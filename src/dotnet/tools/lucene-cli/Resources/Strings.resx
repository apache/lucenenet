<?xml version="1.0" encoding="utf-8"?>
<!--

 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.

-->
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AnalysisCommandDescription" xml:space="preserve">
    <value>Utilities to manage specialized analyzers.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandDescription" xml:space="preserve">
    <value>Generates a set of custom dictionary files for the Lucene.Net.Analysis.Kuromoji library.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandExtendedHelpText" xml:space="preserve">
    <value>Generates the following set of binary files:

- CharacterDefinition.dat
- ConnectionCosts.dat
- TokenInfoDictionary$buffer.dat
- TokenInfoDictionary$fst.dat
- TokenInfoDictionary$posDict.dat
- TokenInfoDictionary$targetMap.dat
- UnknownDictionary$buffer.dat
- UnknownDictionary$posDict.dat
- UnknownDictionary$targetMap.dat

If these files are placed into a subdirectory of your application named 'kuromoji-data', they will be used automatically by Lucene.Net.Analysis.Kuromoji features such as the JapaneseAnalyzer or JapaneseTokenizer. To use an alternate directory location, put the path in an environment variable named 'kuromoji.data.dir'. The files must be placed in a subdirectory of this location named 'kuromoji-data'.

See this blog post (http://mentaldetritus.blogspot.com/2013/03/compiling-custom-dictionary-for.html) for information about the dictionary format. A sample is available at (https://sourceforge.net/projects/mecab/files/mecab-ipadic/2.7.0-20070801/). The Kuromoji project documentation (https://github.com/atilika/kuromoji) may also be helpful.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandFormatDescription" xml:space="preserve">
    <value>The dictionary format. Valid values are IPADIC and UNIDIC. If an invalid value is passed, IPADIC is assumed.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandInputDirectoryDescription" xml:space="preserve">
    <value>The directory where the dictionary input files are located.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandInputDirectoryEncodingDescription" xml:space="preserve">
    <value>The file encoding used by the input files. If not supplied, the default value is EUC-JP.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandNormalizeDescription" xml:space="preserve">
    <value>Normalize the entries using normalization form KC.</value>
  </data>
  <data name="AnalysisKuromojiBuildDictionaryCommandOutputDirectoryDescription" xml:space="preserve">
    <value>The directory to put the dictionary output.</value>
  </data>
  <data name="AnalysisStempelCompileStemsCommandDescription" xml:space="preserve">
    <value>Compiles a stemmer table for the Egothor stemmer.</value>
  </data>
  <data name="AnalysisStempelCompileStemsCommandStemmerTableFilesDescription" xml:space="preserve">
    <value>The path to a file containing a stemmer table. Multiple values are allowed.</value>
  </data>
  <data name="AnalysisStempelCompileStemsCommandStemmerTableFilesEncodingDescription" xml:space="preserve">
    <value>The encoding to use for the stemmer table files. If not supplied, defaults to UTF-8.</value>
  </data>
  <data name="AnalysisStempelCompileStemsCommandStemmingAlgorithmDescription" xml:space="preserve">
    <value>The name of the desired stemming algorithm to use.</value>
  </data>
  <data name="AnalysisStempelPatchStemsCommandDescription" xml:space="preserve">
    <value>Generates patch commands from an already prepared stemmer table.</value>
  </data>
  <data name="AnalysisStempelPatchStemsCommandStemmerTableFilesDescription" xml:space="preserve">
    <value>The path to a file containing a stemmer table. Multiple values are allowed.</value>
  </data>
  <data name="AnalysisStempelPatchStemsCommandStemmerTableFilesEncodingDescription" xml:space="preserve">
    <value>The encoding to use for the stemmer table files. If not supplied, defaults to UTF-8.</value>
  </data>
  <data name="BenchmarkCommandDescription" xml:space="preserve">
    <value>Utilities for benchmarking Lucene.Net.</value>
  </data>
  <data name="BenchmarkExtractReutersCommandDescription" xml:space="preserve">
    <value>Splits Reuters SGML documents into simple text files containing: Title, Date, Dateline, Body.</value>
  </data>
  <data name="BenchmarkExtractReutersCommandInputDirectoryDescription" xml:space="preserve">
    <value>Path to Reuters SGML files.</value>
  </data>
  <data name="BenchmarkExtractReutersCommandOutputDirectoryDescription" xml:space="preserve">
    <value>Path to a directory where the output files will be written.</value>
  </data>
  <data name="BenchmarkExtractWikipediaCommandDescription" xml:space="preserve">
    <value>Extracts a downloaded Wikipedia dump into separate files for indexing.</value>
  </data>
  <data name="BenchmarkExtractWikipediaCommandDiscardImageOnlyDocsDescription" xml:space="preserve">
    <value>Tells the extractor to skip WIKI docs that contain only images.</value>
  </data>
  <data name="BenchmarkExtractWikipediaCommandInputWikipediaFileDescription" xml:space="preserve">
    <value>Input path to a Wikipedia XML file.</value>
  </data>
  <data name="BenchmarkExtractWikipediaCommandOutputDirectoryDescription" xml:space="preserve">
    <value>Path to a directory where the output files will be written.</value>
  </data>
  <data name="BenchmarkFindQualityQueriesCommandDescription" xml:space="preserve">
    <value>Suggests quality queries based on index contents. Used for making quality test benchmarks.</value>
  </data>
  <data name="BenchmarkRunCommandAlgorithmFileDescription" xml:space="preserve">
    <value>An algorithm file specifying the parameters of the benchmark to run.</value>
  </data>
  <data name="BenchmarkRunCommandDescription" xml:space="preserve">
    <value>Runs a benchmark based on an algorithm file.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandDescription" xml:space="preserve">
    <value>Runs a TREC evaluation.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandOutputSubmissionFileDescription" xml:space="preserve">
    <value>Output submission file for TREC evaluation.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandQueryOnDescriptionDescription" xml:space="preserve">
    <value>Use description field in query.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandQueryOnNarrativeDescription" xml:space="preserve">
    <value>Use narrative field in query.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandQueryOnTitleDescription" xml:space="preserve">
    <value>Use title field in query. This flag will automatically be on if no other field is specified.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandQueryRelevanceFileDescription" xml:space="preserve">
    <value>Input file conataining relevance judgements.</value>
  </data>
  <data name="BenchmarkRunTrecEvalCommandTopicsFileDescription" xml:space="preserve">
    <value>Input file containing queries.</value>
  </data>
  <data name="BenchmarkSampleCommandDescription" xml:space="preserve">
    <value>Sample of a performance test written programatically instead of using an algorithm file.</value>
  </data>
  <data name="CrossCheckTermVectorsDescription" xml:space="preserve">
    <value>Cross check term vectors.</value>
  </data>
  <data name="DemoAssociationsFacetsCommandDescription" xml:space="preserve">
    <value>Shows example usage of category associations.</value>
  </data>
  <data name="DemoCommandDescription" xml:space="preserve">
    <value>Demos for various Lucene.Net functionality including C# code samples.</value>
  </data>
  <data name="DemoDistanceFacetsCommandDescription" xml:space="preserve">
    <value>Shows simple usage of dynamic range faceting, using the expressions module to calculate distance.</value>
  </data>
  <data name="DemoExpressionAggregationFacetsCommandDescription" xml:space="preserve">
    <value>Shows facets aggregation by an expression.</value>
  </data>
  <data name="DemoIndexFilesCommandDescription" xml:space="preserve">
    <value>Index all text files under a directory.</value>
  </data>
  <data name="DemoIndexFilesCommandExtendedHelpText" xml:space="preserve">
    <value>This demo can be used to learn how to build a Lucene.Net index. After the index is built, you can run the search-files demo to run queries against it.</value>
  </data>
  <data name="DemoIndexFilesCommandSourceDirectoryDescription" xml:space="preserve">
    <value>The source directory containing files to index. This operation is recursive.</value>
  </data>
  <data name="DemoIndexFilesCommandUpdateDescription" xml:space="preserve">
    <value>Adds new documents to an existing index. If not supplied, any existing index in the &lt;INDEX_DIRECTORY&gt; will be overwritten.</value>
  </data>
  <data name="DemoMultiCategoryListsFacetsCommandDescription" xml:space="preserve">
    <value>Demonstrates indexing categories into different indexed fields.</value>
  </data>
  <data name="DemoRangeFacetsCommandDescription" xml:space="preserve">
    <value>Shows simple usage of dynamic range faceting.</value>
  </data>
  <data name="DemoSearchFilesCommandDescription" xml:space="preserve">
    <value>Simple command-line based search demo. Run index-files demo first.</value>
  </data>
  <data name="DemoSearchFilesCommandExtendedHelpText" xml:space="preserve">
    <value>Run the index-files demo first to create an index to run this command against. You can either use a file containing many queries (each on a single line), a single query on the command line, or omit both options to run queries interactively.</value>
  </data>
  <data name="DemoSearchFilesCommandFieldDescription" xml:space="preserve">
    <value>The index field to use in the search. If not supplied, defaults to "contents".</value>
  </data>
  <data name="DemoSearchFilesCommandPageSizeDescription" xml:space="preserve">
    <value>Hits per page to display.</value>
  </data>
  <data name="DemoSearchFilesCommandQueriesFileDescription" xml:space="preserve">
    <value>A file containing the queries to perform.</value>
  </data>
  <data name="DemoSearchFilesCommandQueryDescription" xml:space="preserve">
    <value>A query to perform.</value>
  </data>
  <data name="DemoSearchFilesCommandRawDescription" xml:space="preserve">
    <value>Output raw format.</value>
  </data>
  <data name="DemoSearchFilesCommandRepeatDescription" xml:space="preserve">
    <value>Repeat the search and time as a benchmark.</value>
  </data>
  <data name="DemoSimpleFacetsCommandDescription" xml:space="preserve">
    <value>Shows simple usage of faceted indexing and search.</value>
  </data>
  <data name="DemoSimpleSortedSetFacetsCommandDescription" xml:space="preserve">
    <value>Shows simple usage of faceted indexing and search using SortedSetDocValuesFacetField and SortedSetDocValuesFacetCounts.</value>
  </data>
  <data name="DirectoryTypeOptionDescription" xml:space="preserve">
    <value>The FSDirectory implementation to use. Defaults to the optimal FSDirectory for your OS platform.</value>
  </data>
  <data name="ExportingSourceCodeCompleteMessage" xml:space="preserve">
    <value>Source code exported to '{0}'.</value>
  </data>
  <data name="ExportingSourceCodeMessage" xml:space="preserve">
    <value>Exporting source code...</value>
  </data>
  <data name="GeneralExceptionMessage" xml:space="preserve">
    <value>An error occurred:</value>
  </data>
  <data name="HelpCommandsMessage" xml:space="preserve">
    <value>Specify --help for a list of available options and commands.</value>
  </data>
  <data name="IndexCheckCommandDescription" xml:space="preserve">
    <value>Checks an index for problematic segments.</value>
  </data>
  <data name="IndexCheckCommandExtendedHelpText" xml:space="preserve">
    <value>Basic tool to check the health of an index. 

As this tool checks every byte in the index, on a large index it can take quite a long time to run.</value>
  </data>
  <data name="IndexCheckCommandSegmentsDescription" xml:space="preserve">
    <value>Only check the specified segment(s). This can be specified multiple times, to check more than one segment, eg --segment _2 --segment _a.</value>
  </data>
  <data name="IndexCommandDescription" xml:space="preserve">
    <value>Utilities to analyze or maintain an index.</value>
  </data>
  <data name="IndexCopySegmentsCommandDescription" xml:space="preserve">
    <value>Copies segments from one index to another index.</value>
  </data>
  <data name="IndexCopySegmentsCommandExtendedHelpText" xml:space="preserve">
    <value>This tool does file-level copying of segments files. This means it's unable to split apart a single segment into multiple segments. For example if your index is a single segment, this tool won't help. Also, it does basic file-level copying (using a simple FileStream) so it will not work with non FSDirectory Directory implementations.</value>
  </data>
  <data name="IndexCopySegmentsCommandInputDirectoryDescription" xml:space="preserve">
    <value>The directory of the index to copy.</value>
  </data>
  <data name="IndexCopySegmentsCommandOutputDirectoryDescription" xml:space="preserve">
    <value>The directory of the destination index.</value>
  </data>
  <data name="IndexCopySegmentsCommandSegmentsDescription" xml:space="preserve">
    <value>The segments to copy, separated by a space.</value>
  </data>
  <data name="IndexDeleteSegmentsCommandDescription" xml:space="preserve">
    <value>Deletes segments from an index.</value>
  </data>
  <data name="IndexDeleteSegmentsCommandExtendedHelpText" xml:space="preserve">
    <value>You can easily accidentally remove segments from your index so be careful! Always make a backup of your index first.</value>
  </data>
  <data name="IndexDeleteSegmentsCommandSegmentsDescription" xml:space="preserve">
    <value>The segments to delete, separated by a space.</value>
  </data>
  <data name="IndexDirectoryArgumentDescription" xml:space="preserve">
    <value>The directory of the index.</value>
  </data>
  <data name="IndexDirectoryOptionalArgumentDescription" xml:space="preserve">
    <value>If omitted, it defaults to the current working directory.</value>
  </data>
  <data name="IndexExtractCfsCommandCFSFileNameDescription" xml:space="preserve">
    <value>The .cfs compound file containing words to parse.</value>
  </data>
  <data name="IndexExtractCfsCommandDescription" xml:space="preserve">
    <value>Extracts sub-files from a .cfs compound file.</value>
  </data>
  <data name="IndexExtractCfsCommandExtendedHelpText" xml:space="preserve">
    <value>Extracts `.cfs` compound files (that were created using the CompoundFileDirectory from Lucene.Net.Misc) to the current working directory.

In order to make the extracted version of the index work, you have to copy the segments file from the compound index into the directory where the extracted files are stored.</value>
  </data>
  <data name="IndexFixCommandDescription" xml:space="preserve">
    <value>Fixes an index by removing problematic segments.</value>
  </data>
  <data name="IndexFixCommandDryRunDescription" xml:space="preserve">
    <value>Doesn't change the index, but reports any actions that would be taken if this option were not supplied.</value>
  </data>
  <data name="IndexFixCommandExtendedHelpText" xml:space="preserve">
    <value>Basic tool to check and fix the health of an index and write a new segments file that removes reference to problematic segments.

As this tool checks every byte in the index, on a large index it can take quite a long time to run. 

WARNING: This command should only be used on an emergency basis as it will cause documents (perhaps many) to be permanently removed from the index. Always make a backup copy of your index before running this! Do not run this tool on an index that is actively being written to. You have been warned!</value>
  </data>
  <data name="IndexListCfsCommandCFSFileNameDescription" xml:space="preserve">
    <value>The .cfs compound file containing words to parse.</value>
  </data>
  <data name="IndexListCfsCommandDescription" xml:space="preserve">
    <value>Lists sub-files out of a .cfs compound file.</value>
  </data>
  <data name="IndexListCfsCommandExtendedHelpText" xml:space="preserve">
    <value>Prints the filename and size of each file within a given `.cfs` compound file. The .cfs compound file format is created using the CompoundFileDirectory from Lucene.Net.Misc.</value>
  </data>
  <data name="IndexListHighFreqTermsCommandDescription" xml:space="preserve">
    <value>Lists the top N most frequent terms by document frequency.</value>
  </data>
  <data name="IndexListHighFreqTermsCommandExtendedHelpText" xml:space="preserve">
    <value>Extracts the top N most frequent terms (by document frequency) from an index and reports thier document frequency.</value>
  </data>
  <data name="IndexListHighFreqTermsCommandFieldDescription" xml:space="preserve">
    <value>The field to consider. If omitted, considers all fields.</value>
  </data>
  <data name="IndexListHighFreqTermsCommandNumberOfTermsDescription" xml:space="preserve">
    <value>The number of terms to consider. If omitted, defaults to 100.</value>
  </data>
  <data name="IndexListHighFreqTermsCommandTotalTermFrequencyDescription" xml:space="preserve">
    <value>Specifies that both the document frequency &amp; term frequency are reported, ordered by descending total term frequency.</value>
  </data>
  <data name="IndexListSegmentsCommandDescription" xml:space="preserve">
    <value>Lists segments in an index.</value>
  </data>
  <data name="IndexListSegmentsExtendedHelpText" xml:space="preserve">
    <value>After running this command to view segments, use copy-segments to copy segments from one index directory to another or delete-segments to remove segments from an index.</value>
  </data>
  <data name="IndexListTaxonomyStatsCommandDescription" xml:space="preserve">
    <value>Displays the taxonomy statistical information for a taxonomy index.</value>
  </data>
  <data name="IndexListTaxonomyStatsCommandExtendedHelpText" xml:space="preserve">
    <value>Prints how many ords are under each dimension.</value>
  </data>
  <data name="IndexListTaxonomyStatsCommandShowTreeDescription" xml:space="preserve">
    <value>Recursively lists all descendant nodes.</value>
  </data>
  <data name="IndexListTermInfoCommandDescription" xml:space="preserve">
    <value>Gets document frequency and total number of occurrences of a term.</value>
  </data>
  <data name="IndexListTermInfoCommandExtendedHelpText" xml:space="preserve">
    <value>Gets document frequency and total number of occurrences (sum of the term frequency for each document) of a term.</value>
  </data>
  <data name="IndexListTermInfoCommandFieldDescription" xml:space="preserve">
    <value>The field to consider.</value>
  </data>
  <data name="IndexListTermInfoCommandIndexDirectoryDescription" xml:space="preserve">
    <value>The directory of the index.</value>
  </data>
  <data name="IndexListTermInfoCommandTermDescription" xml:space="preserve">
    <value>The term to consider.</value>
  </data>
  <data name="IndexMergeCommandDescription" xml:space="preserve">
    <value>Merges multiple indexes into a single index.</value>
  </data>
  <data name="IndexMergeCommandInputDirectoryDescription" xml:space="preserve">
    <value>Two or more source index directories separated by a space.</value>
  </data>
  <data name="IndexMergeCommandOutputDirectoryDescription" xml:space="preserve">
    <value>The output directory to merge the input indexes into.</value>
  </data>
  <data name="IndexSplitCommandDescription" xml:space="preserve">
    <value>Splits an index into multiple parts.</value>
  </data>
  <data name="IndexSplitCommandExtendedHelpText" xml:space="preserve">
    <value>Splits the input index into multiple equal parts. The method employed here uses IndexWriter.AddIndexes(IndexReader[]) where the input data comes from the input index with artificially applied deletes to the document ids that fall outside the selected partition.

Deletes are only applied to a buffered list of deleted documents and don't affect the source index. This tool works also with read-only indexes.

The disadvantage of this tool is that source index needs to be read as many times as there are parts to be created. The multiple passes may be slow.

NOTE: This tool is unaware of documents added automatically via IndexWriter.AddDocuments(IEnumerable&lt;IEnumerable&lt;IIndexableField&gt;&gt;, Analyzer) or IndexWriter.UpdateDocuments(Term, IEnumerable&lt;IEnumerable&lt;IIndexableField&gt;&gt;, Analyzer), which means it can easily break up such document groups.</value>
  </data>
  <data name="IndexSplitCommandInputDirectoryDescription" xml:space="preserve">
    <value>The path of the source index, which can have deletions and can have multiple segments (or multiple readers). Multiple values can be supplied separated by a space.</value>
  </data>
  <data name="IndexSplitCommandNumberOfPartsDescription" xml:space="preserve">
    <value>The number of parts (output indices) to produce. If omitted, defaults to 2.</value>
  </data>
  <data name="IndexSplitCommandOutputDirectoryDescription" xml:space="preserve">
    <value>Path to output directory to contain partial indexes.</value>
  </data>
  <data name="IndexSplitCommandSequentialDescription" xml:space="preserve">
    <value>Sequential doc-id range split (default is round-robin).</value>
  </data>
  <data name="IndexUpgradeCommandDeleteDescription" xml:space="preserve">
    <value>Deletes prior commits.</value>
  </data>
  <data name="IndexUpgradeCommandDescription" xml:space="preserve">
    <value>Upgrades all segments of an index from previous Lucene.Net versions to the current segment file format.</value>
  </data>
  <data name="IndexUpgradeCommandExtendedHelpText" xml:space="preserve">
    <value>This tool keeps only the last commit in an index; for this reason, if the incoming index has more than one commit, the tool refuses to run by default. Specify --delete-prior-commits to override this, allowing the tool to delete all but the last commit. 

Specify an FSDirectory implementation through the --directory-type option to force its use. If not qualified by an AssemblyName, the Lucene.Net.dll assembly will be used. 

WARNING: This tool may reorder document IDs! Be sure to make a backup of your index before you use this. Also, ensure you are using the correct version of this utility to match your application's version of Lucene.Net. This operation cannot be reversed.</value>
  </data>
  <data name="LockCommandDescription" xml:space="preserve">
    <value>Utilities for verifying concurrent locking integrity.</value>
  </data>
  <data name="LockStressTestCommandDescription" xml:space="preserve">
    <value>Simple tool that forever acquires and releases a lock using a specific LockFactory.</value>
  </data>
  <data name="LockStressTestCommandExtendedHelpText" xml:space="preserve">
    <value>You should run multiple instances of this process, each with its own unique ID, and each pointing to the same lock directory, to verify that locking is working correctly. Make sure you are first running verify-server.</value>
  </data>
  <data name="LockStressTestCommandIDDescription" xml:space="preserve">
    <value>An integer from 0 - 255 (should be unique for test process).</value>
  </data>
  <data name="LockStressTestCommandLockDirectoryDescription" xml:space="preserve">
    <value>The path to the lock directory (only utilized if LOCK_FACTORY_TYPE is set to SimpleFSLockFactory or NativeFSLockFactory).</value>
  </data>
  <data name="LockStressTestCommandLockFactoryTypeDescription" xml:space="preserve">
    <value>The primary LockFactory implementation that we will use.</value>
  </data>
  <data name="LockStressTestCommandSleepTimeMSDescription" xml:space="preserve">
    <value>Milliseconds to pause between each lock obtain/release.</value>
  </data>
  <data name="LockStressTestCommandTriesDescription" xml:space="preserve">
    <value>Number of locking tries.</value>
  </data>
  <data name="LockStressTestCommandVerfierPortDescription" xml:space="preserve">
    <value>Port that verify-server is listening on.</value>
  </data>
  <data name="LockStressTestCommandVerifierHostDescription" xml:space="preserve">
    <value>Hostname or IP address that verify-server is listening on.</value>
  </data>
  <data name="LockVerifyServerCommandDescription" xml:space="preserve">
    <value>Simple server that must be running when you use VerifyingLockFactory (or stress-test). This server verifies at most one process holds the lock at a time.</value>
  </data>
  <data name="LockVerifyServerCommandIPHostnameDescription" xml:space="preserve">
    <value>Hostname or IP address that verify-server will listen on.</value>
  </data>
  <data name="LockVerifyServerCommandMaxClientsDescription" xml:space="preserve">
    <value>The maximum number of connected clients.</value>
  </data>
  <data name="NotEnoughArguments" xml:space="preserve">
    <value>{0} arguments are required.</value>
  </data>
  <data name="OutputSourceCodeDescription" xml:space="preserve">
    <value>Output the source code of the demo to the specified directory.</value>
  </data>
  <data name="OutputSourceCodeMessage" xml:space="preserve">
    <value>Run 'demo {0} --view-source-code' to see the C# code or 'demo {0} --output-source-code &lt;DIRECTORY&gt;' to export the code to a local directory.</value>
  </data>
  <data name="RootCommandDescription" xml:space="preserve">
    <value>Utilities and demos for Lucene.Net.</value>
  </data>
  <data name="SegmentsArgumentDescription" xml:space="preserve">
    <value>One or more segments, separated by a space.</value>
  </data>
  <data name="SegmentsOptionDescription" xml:space="preserve">
    <value>An index segment.</value>
  </data>
  <data name="SegmentsOptionMultipleDescription" xml:space="preserve">
    <value>Multiple segments are allowed.</value>
  </data>
  <data name="VerboseOptionDescription" xml:space="preserve">
    <value>Verbose output.</value>
  </data>
  <data name="ViewSourceCodeDescription" xml:space="preserve">
    <value>View the source code of the demo.</value>
  </data>
</root>
// Lucene version compatibility level 4.8.1
/*

Copyright (c) 2001, Dr Martin Porter
Copyright (c) 2002, Richard Boulton
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    * this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    * notice, this list of conditions and the following disclaimer in the
    * documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holders nor the names of its contributors
    * may be used to endorse or promote products derived from this software
    * without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */

namespace Lucene.Net.Tartarus.Snowball.Ext
{
    /// <summary>
    /// This class was automatically generated by a Snowball to Java compiler
    /// It implements the stemming algorithm defined by a snowball script.
    /// </summary>
    public class PortugueseStemmer : SnowballProgram
    {
        // LUCENENET specific: Factored out methodObject by using Func<bool> instead of Reflection

        private readonly static Among[] a_0 = {
                    new Among ( "", -1, 3 ),
                    new Among ( "\u00E3", 0, 1 ),
                    new Among ( "\u00F5", 0, 2 )
                };

        private readonly static Among[] a_1 = {
                    new Among ( "", -1, 3 ),
                    new Among ( "a~", 0, 1 ),
                    new Among ( "o~", 0, 2 )
                };

        private readonly static Among[] a_2 = {
                    new Among ( "ic", -1, -1 ),
                    new Among ( "ad", -1, -1 ),
                    new Among ( "os", -1, -1 ),
                    new Among ( "iv", -1, 1 )
                };

        private readonly static Among[] a_3 = {
                    new Among ( "ante", -1, 1 ),
                    new Among ( "avel", -1, 1 ),
                    new Among ( "\u00EDvel", -1, 1 )
                };

        private readonly static Among[] a_4 = {
                    new Among ( "ic", -1, 1 ),
                    new Among ( "abil", -1, 1 ),
                    new Among ( "iv", -1, 1 )
                };

        private readonly static Among[] a_5 = {
                    new Among ( "ica", -1, 1 ),
                    new Among ( "\u00E2ncia", -1, 1 ),
                    new Among ( "\u00EAncia", -1, 4 ),
                    new Among ( "ira", -1, 9 ),
                    new Among ( "adora", -1, 1 ),
                    new Among ( "osa", -1, 1 ),
                    new Among ( "ista", -1, 1 ),
                    new Among ( "iva", -1, 8 ),
                    new Among ( "eza", -1, 1 ),
                    new Among ( "log\u00EDa", -1, 2 ),
                    new Among ( "idade", -1, 7 ),
                    new Among ( "ante", -1, 1 ),
                    new Among ( "mente", -1, 6 ),
                    new Among ( "amente", 12, 5 ),
                    new Among ( "\u00E1vel", -1, 1 ),
                    new Among ( "\u00EDvel", -1, 1 ),
                    new Among ( "uci\u00F3n", -1, 3 ),
                    new Among ( "ico", -1, 1 ),
                    new Among ( "ismo", -1, 1 ),
                    new Among ( "oso", -1, 1 ),
                    new Among ( "amento", -1, 1 ),
                    new Among ( "imento", -1, 1 ),
                    new Among ( "ivo", -1, 8 ),
                    new Among ( "a\u00E7a~o", -1, 1 ),
                    new Among ( "ador", -1, 1 ),
                    new Among ( "icas", -1, 1 ),
                    new Among ( "\u00EAncias", -1, 4 ),
                    new Among ( "iras", -1, 9 ),
                    new Among ( "adoras", -1, 1 ),
                    new Among ( "osas", -1, 1 ),
                    new Among ( "istas", -1, 1 ),
                    new Among ( "ivas", -1, 8 ),
                    new Among ( "ezas", -1, 1 ),
                    new Among ( "log\u00EDas", -1, 2 ),
                    new Among ( "idades", -1, 7 ),
                    new Among ( "uciones", -1, 3 ),
                    new Among ( "adores", -1, 1 ),
                    new Among ( "antes", -1, 1 ),
                    new Among ( "a\u00E7o~es", -1, 1 ),
                    new Among ( "icos", -1, 1 ),
                    new Among ( "ismos", -1, 1 ),
                    new Among ( "osos", -1, 1 ),
                    new Among ( "amentos", -1, 1 ),
                    new Among ( "imentos", -1, 1 ),
                    new Among ( "ivos", -1, 8 )
                };

        private readonly static Among[] a_6 = {
                    new Among ( "ada", -1, 1 ),
                    new Among ( "ida", -1, 1 ),
                    new Among ( "ia", -1, 1 ),
                    new Among ( "aria", 2, 1 ),
                    new Among ( "eria", 2, 1 ),
                    new Among ( "iria", 2, 1 ),
                    new Among ( "ara", -1, 1 ),
                    new Among ( "era", -1, 1 ),
                    new Among ( "ira", -1, 1 ),
                    new Among ( "ava", -1, 1 ),
                    new Among ( "asse", -1, 1 ),
                    new Among ( "esse", -1, 1 ),
                    new Among ( "isse", -1, 1 ),
                    new Among ( "aste", -1, 1 ),
                    new Among ( "este", -1, 1 ),
                    new Among ( "iste", -1, 1 ),
                    new Among ( "ei", -1, 1 ),
                    new Among ( "arei", 16, 1 ),
                    new Among ( "erei", 16, 1 ),
                    new Among ( "irei", 16, 1 ),
                    new Among ( "am", -1, 1 ),
                    new Among ( "iam", 20, 1 ),
                    new Among ( "ariam", 21, 1 ),
                    new Among ( "eriam", 21, 1 ),
                    new Among ( "iriam", 21, 1 ),
                    new Among ( "aram", 20, 1 ),
                    new Among ( "eram", 20, 1 ),
                    new Among ( "iram", 20, 1 ),
                    new Among ( "avam", 20, 1 ),
                    new Among ( "em", -1, 1 ),
                    new Among ( "arem", 29, 1 ),
                    new Among ( "erem", 29, 1 ),
                    new Among ( "irem", 29, 1 ),
                    new Among ( "assem", 29, 1 ),
                    new Among ( "essem", 29, 1 ),
                    new Among ( "issem", 29, 1 ),
                    new Among ( "ado", -1, 1 ),
                    new Among ( "ido", -1, 1 ),
                    new Among ( "ando", -1, 1 ),
                    new Among ( "endo", -1, 1 ),
                    new Among ( "indo", -1, 1 ),
                    new Among ( "ara~o", -1, 1 ),
                    new Among ( "era~o", -1, 1 ),
                    new Among ( "ira~o", -1, 1 ),
                    new Among ( "ar", -1, 1 ),
                    new Among ( "er", -1, 1 ),
                    new Among ( "ir", -1, 1 ),
                    new Among ( "as", -1, 1 ),
                    new Among ( "adas", 47, 1 ),
                    new Among ( "idas", 47, 1 ),
                    new Among ( "ias", 47, 1 ),
                    new Among ( "arias", 50, 1 ),
                    new Among ( "erias", 50, 1 ),
                    new Among ( "irias", 50, 1 ),
                    new Among ( "aras", 47, 1 ),
                    new Among ( "eras", 47, 1 ),
                    new Among ( "iras", 47, 1 ),
                    new Among ( "avas", 47, 1 ),
                    new Among ( "es", -1, 1 ),
                    new Among ( "ardes", 58, 1 ),
                    new Among ( "erdes", 58, 1 ),
                    new Among ( "irdes", 58, 1 ),
                    new Among ( "ares", 58, 1 ),
                    new Among ( "eres", 58, 1 ),
                    new Among ( "ires", 58, 1 ),
                    new Among ( "asses", 58, 1 ),
                    new Among ( "esses", 58, 1 ),
                    new Among ( "isses", 58, 1 ),
                    new Among ( "astes", 58, 1 ),
                    new Among ( "estes", 58, 1 ),
                    new Among ( "istes", 58, 1 ),
                    new Among ( "is", -1, 1 ),
                    new Among ( "ais", 71, 1 ),
                    new Among ( "eis", 71, 1 ),
                    new Among ( "areis", 73, 1 ),
                    new Among ( "ereis", 73, 1 ),
                    new Among ( "ireis", 73, 1 ),
                    new Among ( "\u00E1reis", 73, 1 ),
                    new Among ( "\u00E9reis", 73, 1 ),
                    new Among ( "\u00EDreis", 73, 1 ),
                    new Among ( "\u00E1sseis", 73, 1 ),
                    new Among ( "\u00E9sseis", 73, 1 ),
                    new Among ( "\u00EDsseis", 73, 1 ),
                    new Among ( "\u00E1veis", 73, 1 ),
                    new Among ( "\u00EDeis", 73, 1 ),
                    new Among ( "ar\u00EDeis", 84, 1 ),
                    new Among ( "er\u00EDeis", 84, 1 ),
                    new Among ( "ir\u00EDeis", 84, 1 ),
                    new Among ( "ados", -1, 1 ),
                    new Among ( "idos", -1, 1 ),
                    new Among ( "amos", -1, 1 ),
                    new Among ( "\u00E1ramos", 90, 1 ),
                    new Among ( "\u00E9ramos", 90, 1 ),
                    new Among ( "\u00EDramos", 90, 1 ),
                    new Among ( "\u00E1vamos", 90, 1 ),
                    new Among ( "\u00EDamos", 90, 1 ),
                    new Among ( "ar\u00EDamos", 95, 1 ),
                    new Among ( "er\u00EDamos", 95, 1 ),
                    new Among ( "ir\u00EDamos", 95, 1 ),
                    new Among ( "emos", -1, 1 ),
                    new Among ( "aremos", 99, 1 ),
                    new Among ( "eremos", 99, 1 ),
                    new Among ( "iremos", 99, 1 ),
                    new Among ( "\u00E1ssemos", 99, 1 ),
                    new Among ( "\u00EAssemos", 99, 1 ),
                    new Among ( "\u00EDssemos", 99, 1 ),
                    new Among ( "imos", -1, 1 ),
                    new Among ( "armos", -1, 1 ),
                    new Among ( "ermos", -1, 1 ),
                    new Among ( "irmos", -1, 1 ),
                    new Among ( "\u00E1mos", -1, 1 ),
                    new Among ( "ar\u00E1s", -1, 1 ),
                    new Among ( "er\u00E1s", -1, 1 ),
                    new Among ( "ir\u00E1s", -1, 1 ),
                    new Among ( "eu", -1, 1 ),
                    new Among ( "iu", -1, 1 ),
                    new Among ( "ou", -1, 1 ),
                    new Among ( "ar\u00E1", -1, 1 ),
                    new Among ( "er\u00E1", -1, 1 ),
                    new Among ( "ir\u00E1", -1, 1 )
                };

        private readonly static Among[] a_7 = {
                    new Among ( "a", -1, 1 ),
                    new Among ( "i", -1, 1 ),
                    new Among ( "o", -1, 1 ),
                    new Among ( "os", -1, 1 ),
                    new Among ( "\u00E1", -1, 1 ),
                    new Among ( "\u00ED", -1, 1 ),
                    new Among ( "\u00F3", -1, 1 )
                };

        private readonly static Among[] a_8 = {
                    new Among ( "e", -1, 1 ),
                    new Among ( "\u00E7", -1, 2 ),
                    new Among ( "\u00E9", -1, 1 ),
                    new Among ( "\u00EA", -1, 1 )
                };

        private static readonly char[] g_v = { (char)17, (char)65, (char)16, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)3, (char)19, (char)12, (char)2 };

        private int I_p2;
        private int I_p1;
        private int I_pV;

        private void copy_from(PortugueseStemmer other)
        {
            I_p2 = other.I_p2;
            I_p1 = other.I_p1;
            I_pV = other.I_pV;
            base.CopyFrom(other);
        }

        private bool r_prelude()
        {
            int among_var;
            int v_1;
            // repeat, line 36
            while (true)
            {
                v_1 = m_cursor;
                do
                {
                    // (, line 36
                    // [, line 37
                    m_bra = m_cursor;
                    // substring, line 37
                    among_var = FindAmong(a_0, 3);
                    if (among_var == 0)
                    {
                        goto lab1;
                    }
                    // ], line 37
                    m_ket = m_cursor;
                    switch (among_var)
                    {
                        case 0:
                            goto lab1;
                        case 1:
                            // (, line 38
                            // <-, line 38
                            SliceFrom("a~");
                            break;
                        case 2:
                            // (, line 39
                            // <-, line 39
                            SliceFrom("o~");
                            break;
                        case 3:
                            // (, line 40
                            // next, line 40
                            if (m_cursor >= m_limit)
                            {
                                goto lab1;
                            }
                            m_cursor++;
                            break;
                    }
                    // LUCENENET NOTE: continue label is not supported directly in .NET,
                    // so we just need to add another goto to get to the end of the outer loop.
                    // See: http://stackoverflow.com/a/359449/181087

                    // Original code:
                    //continue replab0;

                    goto end_of_outer_loop;

                } while (false);
                lab1:
                m_cursor = v_1;
                goto replab0;
                end_of_outer_loop: { }
            }
            replab0:
            return true;
        }

        private bool r_mark_regions()
        {
            int v_1;
            int v_2;
            int v_3;
            int v_6;
            int v_8;
            // (, line 44
            I_pV = m_limit;
            I_p1 = m_limit;
            I_p2 = m_limit;
            // do, line 50
            v_1 = m_cursor;
            do
            {
                // (, line 50
                // or, line 52
                do
                {
                    v_2 = m_cursor;
                    do
                    {
                        // (, line 51
                        if (!(InGrouping(g_v, 97, 250)))
                        {
                            goto lab2;
                        }
                        // or, line 51
                        do
                        {
                            v_3 = m_cursor;
                            do
                            {
                                // (, line 51
                                if (!(OutGrouping(g_v, 97, 250)))
                                {
                                    goto lab4;
                                }
                                // gopast, line 51
                                while (true)
                                {
                                    do
                                    {
                                        if (!(InGrouping(g_v, 97, 250)))
                                        {
                                            goto lab6;
                                        }
                                        goto golab5;
                                    } while (false);
                                    lab6:
                                    if (m_cursor >= m_limit)
                                    {
                                        goto lab4;
                                    }
                                    m_cursor++;
                                }
                                golab5:
                                goto lab3;
                            } while (false);
                            lab4:
                            m_cursor = v_3;
                            // (, line 51
                            if (!(InGrouping(g_v, 97, 250)))
                            {
                                goto lab2;
                            }
                            // gopast, line 51
                            while (true)
                            {
                                do
                                {
                                    if (!(OutGrouping(g_v, 97, 250)))
                                    {
                                        goto lab8;
                                    }
                                    goto golab7;
                                } while (false);
                                lab8:
                                if (m_cursor >= m_limit)
                                {
                                    goto lab2;
                                }
                                m_cursor++;
                            }
                            golab7: {/* LUCENENET: intentionally blank */}
                        } while (false);
                        lab3:
                        goto lab1;
                    } while (false);
                    lab2:
                    m_cursor = v_2;
                    // (, line 53
                    if (!(OutGrouping(g_v, 97, 250)))
                    {
                        goto lab0;
                    }
                    // or, line 53
                    do
                    {
                        v_6 = m_cursor;
                        do
                        {
                            // (, line 53
                            if (!(OutGrouping(g_v, 97, 250)))
                            {
                                goto lab10;
                            }
                            // gopast, line 53
                            while (true)
                            {
                                do
                                {
                                    if (!(InGrouping(g_v, 97, 250)))
                                    {
                                        goto lab12;
                                    }
                                    goto golab11;
                                } while (false);
                                lab12:
                                if (m_cursor >= m_limit)
                                {
                                    goto lab10;
                                }
                                m_cursor++;
                            }
                            golab11:
                            goto lab9;
                        } while (false);
                        lab10:
                        m_cursor = v_6;
                        // (, line 53
                        if (!(InGrouping(g_v, 97, 250)))
                        {
                            goto lab0;
                        }
                        // next, line 53
                        if (m_cursor >= m_limit)
                        {
                            goto lab0;
                        }
                        m_cursor++;
                    } while (false);
                    lab9: {/* LUCENENET: intentionally blank */}
                } while (false);
                lab1:
                // setmark pV, line 54
                I_pV = m_cursor;
            } while (false);
            lab0:
            m_cursor = v_1;
            // do, line 56
            v_8 = m_cursor;
            do
            {
                // (, line 56
                // gopast, line 57
                while (true)
                {
                    do
                    {
                        if (!(InGrouping(g_v, 97, 250)))
                        {
                            goto lab15;
                        }
                        goto golab14;
                    } while (false);
                    lab15:
                    if (m_cursor >= m_limit)
                    {
                        goto lab13;
                    }
                    m_cursor++;
                }
                golab14:
                // gopast, line 57
                while (true)
                {
                    do
                    {
                        if (!(OutGrouping(g_v, 97, 250)))
                        {
                            goto lab17;
                        }
                        goto golab16;
                    } while (false);
                    lab17:
                    if (m_cursor >= m_limit)
                    {
                        goto lab13;
                    }
                    m_cursor++;
                }
                golab16:
                // setmark p1, line 57
                I_p1 = m_cursor;
                // gopast, line 58
                while (true)
                {
                    do
                    {
                        if (!(InGrouping(g_v, 97, 250)))
                        {
                            goto lab19;
                        }
                        goto golab18;
                    } while (false);
                    lab19:
                    if (m_cursor >= m_limit)
                    {
                        goto lab13;
                    }
                    m_cursor++;
                }
                golab18:
                // gopast, line 58
                while (true)
                {
                    do
                    {
                        if (!(OutGrouping(g_v, 97, 250)))
                        {
                            goto lab21;
                        }
                        goto golab20;
                    } while (false);
                    lab21:
                    if (m_cursor >= m_limit)
                    {
                        goto lab13;
                    }
                    m_cursor++;
                }
                golab20:
                // setmark p2, line 58
                I_p2 = m_cursor;
            } while (false);
            lab13:
            m_cursor = v_8;
            return true;
        }

        private bool r_postlude()
        {
            int among_var;
            int v_1;
            // repeat, line 62
            while (true)
            {
                v_1 = m_cursor;
                do
                {
                    // (, line 62
                    // [, line 63
                    m_bra = m_cursor;
                    // substring, line 63
                    among_var = FindAmong(a_1, 3);
                    if (among_var == 0)
                    {
                        goto lab1;
                    }
                    // ], line 63
                    m_ket = m_cursor;
                    switch (among_var)
                    {
                        case 0:
                            goto lab1;
                        case 1:
                            // (, line 64
                            // <-, line 64
                            SliceFrom("\u00E3");
                            break;
                        case 2:
                            // (, line 65
                            // <-, line 65
                            SliceFrom("\u00F5");
                            break;
                        case 3:
                            // (, line 66
                            // next, line 66
                            if (m_cursor >= m_limit)
                            {
                                goto lab1;
                            }
                            m_cursor++;
                            break;
                    }
                    // LUCENENET NOTE: continue label is not supported directly in .NET,
                    // so we just need to add another goto to get to the end of the outer loop.
                    // See: http://stackoverflow.com/a/359449/181087

                    // Original code:
                    //continue replab0;

                    goto end_of_outer_loop;

                } while (false);
                lab1:
                m_cursor = v_1;
                goto replab0;
                end_of_outer_loop: { }
            }
            replab0:
            return true;
        }

        private bool r_RV()
        {
            if (!(I_pV <= m_cursor))
            {
                return false;
            }
            return true;
        }

        private bool r_R1()
        {
            if (!(I_p1 <= m_cursor))
            {
                return false;
            }
            return true;
        }

        private bool r_R2()
        {
            if (!(I_p2 <= m_cursor))
            {
                return false;
            }
            return true;
        }

        private bool r_standard_suffix()
        {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            // (, line 76
            // [, line 77
            m_ket = m_cursor;
            // substring, line 77
            among_var = FindAmongB(a_5, 45);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 77
            m_bra = m_cursor;
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 92
                    // call R2, line 93
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 93
                    SliceDel();
                    break;
                case 2:
                    // (, line 97
                    // call R2, line 98
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 98
                    SliceFrom("log");
                    break;
                case 3:
                    // (, line 101
                    // call R2, line 102
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 102
                    SliceFrom("u");
                    break;
                case 4:
                    // (, line 105
                    // call R2, line 106
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 106
                    SliceFrom("ente");
                    break;
                case 5:
                    // (, line 109
                    // call R1, line 110
                    if (!r_R1())
                    {
                        return false;
                    }
                    // delete, line 110
                    SliceDel();
                    // try, line 111
                    v_1 = m_limit - m_cursor;
                    do
                    {
                        // (, line 111
                        // [, line 112
                        m_ket = m_cursor;
                        // substring, line 112
                        among_var = FindAmongB(a_2, 4);
                        if (among_var == 0)
                        {
                            m_cursor = m_limit - v_1;
                            goto lab0;
                        }
                        // ], line 112
                        m_bra = m_cursor;
                        // call R2, line 112
                        if (!r_R2())
                        {
                            m_cursor = m_limit - v_1;
                            goto lab0;
                        }
                        // delete, line 112
                        SliceDel();
                        switch (among_var)
                        {
                            case 0:
                                m_cursor = m_limit - v_1;
                                goto lab0;
                            case 1:
                                // (, line 113
                                // [, line 113
                                m_ket = m_cursor;
                                // literal, line 113
                                if (!(Eq_S_B(2, "at")))
                                {
                                    m_cursor = m_limit - v_1;
                                    goto lab0;
                                }
                                // ], line 113
                                m_bra = m_cursor;
                                // call R2, line 113
                                if (!r_R2())
                                {
                                    m_cursor = m_limit - v_1;
                                    goto lab0;
                                }
                                // delete, line 113
                                SliceDel();
                                break;
                        }
                    } while (false);
                    lab0:
                    break;
                case 6:
                    // (, line 121
                    // call R2, line 122
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 122
                    SliceDel();
                    // try, line 123
                    v_2 = m_limit - m_cursor;
                    do
                    {
                        // (, line 123
                        // [, line 124
                        m_ket = m_cursor;
                        // substring, line 124
                        among_var = FindAmongB(a_3, 3);
                        if (among_var == 0)
                        {
                            m_cursor = m_limit - v_2;
                            goto lab1;
                        }
                        // ], line 124
                        m_bra = m_cursor;
                        switch (among_var)
                        {
                            case 0:
                                m_cursor = m_limit - v_2;
                                goto lab1;
                            case 1:
                                // (, line 127
                                // call R2, line 127
                                if (!r_R2())
                                {
                                    m_cursor = m_limit - v_2;
                                    goto lab1;
                                }
                                // delete, line 127
                                SliceDel();
                                break;
                        }
                    } while (false);
                    lab1:
                    break;
                case 7:
                    // (, line 133
                    // call R2, line 134
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 134
                    SliceDel();
                    // try, line 135
                    v_3 = m_limit - m_cursor;
                    do
                    {
                        // (, line 135
                        // [, line 136
                        m_ket = m_cursor;
                        // substring, line 136
                        among_var = FindAmongB(a_4, 3);
                        if (among_var == 0)
                        {
                            m_cursor = m_limit - v_3;
                            goto lab2;
                        }
                        // ], line 136
                        m_bra = m_cursor;
                        switch (among_var)
                        {
                            case 0:
                                m_cursor = m_limit - v_3;
                                goto lab2;
                            case 1:
                                // (, line 139
                                // call R2, line 139
                                if (!r_R2())
                                {
                                    m_cursor = m_limit - v_3;
                                    goto lab2;
                                }
                                // delete, line 139
                                SliceDel();
                                break;
                        }
                    } while (false);
                    lab2:
                    break;
                case 8:
                    // (, line 145
                    // call R2, line 146
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 146
                    SliceDel();
                    // try, line 147
                    v_4 = m_limit - m_cursor;
                    do
                    {
                        // (, line 147
                        // [, line 148
                        m_ket = m_cursor;
                        // literal, line 148
                        if (!(Eq_S_B(2, "at")))
                        {
                            m_cursor = m_limit - v_4;
                            goto lab3;
                        }
                        // ], line 148
                        m_bra = m_cursor;
                        // call R2, line 148
                        if (!r_R2())
                        {
                            m_cursor = m_limit - v_4;
                            goto lab3;
                        }
                        // delete, line 148
                        SliceDel();
                    } while (false);
                    lab3:
                    break;
                case 9:
                    // (, line 152
                    // call RV, line 153
                    if (!r_RV())
                    {
                        return false;
                    }
                    // literal, line 153
                    if (!(Eq_S_B(1, "e")))
                    {
                        return false;
                    }
                    // <-, line 154
                    SliceFrom("ir");
                    break;
            }
            return true;
        }

        private bool r_verb_suffix()
        {
            int among_var;
            int v_1;
            int v_2;
            // setlimit, line 159
            v_1 = m_limit - m_cursor;
            // tomark, line 159
            if (m_cursor < I_pV)
            {
                return false;
            }
            m_cursor = I_pV;
            v_2 = m_limit_backward;
            m_limit_backward = m_cursor;
            m_cursor = m_limit - v_1;
            // (, line 159
            // [, line 160
            m_ket = m_cursor;
            // substring, line 160
            among_var = FindAmongB(a_6, 120);
            if (among_var == 0)
            {
                m_limit_backward = v_2;
                return false;
            }
            // ], line 160
            m_bra = m_cursor;
            switch (among_var)
            {
                case 0:
                    m_limit_backward = v_2;
                    return false;
                case 1:
                    // (, line 179
                    // delete, line 179
                    SliceDel();
                    break;
            }
            m_limit_backward = v_2;
            return true;
        }

        private bool r_residual_suffix()
        {
            int among_var;
            // (, line 183
            // [, line 184
            m_ket = m_cursor;
            // substring, line 184
            among_var = FindAmongB(a_7, 7);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 184
            m_bra = m_cursor;
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 187
                    // call RV, line 187
                    if (!r_RV())
                    {
                        return false;
                    }
                    // delete, line 187
                    SliceDel();
                    break;
            }
            return true;
        }

        private bool r_residual_form()
        {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            // (, line 191
            // [, line 192
            m_ket = m_cursor;
            // substring, line 192
            among_var = FindAmongB(a_8, 4);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 192
            m_bra = m_cursor;
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 194
                    // call RV, line 194
                    if (!r_RV())
                    {
                        return false;
                    }
                    // delete, line 194
                    SliceDel();
                    // [, line 194
                    m_ket = m_cursor;
                    // or, line 194
                    do
                    {
                        v_1 = m_limit - m_cursor;
                        do
                        {
                            // (, line 194
                            // literal, line 194
                            if (!(Eq_S_B(1, "u")))
                            {
                                goto lab1;
                            }
                            // ], line 194
                            m_bra = m_cursor;
                            // test, line 194
                            v_2 = m_limit - m_cursor;
                            // literal, line 194
                            if (!(Eq_S_B(1, "g")))
                            {
                                goto lab1;
                            }
                            m_cursor = m_limit - v_2;
                            goto lab0;
                        } while (false);
                        lab1:
                        m_cursor = m_limit - v_1;
                        // (, line 195
                        // literal, line 195
                        if (!(Eq_S_B(1, "i")))
                        {
                            return false;
                        }
                        // ], line 195
                        m_bra = m_cursor;
                        // test, line 195
                        v_3 = m_limit - m_cursor;
                        // literal, line 195
                        if (!(Eq_S_B(1, "c")))
                        {
                            return false;
                        }
                        m_cursor = m_limit - v_3;
                    } while (false);
                    lab0:
                    // call RV, line 195
                    if (!r_RV())
                    {
                        return false;
                    }
                    // delete, line 195
                    SliceDel();
                    break;
                case 2:
                    // (, line 196
                    // <-, line 196
                    SliceFrom("c");
                    break;
            }
            return true;
        }


        public override bool Stem()
        {
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            int v_6;
            int v_7;
            int v_8;
            int v_9;
            int v_10;
            // (, line 201
            // do, line 202
            v_1 = m_cursor;
            do
            {
                // call prelude, line 202
                if (!r_prelude())
                {
                    goto lab0;
                }
            } while (false);
            lab0:
            m_cursor = v_1;
            // do, line 203
            v_2 = m_cursor;
            do
            {
                // call mark_regions, line 203
                if (!r_mark_regions())
                {
                    goto lab1;
                }
            } while (false);
            lab1:
            m_cursor = v_2;
            // backwards, line 204
            m_limit_backward = m_cursor; m_cursor = m_limit;
            // (, line 204
            // do, line 205
            v_3 = m_limit - m_cursor;
            do
            {
                // (, line 205
                // or, line 209
                do
                {
                    v_4 = m_limit - m_cursor;
                    do
                    {
                        // (, line 206
                        // and, line 207
                        v_5 = m_limit - m_cursor;
                        // (, line 206
                        // or, line 206
                        do
                        {
                            v_6 = m_limit - m_cursor;
                            do
                            {
                                // call standard_suffix, line 206
                                if (!r_standard_suffix())
                                {
                                    goto lab6;
                                }
                                goto lab5;
                            } while (false);
                            lab6:
                            m_cursor = m_limit - v_6;
                            // call verb_suffix, line 206
                            if (!r_verb_suffix())
                            {
                                goto lab4;
                            }
                        } while (false);
                        lab5:
                        m_cursor = m_limit - v_5;
                        // do, line 207
                        v_7 = m_limit - m_cursor;
                        do
                        {
                            // (, line 207
                            // [, line 207
                            m_ket = m_cursor;
                            // literal, line 207
                            if (!(Eq_S_B(1, "i")))
                            {
                                goto lab7;
                            }
                            // ], line 207
                            m_bra = m_cursor;
                            // test, line 207
                            v_8 = m_limit - m_cursor;
                            // literal, line 207
                            if (!(Eq_S_B(1, "c")))
                            {
                                goto lab7;
                            }
                            m_cursor = m_limit - v_8;
                            // call RV, line 207
                            if (!r_RV())
                            {
                                goto lab7;
                            }
                            // delete, line 207
                            SliceDel();
                        } while (false);
                        lab7:
                        m_cursor = m_limit - v_7;
                        goto lab3;
                    } while (false);
                    lab4:
                    m_cursor = m_limit - v_4;
                    // call residual_suffix, line 209
                    if (!r_residual_suffix())
                    {
                        goto lab2;
                    }
                } while (false);
                lab3: {/* LUCENENET: intentionally blank */}
            } while (false);
            lab2:
            m_cursor = m_limit - v_3;
            // do, line 211
            v_9 = m_limit - m_cursor;
            do
            {
                // call residual_form, line 211
                if (!r_residual_form())
                {
                    goto lab8;
                }
            } while (false);
            lab8:
            m_cursor = m_limit - v_9;
            m_cursor = m_limit_backward;                    // do, line 213
            v_10 = m_cursor;
            do
            {
                // call postlude, line 213
                if (!r_postlude())
                {
                    goto lab9;
                }
            } while (false);
            lab9:
            m_cursor = v_10;
            return true;
        }


        public override bool Equals(object o)
        {
            return o is PortugueseStemmer;
        }

        public override int GetHashCode()
        {
            return this.GetType().FullName.GetHashCode();
        }
    }
}
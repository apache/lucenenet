// Lucene version compatibility level 4.8.1
/*

Copyright (c) 2001, Dr Martin Porter
Copyright (c) 2002, Richard Boulton
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    * this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    * notice, this list of conditions and the following disclaimer in the
    * documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holders nor the names of its contributors
    * may be used to endorse or promote products derived from this software
    * without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */

namespace Lucene.Net.Tartarus.Snowball.Ext
{
    /// <summary>
    /// This class was automatically generated by a Snowball to Java compiler
    /// It implements the stemming algorithm defined by a snowball script.
    /// </summary>
    public class HungarianStemmer : SnowballProgram
    {
        // LUCENENET specific: Factored out methodObject by using Func<bool> instead of Reflection

        private readonly static Among[] a_0 = {
                    new Among ( "cs", -1, -1 ),
                    new Among ( "dzs", -1, -1 ),
                    new Among ( "gy", -1, -1 ),
                    new Among ( "ly", -1, -1 ),
                    new Among ( "ny", -1, -1 ),
                    new Among ( "sz", -1, -1 ),
                    new Among ( "ty", -1, -1 ),
                    new Among ( "zs", -1, -1 )
                };

        private readonly static Among[] a_1 = {
                    new Among ( "\u00E1", -1, 1 ),
                    new Among ( "\u00E9", -1, 2 )
                };

        private readonly static Among[] a_2 = {
                    new Among ( "bb", -1, -1 ),
                    new Among ( "cc", -1, -1 ),
                    new Among ( "dd", -1, -1 ),
                    new Among ( "ff", -1, -1 ),
                    new Among ( "gg", -1, -1 ),
                    new Among ( "jj", -1, -1 ),
                    new Among ( "kk", -1, -1 ),
                    new Among ( "ll", -1, -1 ),
                    new Among ( "mm", -1, -1 ),
                    new Among ( "nn", -1, -1 ),
                    new Among ( "pp", -1, -1 ),
                    new Among ( "rr", -1, -1 ),
                    new Among ( "ccs", -1, -1 ),
                    new Among ( "ss", -1, -1 ),
                    new Among ( "zzs", -1, -1 ),
                    new Among ( "tt", -1, -1 ),
                    new Among ( "vv", -1, -1 ),
                    new Among ( "ggy", -1, -1 ),
                    new Among ( "lly", -1, -1 ),
                    new Among ( "nny", -1, -1 ),
                    new Among ( "tty", -1, -1 ),
                    new Among ( "ssz", -1, -1 ),
                    new Among ( "zz", -1, -1 )
                };

        private readonly static Among[] a_3 = {
                    new Among ( "al", -1, 1 ),
                    new Among ( "el", -1, 2 )
                };

        private readonly static Among[] a_4 = {
                    new Among ( "ba", -1, -1 ),
                    new Among ( "ra", -1, -1 ),
                    new Among ( "be", -1, -1 ),
                    new Among ( "re", -1, -1 ),
                    new Among ( "ig", -1, -1 ),
                    new Among ( "nak", -1, -1 ),
                    new Among ( "nek", -1, -1 ),
                    new Among ( "val", -1, -1 ),
                    new Among ( "vel", -1, -1 ),
                    new Among ( "ul", -1, -1 ),
                    new Among ( "n\u00E1l", -1, -1 ),
                    new Among ( "n\u00E9l", -1, -1 ),
                    new Among ( "b\u00F3l", -1, -1 ),
                    new Among ( "r\u00F3l", -1, -1 ),
                    new Among ( "t\u00F3l", -1, -1 ),
                    new Among ( "b\u00F5l", -1, -1 ),
                    new Among ( "r\u00F5l", -1, -1 ),
                    new Among ( "t\u00F5l", -1, -1 ),
                    new Among ( "\u00FCl", -1, -1 ),
                    new Among ( "n", -1, -1 ),
                    new Among ( "an", 19, -1 ),
                    new Among ( "ban", 20, -1 ),
                    new Among ( "en", 19, -1 ),
                    new Among ( "ben", 22, -1 ),
                    new Among ( "k\u00E9ppen", 22, -1 ),
                    new Among ( "on", 19, -1 ),
                    new Among ( "\u00F6n", 19, -1 ),
                    new Among ( "k\u00E9pp", -1, -1 ),
                    new Among ( "kor", -1, -1 ),
                    new Among ( "t", -1, -1 ),
                    new Among ( "at", 29, -1 ),
                    new Among ( "et", 29, -1 ),
                    new Among ( "k\u00E9nt", 29, -1 ),
                    new Among ( "ank\u00E9nt", 32, -1 ),
                    new Among ( "enk\u00E9nt", 32, -1 ),
                    new Among ( "onk\u00E9nt", 32, -1 ),
                    new Among ( "ot", 29, -1 ),
                    new Among ( "\u00E9rt", 29, -1 ),
                    new Among ( "\u00F6t", 29, -1 ),
                    new Among ( "hez", -1, -1 ),
                    new Among ( "hoz", -1, -1 ),
                    new Among ( "h\u00F6z", -1, -1 ),
                    new Among ( "v\u00E1", -1, -1 ),
                    new Among ( "v\u00E9", -1, -1 )
                };

        private readonly static Among[] a_5 = {
                    new Among ( "\u00E1n", -1, 2 ),
                    new Among ( "\u00E9n", -1, 1 ),
                    new Among ( "\u00E1nk\u00E9nt", -1, 3 )
                };

        private readonly static Among[] a_6 = {
                    new Among ( "stul", -1, 2 ),
                    new Among ( "astul", 0, 1 ),
                    new Among ( "\u00E1stul", 0, 3 ),
                    new Among ( "st\u00FCl", -1, 2 ),
                    new Among ( "est\u00FCl", 3, 1 ),
                    new Among ( "\u00E9st\u00FCl", 3, 4 )
                };

        private readonly static Among[] a_7 = {
                    new Among ( "\u00E1", -1, 1 ),
                    new Among ( "\u00E9", -1, 2 )
                };

        private readonly static Among[] a_8 = {
                    new Among ( "k", -1, 7 ),
                    new Among ( "ak", 0, 4 ),
                    new Among ( "ek", 0, 6 ),
                    new Among ( "ok", 0, 5 ),
                    new Among ( "\u00E1k", 0, 1 ),
                    new Among ( "\u00E9k", 0, 2 ),
                    new Among ( "\u00F6k", 0, 3 )
                };

        private readonly static Among[] a_9 = {
                    new Among ( "\u00E9i", -1, 7 ),
                    new Among ( "\u00E1\u00E9i", 0, 6 ),
                    new Among ( "\u00E9\u00E9i", 0, 5 ),
                    new Among ( "\u00E9", -1, 9 ),
                    new Among ( "k\u00E9", 3, 4 ),
                    new Among ( "ak\u00E9", 4, 1 ),
                    new Among ( "ek\u00E9", 4, 1 ),
                    new Among ( "ok\u00E9", 4, 1 ),
                    new Among ( "\u00E1k\u00E9", 4, 3 ),
                    new Among ( "\u00E9k\u00E9", 4, 2 ),
                    new Among ( "\u00F6k\u00E9", 4, 1 ),
                    new Among ( "\u00E9\u00E9", 3, 8 )
                };

        private readonly static Among[] a_10 = {
                    new Among ( "a", -1, 18 ),
                    new Among ( "ja", 0, 17 ),
                    new Among ( "d", -1, 16 ),
                    new Among ( "ad", 2, 13 ),
                    new Among ( "ed", 2, 13 ),
                    new Among ( "od", 2, 13 ),
                    new Among ( "\u00E1d", 2, 14 ),
                    new Among ( "\u00E9d", 2, 15 ),
                    new Among ( "\u00F6d", 2, 13 ),
                    new Among ( "e", -1, 18 ),
                    new Among ( "je", 9, 17 ),
                    new Among ( "nk", -1, 4 ),
                    new Among ( "unk", 11, 1 ),
                    new Among ( "\u00E1nk", 11, 2 ),
                    new Among ( "\u00E9nk", 11, 3 ),
                    new Among ( "\u00FCnk", 11, 1 ),
                    new Among ( "uk", -1, 8 ),
                    new Among ( "juk", 16, 7 ),
                    new Among ( "\u00E1juk", 17, 5 ),
                    new Among ( "\u00FCk", -1, 8 ),
                    new Among ( "j\u00FCk", 19, 7 ),
                    new Among ( "\u00E9j\u00FCk", 20, 6 ),
                    new Among ( "m", -1, 12 ),
                    new Among ( "am", 22, 9 ),
                    new Among ( "em", 22, 9 ),
                    new Among ( "om", 22, 9 ),
                    new Among ( "\u00E1m", 22, 10 ),
                    new Among ( "\u00E9m", 22, 11 ),
                    new Among ( "o", -1, 18 ),
                    new Among ( "\u00E1", -1, 19 ),
                    new Among ( "\u00E9", -1, 20 )
                };

        private readonly static Among[] a_11 = {
                    new Among ( "id", -1, 10 ),
                    new Among ( "aid", 0, 9 ),
                    new Among ( "jaid", 1, 6 ),
                    new Among ( "eid", 0, 9 ),
                    new Among ( "jeid", 3, 6 ),
                    new Among ( "\u00E1id", 0, 7 ),
                    new Among ( "\u00E9id", 0, 8 ),
                    new Among ( "i", -1, 15 ),
                    new Among ( "ai", 7, 14 ),
                    new Among ( "jai", 8, 11 ),
                    new Among ( "ei", 7, 14 ),
                    new Among ( "jei", 10, 11 ),
                    new Among ( "\u00E1i", 7, 12 ),
                    new Among ( "\u00E9i", 7, 13 ),
                    new Among ( "itek", -1, 24 ),
                    new Among ( "eitek", 14, 21 ),
                    new Among ( "jeitek", 15, 20 ),
                    new Among ( "\u00E9itek", 14, 23 ),
                    new Among ( "ik", -1, 29 ),
                    new Among ( "aik", 18, 26 ),
                    new Among ( "jaik", 19, 25 ),
                    new Among ( "eik", 18, 26 ),
                    new Among ( "jeik", 21, 25 ),
                    new Among ( "\u00E1ik", 18, 27 ),
                    new Among ( "\u00E9ik", 18, 28 ),
                    new Among ( "ink", -1, 20 ),
                    new Among ( "aink", 25, 17 ),
                    new Among ( "jaink", 26, 16 ),
                    new Among ( "eink", 25, 17 ),
                    new Among ( "jeink", 28, 16 ),
                    new Among ( "\u00E1ink", 25, 18 ),
                    new Among ( "\u00E9ink", 25, 19 ),
                    new Among ( "aitok", -1, 21 ),
                    new Among ( "jaitok", 32, 20 ),
                    new Among ( "\u00E1itok", -1, 22 ),
                    new Among ( "im", -1, 5 ),
                    new Among ( "aim", 35, 4 ),
                    new Among ( "jaim", 36, 1 ),
                    new Among ( "eim", 35, 4 ),
                    new Among ( "jeim", 38, 1 ),
                    new Among ( "\u00E1im", 35, 2 ),
                    new Among ( "\u00E9im", 35, 3 )
                };

        private static readonly char[] g_v = { (char)17, (char)65, (char)16, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)17, (char)52, (char)14 };

        private int I_p1;

        private void copy_from(HungarianStemmer other)
        {
            I_p1 = other.I_p1;
            base.CopyFrom(other);
        }

        private bool r_mark_regions()
        {
            int v_1;
            int v_2;
            int v_3;
            // (, line 44
            I_p1 = m_limit;
            // or, line 51
            do
            {
                v_1 = m_cursor;
                do
                {
                    // (, line 48
                    if (!(InGrouping(g_v, 97, 252)))
                    {
                        goto lab1;
                    }
                    // goto, line 48
                    while (true)
                    {
                        v_2 = m_cursor;
                        do
                        {
                            if (!(OutGrouping(g_v, 97, 252)))
                            {
                                goto lab3;
                            }
                            m_cursor = v_2;
                            goto golab2;
                        } while (false);
                        lab3:
                        m_cursor = v_2;
                        if (m_cursor >= m_limit)
                        {
                            goto lab1;
                        }
                        m_cursor++;
                    }
                    golab2:
                    // or, line 49
                    do
                    {
                        v_3 = m_cursor;
                        do
                        {
                            // among, line 49
                            if (FindAmong(a_0, 8) == 0)
                            {
                                goto lab5;
                            }
                            goto lab4;
                        } while (false);
                        lab5:
                        m_cursor = v_3;
                        // next, line 49
                        if (m_cursor >= m_limit)
                        {
                            goto lab1;
                        }
                        m_cursor++;
                    } while (false);
                    lab4:
                    // setmark p1, line 50
                    I_p1 = m_cursor;
                    goto lab0;
                } while (false);
                lab1:
                m_cursor = v_1;
                // (, line 53
                if (!(OutGrouping(g_v, 97, 252)))
                {
                    return false;
                }
                // gopast, line 53
                while (true)
                {
                    do
                    {
                        if (!(InGrouping(g_v, 97, 252)))
                        {
                            goto lab7;
                        }
                        goto golab6;
                    } while (false);
                    lab7:
                    if (m_cursor >= m_limit)
                    {
                        return false;
                    }
                    m_cursor++;
                }
                golab6:
                // setmark p1, line 53
                I_p1 = m_cursor;
            } while (false);
            lab0:
            return true;
        }

        private bool r_R1()
        {
            if (!(I_p1 <= m_cursor))
            {
                return false;
            }
            return true;
        }

        private bool r_v_ending()
        {
            int among_var;
            // (, line 60
            // [, line 61
            m_ket = m_cursor;
            // substring, line 61
            among_var = FindAmongB(a_1, 2);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 61
            m_bra = m_cursor;
            // call R1, line 61
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 62
                    // <-, line 62
                    SliceFrom("a");
                    break;
                case 2:
                    // (, line 63
                    // <-, line 63
                    SliceFrom("e");
                    break;
            }
            return true;
        }

        private bool r_double()
        {
            int v_1;
            // (, line 67
            // test, line 68
            v_1 = m_limit - m_cursor;
            // among, line 68
            if (FindAmongB(a_2, 23) == 0)
            {
                return false;
            }
            m_cursor = m_limit - v_1;
            return true;
        }

        private bool r_undouble()
        {
            // (, line 72
            // next, line 73
            if (m_cursor <= m_limit_backward)
            {
                return false;
            }
            m_cursor--;
            // [, line 73
            m_ket = m_cursor;
            // hop, line 73
            {
                int c = m_cursor - 1;
                if (m_limit_backward > c || c > m_limit)
                {
                    return false;
                }
                m_cursor = c;
            }
            // ], line 73
            m_bra = m_cursor;
            // delete, line 73
            SliceDel();
            return true;
        }

        private bool r_instrum()
        {
            int among_var;
            // (, line 76
            // [, line 77
            m_ket = m_cursor;
            // substring, line 77
            among_var = FindAmongB(a_3, 2);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 77
            m_bra = m_cursor;
            // call R1, line 77
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 78
                    // call double, line 78
                    if (!r_double())
                    {
                        return false;
                    }
                    break;
                case 2:
                    // (, line 79
                    // call double, line 79
                    if (!r_double())
                    {
                        return false;
                    }
                    break;
            }
            // delete, line 81
            SliceDel();
            // call undouble, line 82
            if (!r_undouble())
            {
                return false;
            }
            return true;
        }

        private bool r_case()
        {
            // (, line 86
            // [, line 87
            m_ket = m_cursor;
            // substring, line 87
            if (FindAmongB(a_4, 44) == 0)
            {
                return false;
            }
            // ], line 87
            m_bra = m_cursor;
            // call R1, line 87
            if (!r_R1())
            {
                return false;
            }
            // delete, line 111
            SliceDel();
            // call v_ending, line 112
            if (!r_v_ending())
            {
                return false;
            }
            return true;
        }

        private bool r_case_special()
        {
            int among_var;
            // (, line 115
            // [, line 116
            m_ket = m_cursor;
            // substring, line 116
            among_var = FindAmongB(a_5, 3);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 116
            m_bra = m_cursor;
            // call R1, line 116
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 117
                    // <-, line 117
                    SliceFrom("e");
                    break;
                case 2:
                    // (, line 118
                    // <-, line 118
                    SliceFrom("a");
                    break;
                case 3:
                    // (, line 119
                    // <-, line 119
                    SliceFrom("a");
                    break;
            }
            return true;
        }

        private bool r_case_other()
        {
            int among_var;
            // (, line 123
            // [, line 124
            m_ket = m_cursor;
            // substring, line 124
            among_var = FindAmongB(a_6, 6);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 124
            m_bra = m_cursor;
            // call R1, line 124
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 125
                    // delete, line 125
                    SliceDel();
                    break;
                case 2:
                    // (, line 126
                    // delete, line 126
                    SliceDel();
                    break;
                case 3:
                    // (, line 127
                    // <-, line 127
                    SliceFrom("a");
                    break;
                case 4:
                    // (, line 128
                    // <-, line 128
                    SliceFrom("e");
                    break;
            }
            return true;
        }

        private bool r_factive()
        {
            int among_var;
            // (, line 132
            // [, line 133
            m_ket = m_cursor;
            // substring, line 133
            among_var = FindAmongB(a_7, 2);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 133
            m_bra = m_cursor;
            // call R1, line 133
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 134
                    // call double, line 134
                    if (!r_double())
                    {
                        return false;
                    }
                    break;
                case 2:
                    // (, line 135
                    // call double, line 135
                    if (!r_double())
                    {
                        return false;
                    }
                    break;
            }
            // delete, line 137
            SliceDel();
            // call undouble, line 138
            if (!r_undouble())
            {
                return false;
            }
            return true;
        }

        private bool r_plural()
        {
            int among_var;
            // (, line 141
            // [, line 142
            m_ket = m_cursor;
            // substring, line 142
            among_var = FindAmongB(a_8, 7);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 142
            m_bra = m_cursor;
            // call R1, line 142
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 143
                    // <-, line 143
                    SliceFrom("a");
                    break;
                case 2:
                    // (, line 144
                    // <-, line 144
                    SliceFrom("e");
                    break;
                case 3:
                    // (, line 145
                    // delete, line 145
                    SliceDel();
                    break;
                case 4:
                    // (, line 146
                    // delete, line 146
                    SliceDel();
                    break;
                case 5:
                    // (, line 147
                    // delete, line 147
                    SliceDel();
                    break;
                case 6:
                    // (, line 148
                    // delete, line 148
                    SliceDel();
                    break;
                case 7:
                    // (, line 149
                    // delete, line 149
                    SliceDel();
                    break;
            }
            return true;
        }

        private bool r_owned()
        {
            int among_var;
            // (, line 153
            // [, line 154
            m_ket = m_cursor;
            // substring, line 154
            among_var = FindAmongB(a_9, 12);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 154
            m_bra = m_cursor;
            // call R1, line 154
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 155
                    // delete, line 155
                    SliceDel();
                    break;
                case 2:
                    // (, line 156
                    // <-, line 156
                    SliceFrom("e");
                    break;
                case 3:
                    // (, line 157
                    // <-, line 157
                    SliceFrom("a");
                    break;
                case 4:
                    // (, line 158
                    // delete, line 158
                    SliceDel();
                    break;
                case 5:
                    // (, line 159
                    // <-, line 159
                    SliceFrom("e");
                    break;
                case 6:
                    // (, line 160
                    // <-, line 160
                    SliceFrom("a");
                    break;
                case 7:
                    // (, line 161
                    // delete, line 161
                    SliceDel();
                    break;
                case 8:
                    // (, line 162
                    // <-, line 162
                    SliceFrom("e");
                    break;
                case 9:
                    // (, line 163
                    // delete, line 163
                    SliceDel();
                    break;
            }
            return true;
        }

        private bool r_sing_owner()
        {
            int among_var;
            // (, line 167
            // [, line 168
            m_ket = m_cursor;
            // substring, line 168
            among_var = FindAmongB(a_10, 31);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 168
            m_bra = m_cursor;
            // call R1, line 168
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 169
                    // delete, line 169
                    SliceDel();
                    break;
                case 2:
                    // (, line 170
                    // <-, line 170
                    SliceFrom("a");
                    break;
                case 3:
                    // (, line 171
                    // <-, line 171
                    SliceFrom("e");
                    break;
                case 4:
                    // (, line 172
                    // delete, line 172
                    SliceDel();
                    break;
                case 5:
                    // (, line 173
                    // <-, line 173
                    SliceFrom("a");
                    break;
                case 6:
                    // (, line 174
                    // <-, line 174
                    SliceFrom("e");
                    break;
                case 7:
                    // (, line 175
                    // delete, line 175
                    SliceDel();
                    break;
                case 8:
                    // (, line 176
                    // delete, line 176
                    SliceDel();
                    break;
                case 9:
                    // (, line 177
                    // delete, line 177
                    SliceDel();
                    break;
                case 10:
                    // (, line 178
                    // <-, line 178
                    SliceFrom("a");
                    break;
                case 11:
                    // (, line 179
                    // <-, line 179
                    SliceFrom("e");
                    break;
                case 12:
                    // (, line 180
                    // delete, line 180
                    SliceDel();
                    break;
                case 13:
                    // (, line 181
                    // delete, line 181
                    SliceDel();
                    break;
                case 14:
                    // (, line 182
                    // <-, line 182
                    SliceFrom("a");
                    break;
                case 15:
                    // (, line 183
                    // <-, line 183
                    SliceFrom("e");
                    break;
                case 16:
                    // (, line 184
                    // delete, line 184
                    SliceDel();
                    break;
                case 17:
                    // (, line 185
                    // delete, line 185
                    SliceDel();
                    break;
                case 18:
                    // (, line 186
                    // delete, line 186
                    SliceDel();
                    break;
                case 19:
                    // (, line 187
                    // <-, line 187
                    SliceFrom("a");
                    break;
                case 20:
                    // (, line 188
                    // <-, line 188
                    SliceFrom("e");
                    break;
            }
            return true;
        }

        private bool r_plur_owner()
        {
            int among_var;
            // (, line 192
            // [, line 193
            m_ket = m_cursor;
            // substring, line 193
            among_var = FindAmongB(a_11, 42);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 193
            m_bra = m_cursor;
            // call R1, line 193
            if (!r_R1())
            {
                return false;
            }
            switch (among_var)
            {
                case 0:
                    return false;
                case 1:
                    // (, line 194
                    // delete, line 194
                    SliceDel();
                    break;
                case 2:
                    // (, line 195
                    // <-, line 195
                    SliceFrom("a");
                    break;
                case 3:
                    // (, line 196
                    // <-, line 196
                    SliceFrom("e");
                    break;
                case 4:
                    // (, line 197
                    // delete, line 197
                    SliceDel();
                    break;
                case 5:
                    // (, line 198
                    // delete, line 198
                    SliceDel();
                    break;
                case 6:
                    // (, line 199
                    // delete, line 199
                    SliceDel();
                    break;
                case 7:
                    // (, line 200
                    // <-, line 200
                    SliceFrom("a");
                    break;
                case 8:
                    // (, line 201
                    // <-, line 201
                    SliceFrom("e");
                    break;
                case 9:
                    // (, line 202
                    // delete, line 202
                    SliceDel();
                    break;
                case 10:
                    // (, line 203
                    // delete, line 203
                    SliceDel();
                    break;
                case 11:
                    // (, line 204
                    // delete, line 204
                    SliceDel();
                    break;
                case 12:
                    // (, line 205
                    // <-, line 205
                    SliceFrom("a");
                    break;
                case 13:
                    // (, line 206
                    // <-, line 206
                    SliceFrom("e");
                    break;
                case 14:
                    // (, line 207
                    // delete, line 207
                    SliceDel();
                    break;
                case 15:
                    // (, line 208
                    // delete, line 208
                    SliceDel();
                    break;
                case 16:
                    // (, line 209
                    // delete, line 209
                    SliceDel();
                    break;
                case 17:
                    // (, line 210
                    // delete, line 210
                    SliceDel();
                    break;
                case 18:
                    // (, line 211
                    // <-, line 211
                    SliceFrom("a");
                    break;
                case 19:
                    // (, line 212
                    // <-, line 212
                    SliceFrom("e");
                    break;
                case 20:
                    // (, line 214
                    // delete, line 214
                    SliceDel();
                    break;
                case 21:
                    // (, line 215
                    // delete, line 215
                    SliceDel();
                    break;
                case 22:
                    // (, line 216
                    // <-, line 216
                    SliceFrom("a");
                    break;
                case 23:
                    // (, line 217
                    // <-, line 217
                    SliceFrom("e");
                    break;
                case 24:
                    // (, line 218
                    // delete, line 218
                    SliceDel();
                    break;
                case 25:
                    // (, line 219
                    // delete, line 219
                    SliceDel();
                    break;
                case 26:
                    // (, line 220
                    // delete, line 220
                    SliceDel();
                    break;
                case 27:
                    // (, line 221
                    // <-, line 221
                    SliceFrom("a");
                    break;
                case 28:
                    // (, line 222
                    // <-, line 222
                    SliceFrom("e");
                    break;
                case 29:
                    // (, line 223
                    // delete, line 223
                    SliceDel();
                    break;
            }
            return true;
        }


        public override bool Stem()
        {
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            int v_6;
            int v_7;
            int v_8;
            int v_9;
            int v_10;
            // (, line 228
            // do, line 229
            v_1 = m_cursor;
            do
            {
                // call mark_regions, line 229
                if (!r_mark_regions())
                {
                    goto lab0;
                }
            } while (false);
            lab0:
            m_cursor = v_1;
            // backwards, line 230
            m_limit_backward = m_cursor; m_cursor = m_limit;
            // (, line 230
            // do, line 231
            v_2 = m_limit - m_cursor;
            do
            {
                // call instrum, line 231
                if (!r_instrum())
                {
                    goto lab1;
                }
            } while (false);
            lab1:
            m_cursor = m_limit - v_2;
            // do, line 232
            v_3 = m_limit - m_cursor;
            do
            {
                // call case, line 232
                if (!r_case())
                {
                    goto lab2;
                }
            } while (false);
            lab2:
            m_cursor = m_limit - v_3;
            // do, line 233
            v_4 = m_limit - m_cursor;
            do
            {
                // call case_special, line 233
                if (!r_case_special())
                {
                    goto lab3;
                }
            } while (false);
            lab3:
            m_cursor = m_limit - v_4;
            // do, line 234
            v_5 = m_limit - m_cursor;
            do
            {
                // call case_other, line 234
                if (!r_case_other())
                {
                    goto lab4;
                }
            } while (false);
            lab4:
            m_cursor = m_limit - v_5;
            // do, line 235
            v_6 = m_limit - m_cursor;
            do
            {
                // call factive, line 235
                if (!r_factive())
                {
                    goto lab5;
                }
            } while (false);
            lab5:
            m_cursor = m_limit - v_6;
            // do, line 236
            v_7 = m_limit - m_cursor;
            do
            {
                // call owned, line 236
                if (!r_owned())
                {
                    goto lab6;
                }
            } while (false);
            lab6:
            m_cursor = m_limit - v_7;
            // do, line 237
            v_8 = m_limit - m_cursor;
            do
            {
                // call sing_owner, line 237
                if (!r_sing_owner())
                {
                    goto lab7;
                }
            } while (false);
            lab7:
            m_cursor = m_limit - v_8;
            // do, line 238
            v_9 = m_limit - m_cursor;
            do
            {
                // call plur_owner, line 238
                if (!r_plur_owner())
                {
                    goto lab8;
                }
            } while (false);
            lab8:
            m_cursor = m_limit - v_9;
            // do, line 239
            v_10 = m_limit - m_cursor;
            do
            {
                // call plural, line 239
                if (!r_plural())
                {
                    goto lab9;
                }
            } while (false);
            lab9:
            m_cursor = m_limit - v_10;
            m_cursor = m_limit_backward; return true;
        }

        public override bool Equals(object o)
        {
            return o is HungarianStemmer;
        }

        public override int GetHashCode()
        {
            return this.GetType().FullName.GetHashCode();
        }
    }
}
<html xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Lucene.Net.Search Namespace</title><meta name="Language" content="en-us" /><meta name="System.Keywords" content="Lucene.Net.Search namespace" /><meta name="Microsoft.Help.F1" content="Lucene.Net.Search" /><meta name="Microsoft.Help.Id" content="N:Lucene.Net.Search" /><meta name="Description" content="[Missing &lt;summary&gt; documentation for &quot;N:Lucene.Net.Search&quot;]" /><meta name="Microsoft.Help.ContentType" content="Reference" /><link rel="stylesheet" type="text/css" href="../styles/Presentation.css" /><link rel="stylesheet" type="text/css" href="ms-help://Hx/HxRuntime/HxLink.css" /><script type="text/javascript" src="../scripts/EventUtilities.js"> </script><script type="text/javascript" src="../scripts/SplitScreen.js"> </script><script type="text/javascript" src="../scripts/Dropdown.js"> </script><script type="text/javascript" src="../scripts/script_manifold.js"> </script><script type="text/javascript" src="../scripts/script_feedBack.js"> </script><script type="text/javascript" src="../scripts/CheckboxMenu.js"> </script><script type="text/javascript" src="../scripts/CommonUtilities.js"> </script><meta name="container" content="Lucene.Net.Search" /><meta name="file" content="5715bafd-c3a8-9ed0-225c-3c4cececbdc0" /><meta name="guid" content="5715bafd-c3a8-9ed0-225c-3c4cececbdc0" /><xml><MSHelp:Attr Name="AssetID" Value="N:Lucene.Net.Search" /><MSHelp:TOCTitle Title="Lucene.Net.Search Namespace" /><MSHelp:RLTitle Title="Lucene.Net.Search Namespace ()" /><MSHelp:Keyword Index="A" Term="N:Lucene.Net.Search" /><MSHelp:Keyword Index="A" Term="frlrfLuceneNetSearch" /><MSHelp:Keyword Index="K" Term="Lucene.Net.Search namespace" /><MSHelp:Keyword Index="F" Term="Lucene.Net.Search" /><MSHelp:Attr Name="HelpPriority" Value="1" /><MSHelp:Attr Name="DevLang" Value="CSharp" /><MSHelp:Attr Name="DevLang" Value="VB" /><MSHelp:Attr Name="Locale" Value="en-us" /><MSHelp:Attr Name="TopicType" Value="kbSyntax" /><MSHelp:Attr Name="TopicType" Value="apiref" /><MSHelp:Attr Name="Abstract" Value="[Missing &lt;summary&gt; documentation for &quot;N:Lucene.Net.Search&quot;]" /></xml><link type="text/css" rel="stylesheet" href="../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"> </script></head><body><input type="hidden" id="userDataCache" class="userDataStyle" /><input type="hidden" id="hiddenScrollOffset" /><img id="collapseImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" alt="Collapse image" title="Collapse image" /><img id="expandImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" alt="Expand Image" title="Expand Image" /><img id="collapseAllImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" /><img id="expandAllImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" /><img id="dropDownImage" style="display:none; height:0; width:0;" src="../icons/dropdown.gif" /><img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="../icons/dropdownHover.gif" /><img id="copyImage" style="display:none; height:0; width:0;" src="../icons/copycode.gif" alt="Copy image" title="Copy image" /><img id="copyHoverImage" style="display:none; height:0; width:0;" src="../icons/copycodeHighlight.gif" alt="CopyHover image" title="CopyHover image" /><div id="header"><table id="topTable" cellspacing="0" cellpadding="0"><tr><td><span onclick="ExpandCollapseAll(toggleAllImage)" style="cursor:default;" onkeypress="ExpandCollapseAll_CheckKey(toggleAllImage, event)" tabindex="0"><img ID="toggleAllImage" class="toggleAll" src="../icons/collapse_all.gif" /> <label id="collapseAllLabel" for="toggleAllImage" style="display: none;">Collapse All</label><label id="expandAllLabel" for="toggleAllImage" style="display: none;">Expand All</label> </span><span>    </span><span id="devlangsDropdown" class="filter" tabindex="0"><img id="devlangsDropdownImage" src="../icons/dropdown.gif" /> <label id="devlangsMenuAllLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: All </nobr></label><label id="devlangsMenuMultipleLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Multiple </nobr></label><label id="devlangsMenuCSharpLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: C# </nobr></label><label id="devlangsMenuVisualBasicLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual Basic </nobr></label><label id="devlangsMenuManagedCPlusPlusLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual C++ </nobr></label></span></td></tr></table><div id="devlangsMenu"><input id="CSharpCheckbox" type="checkbox" data="CSharp,cs,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="CSharpCheckbox">C#</label><br /><input id="VisualBasicCheckbox" type="checkbox" data="VisualBasic,vb,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="VisualBasicCheckbox">Visual Basic</label><br /><input id="ManagedCPlusPlusCheckbox" type="checkbox" data="ManagedCPlusPlus,cpp,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="ManagedCPlusPlusCheckbox">Visual C++</label><br /></div><table id="bottomTable" cellpadding="0" cellspacing="0"><tr id="headerTableRow1"><td align="left"><span id="runningHeaderText">Lucene.Net Class Libraries</span></td></tr><tr id="headerTableRow2"><td align="left"><span id="nsrTitle">Lucene.Net.Search Namespace</span></td></tr><tr id="headerTableRow3"><td align="left"><span id="headfeedbackarea" class="feedbackhead"><a href="javascript:SubmitFeedback('','Lucene.Net Class Libraries','','','','%0\dYour%20feedback%20is%20used%20to%20improve%20the%20documentation%20and%20the%20product.%20Your%20e-mail%20address%20will%20not%20be%20used%20for%20any%20other%20purpose%20and%20is%20disposed%20of%20after%20the%20issue%20you%20report%20is%20resolved.%20%20While%20working%20to%20resolve%20the%20issue%20that%20you%20report,%20you%20may%20be%20contacted%20via%20e-mail%20to%20get%20further%20details%20or%20clarification%20on%20the%20feedback%20you%20sent.%20After%20the%20issue%20you%20report%20has%20been%20addressed,%20you%20may%20receive%20an%20e-mail%20to%20let%20you%20know%20that%20your%20feedback%20has%20been%20addressed.%0\A%0\d','Customer%20Feedback');">Send Feedback</a></span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()" /><span style="color: DarkGray"></span><div class="summary"><p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[Missing &lt;summary&gt; documentation for "N:Lucene.Net.Search"]</p></div><h1 class="heading"><span onclick="ExpandCollapse(classToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(classToggle, event)" tabindex="0"><img id="classToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Classes</span></h1><div id="classSection" class="section" name="collapseableSection" style=""><table id="typeList" class="members" frame="lhs" cellpadding="2"><col width="10%" /><tr><th class="iconColumn">
           
       </th><th class="nameColumn">Class</th><th class="descriptionColumn">Description</th></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="9b1cfa90-4164-5ce2-7101-4ede071aaf50.htm">BooleanClause</a></td><td><div class="summary">A clause in a BooleanQuery. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="1025c53e-72de-0154-5183-81f2f6f07421.htm">BooleanClause<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>Occur</a></td><td><div class="summary">Specifies how clauses are to occur in matching documents. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="fb4b887b-868e-d9f5-5122-4d8ec41bfae6.htm">BooleanFilter</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="c938df7d-6832-9d73-0ebc-9776383e1d29.htm">BooleanFilterClause</a></td><td><div class="summary">
            A spefic clause that makes up a part of the BooleanFilter
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="e26a1f99-0b64-ba13-9ec4-cde23885af56.htm">BooleanQuery</a></td><td><div class="summary">A Query that matches documents matching boolean combinations of other
            queries, e.g. {@link TermQuery}s, {@link PhraseQuery}s or other
            BooleanQuerys.
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="e9a44ae2-42bc-95d7-905a-512dd3bbc73d.htm">BooleanQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>BooleanWeight</a></td><td><div class="summary"> Expert: the Weight for BooleanQuery, used to
            normalize, score and explain these queries.
            
            <p />NOTE: this API and implementation is subject to
            change suddenly in the next release.<p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="f8bd2ab8-951f-77cd-5ebf-c50496965c9e.htm">BooleanQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>TooManyClauses</a></td><td><div class="summary">Thrown when an attempt is made to add more than {@link
            #GetMaxClauseCount()} clauses. This typically happens if
            a PrefixQuery, FuzzyQuery, WildcardQuery, or TermRangeQuery 
            is expanded to many terms during search. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="61c28553-01fc-2083-3987-44679f29ec0c.htm">BooleanScorer</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="752728c4-f937-0be2-97f0-4ec3098d074f.htm">BoostingQuery</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="17fd40de-3e03-b02c-220e-fc4b74427f0e.htm">CacheEntry</a></td><td><div class="summary"> EXPERT: A unique Identifier/Description for each item in the FieldCache. 
            Can be useful for logging/debugging.
            <p /><b>EXPERIMENTAL API:</b> This API is considered extremely advanced 
            and experimental.  It may be removed or altered w/o warning in future 
            releases 
            of Lucene.
            <p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="19a61b37-539c-2f1f-9aad-e82bbd59668f.htm">CachingSpanFilter</a></td><td><div class="summary"> Wraps another SpanFilter's result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add caching.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="00439464-00b5-569d-0cc3-c841fa6ab613.htm">CachingWrapperFilter</a></td><td><div class="summary"> Wraps another filter's result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add caching.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a0cb6253-1d3c-7073-2514-7b831dcd35c7.htm">CachingWrapperFilter<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>DeletesMode</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a0b3a4fa-3429-0e0a-fa6e-162ad83e3ea5.htm">Collector</a></td><td><div class="summary"><p />Expert: Collectors are primarily meant to be used to
            gather raw results from a search, and implement sorting
            or custom result filtering, collation, etc. <p /><p />As of 2.9, this class replaces the deprecated
            HitCollector, and offers an API for efficient collection
            of hits across sequential {@link IndexReader}s. {@link
            IndexSearcher} advances the collector through each of the
            sub readers, in an arbitrary order. This results in a
            higher performance means of collection.<p /><p />Lucene's core collectors are derived from Collector.
            Likely your application can use one of these classes, or
            subclass {@link TopDocsCollector}, instead of
            implementing Collector directly:
            
            <ul><li>{@link TopDocsCollector} is an abstract base class
            that assumes you will retrieve the top N docs,
            according to some criteria, after collection is
            done.  </li><li>{@link TopScoreDocCollector} is a concrete subclass
            {@link TopDocsCollector} and sorts according to score +
            docID.  This is used internally by the {@link
            IndexSearcher} search methods that do not take an
            explicit {@link Sort}. It is likely the most frequently
            used collector.</li><li>{@link TopFieldCollector} subclasses {@link
            TopDocsCollector} and sorts according to a specified
            {@link Sort} object (sort by field).  This is used
            internally by the {@link IndexSearcher} search methods
            that take an explicit {@link Sort}.</li><li>{@link TimeLimitingCollector}, which wraps any other
            Collector and aborts the search if it's taken too much
            time, will subclass Collector in 3.0 (presently it
            subclasses the deprecated HitCollector).</li><li>{@link PositiveScoresOnlyCollector} wraps any other
            Collector and prevents collection of hits whose score
            is &lt;= 0.0</li></ul><p />Collector decouples the score from the collected doc:
            the score computation is skipped entirely if it's not
            needed.  Collectors that do need the score should
            implement the {@link #setScorer} method, to hold onto the
            passed {@link Scorer} instance, and call {@link
            Scorer#Score()} within the collect method to compute the
            current hit's score.  If your collector may request the
            score for a single hit multiple times, you should use
            {@link ScoreCachingWrappingScorer}. <p /><p /><b>NOTE:</b> The doc that is passed to the collect
            method is relative to the current reader. If your
            collector needs to resolve this to the docID space of the
            Multi*Reader, you must re-base it by recording the
            docBase from the most recent setNextReader call.  Here's
            a simple example showing how to collect docIDs into a
            BitSet:<p /><pre>
            Searcher searcher = new IndexSearcher(indexReader);
            final BitSet bits = new BitSet(indexReader.maxDoc());
            searcher.search(query, new Collector() {
            private int docBase;
            
            <em>// ignore scorer</em>
            public void setScorer(Scorer scorer) {
            }
            
            <em>// accept docs out of order (for a BitSet it doesn't matter)</em>
            public boolean acceptsDocsOutOfOrder() {
            return true;
            }
            
            public void collect(int doc) {
            bits.set(doc + docBase);
            }
            
            public void setNextReader(IndexReader reader, int docBase) {
            this.docBase = docBase;
            }
            });
            </pre><p />Not all collectors will need to rebase the docID.  For
            example, a collector that simply counts the total number
            of hits would skip it.<p /><p /><b>NOTE:</b> Prior to 2.9, Lucene silently filtered
            out hits with score &lt;= 0.  As of 2.9, the core Collectors
            no longer do that.  It's very unusual to have such hits
            (a negative query boost, or function query returning
            negative custom scores, could cause it to happen).  If
            you need that behavior, use {@link
            PositiveScoresOnlyCollector}.<p /><p /><b>NOTE:</b> This API is experimental and might change
            in incompatible ways in the next release.<p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="fe3156cf-c721-84aa-f915-8d02aeb00f9b.htm">ComplexExplanation</a></td><td><div class="summary">Expert: Describes the score computation for document and query, and
            can distinguish a match independent of a positive value. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="42f13b9b-3d1a-a2dc-3394-d34c54e1e982.htm">ConstantScoreQuery</a></td><td><div class="summary"> A query that wraps a filter and simply returns a constant score equal to the
            query boost for every document in the filter.
            
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="c34f153f-1302-cbd8-e6b2-a16fe0b775a1.htm">ConstantScoreQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ConstantScorer</a></td><td /></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="3795658a-0003-ae0f-cdd0-47ba5ea97a97.htm">ConstantScoreQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ConstantWeight</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="ea69ab4f-d256-f8cd-8c32-0570f762f7b0.htm">ConstantScoreRangeQuery</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> A range query that returns a constant score equal to its boost for
            all documents in the exclusive range of terms.
            
            <p />It does not have an upper bound on the number of clauses covered in the range.
            
            <p />This query matches the documents looking for terms that fall into the
            supplied range according to {@link String#compareTo(String)}. It is not intended
            for numerical ranges, use {@link NumericRangeQuery} instead.
            
            <p />This query is hardwired to {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}.
            If you want to change this, use {@link TermRangeQuery} instead.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="56c42b3d-0f66-dfaa-1ce7-d66c9ebb3115.htm">CreationPlaceholder</a></td><td><div class="summary"> Expert: Maintains caches of term values.
            
            <p />Created: May 19, 2004 11:13:14 AM
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="685571bd-e7ad-c241-6ec0-418010782d42.htm">DefaultSimilarity</a></td><td><div class="summary">Expert: Default scoring implementation. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a00c6261-ecf3-1a31-5a2c-51cfc01b9b5f.htm">DisjunctionMaxQuery</a></td><td><div class="summary"> A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
            score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
            This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
            combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
            not the sum of the field scores (as BooleanQuery would give).
            If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
            another gets a higher score than "albino" matching both fields.
            To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
            each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
            The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
            include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
            in the multiple fields.
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="9bc2d5c7-f877-6b2c-2a12-99213c42e684.htm">DisjunctionMaxQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>DisjunctionMaxWeight</a></td><td><div class="summary"> Expert: the Weight for DisjunctionMaxQuery, used to
            normalize, score and explain these queries.
            
            <p />NOTE: this API and implementation is subject to
            change suddenly in the next release.<p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="d738f5f2-a750-0294-d2f8-af96533b29bb.htm">DocIdSet</a></td><td><div class="summary"> A DocIdSet contains a set of doc ids. Implementing classes must
            only implement {@link #iterator} to provide access to the set. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="08a7b047-eff6-b359-01bd-741dfe2eabe2.htm">DocIdSet<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>AnonymousClassDocIdSet</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b8c3cfbd-a696-7f5f-6e6d-f4a3fe0789a5.htm">DocIdSet<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>AnonymousClassDocIdSet<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>AnonymousClassDocIdSetIterator</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="9e83b508-04fc-e729-ad73-410f46dc6590.htm">DocIdSetIterator</a></td><td><div class="summary"> This abstract class defines methods to iterate over a set of non-decreasing
            doc ids. Note that this class assumes it iterates on doc Ids, and therefore
            {@link #NO_MORE_DOCS} is set to {@value #NO_MORE_DOCS} in order to be used as
            a sentinel object. Implementations of this class are expected to consider
            {@link Integer#MAX_VALUE} as an invalid value.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="c3b77dfd-db93-73b1-a845-39b30e9ee66a.htm">DuplicateFilter</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b847c6cf-0e06-5e20-5623-06f7868d93e4.htm">Explanation</a></td><td><div class="summary">Expert: Describes the score computation for document and query. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="aedede15-8c78-3f1d-15e2-b5289feee2af.htm">Explanation<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>IDFExplanation</a></td><td><div class="summary"> Small Util class used to pass both an idf factor as well as an
            explanation for that factor.
            
            This class will likely be held on a {@link Weight}, so be aware 
            before storing any large or un-serializable fields.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="2e1b0d6b-c6bd-b8b2-c77c-f1689fca5ec6.htm">Extensions</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5de7f135-9285-13d3-6083-3534c0313c17.htm">FieldCacheRangeFilter</a></td><td><div class="summary"> A range filter built on top of a cached single term field (in {@link FieldCache}).
            
            <p />FieldCacheRangeFilter builds a single cache for the field the first time it is used.
            Each subsequent FieldCacheRangeFilter on the same field then reuses this cache,
            even if the range itself changes. 
            
            <p />This means that FieldCacheRangeFilter is much faster (sometimes more than 100x as fast) 
            as building a {@link TermRangeFilter} (or {@link ConstantScoreRangeQuery} on a {@link TermRangeFilter})
            for each query, if using a {@link #newStringRange}. However, if the range never changes it
            is slower (around 2x as slow) than building a CachingWrapperFilter on top of a single TermRangeFilter.
            
            For numeric data types, this filter may be significantly faster than {@link NumericRangeFilter}.
            Furthermore, it does not need the numeric values encoded by {@link NumericField}. But
            it has the problem that it only works with exact one value/document (see below).
            
            <p />As with all {@link FieldCache} based functionality, FieldCacheRangeFilter is only valid for 
            fields which exact one term for each document (except for {@link #newStringRange}
            where 0 terms are also allowed). Due to a restriction of {@link FieldCache}, for numeric ranges
            all terms that do not have a numeric value, 0 is assumed.
            
            <p />Thus it works on dates, prices and other single value fields but will not work on
            regular text fields. It is preferable to use a <span id="cbc_13" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">NOT_ANALYZED</pre></div></span> field to ensure that
            there is only a single term. 
            
            <p />This class does not have an constructor, use one of the static factory methods available,
            that create a correct instance for different data types supported by {@link FieldCache}.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="2e202537-4e82-acf8-03d2-1b8b6ee4385f.htm">FieldCacheTermsFilter</a></td><td><div class="summary"> A {@link Filter} that only accepts documents whose single
            term value in the specified field is contained in the
            provided set of allowed terms.
            
            <p />
            
            This is the same functionality as TermsFilter (from
            contrib/queries), except this filter requires that the
            field contains only a single term for all documents.
            Because of drastically different implementations, they
            also have different performance characteristics, as
            described below.
            
            <p />
            
            The first invocation of this filter on a given field will
            be slower, since a {@link FieldCache.StringIndex} must be
            created.  Subsequent invocations using the same field
            will re-use this cache.  However, as with all
            functionality based on {@link FieldCache}, persistent RAM
            is consumed to hold the cache, and is not freed until the
            {@link IndexReader} is closed.  In contrast, TermsFilter
            has no persistent RAM consumption.
            
            
            <p />
            
            With each search, this filter translates the specified
            set of Terms into a private {@link OpenBitSet} keyed by
            term number per unique {@link IndexReader} (normally one
            reader per segment).  Then, during matching, the term
            number for each docID is retrieved from the cache and
            then checked for inclusion using the {@link OpenBitSet}.
            Since all testing is done using RAM resident data
            structures, performance should be very fast, most likely
            fast enough to not require further caching of the
            DocIdSet for each possible combination of terms.
            However, because docIDs are simply scanned linearly, an
            index with a great many small documents may find this
            linear scan too costly.
            
            <p />
            
            In contrast, TermsFilter builds up an {@link OpenBitSet},
            keyed by docID, every time it's created, by enumerating
            through all matching docs using {@link TermDocs} to seek
            and scan through each term's docID list.  While there is
            no linear scan of all docIDs, besides the allocation of
            the underlying array in the {@link OpenBitSet}, this
            approach requires a number of "disk seeks" in proportion
            to the number of terms, which can be exceptionally costly
            when there are cache misses in the OS's IO cache.
            
            <p />
            
            Generally, this filter will be slower on the first
            invocation for a given field, but subsequent invocations,
            even if you change the allowed set of Terms, should be
            faster than TermsFilter, especially as the number of
            Terms being matched increases.  If you are matching only
            a very small number of terms, and those terms in turn
            match a very small number of documents, TermsFilter may
            perform faster.
            
            <p />
            
            Which filter is best is very application dependent.
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="664bdeae-3258-b127-648e-867ae5835548.htm">FieldCacheTermsFilter<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FieldCacheTermsFilterDocIdSet</a></td><td /></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="a4a820aa-7072-3c59-6e89-95b9e7e5eb8f.htm">FieldCacheTermsFilter<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FieldCacheTermsFilterDocIdSet<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FieldCacheTermsFilterDocIdSetIterator</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5ca40d5d-1c91-5978-c819-7f32473afc65.htm">FieldComparator</a></td><td><div class="summary"> Expert: a FieldComparator compares hits so as to determine their
            sort order when collecting the top results with {@link
            TopFieldCollector}.  The concrete public FieldComparator
            classes here correspond to the SortField types.
            
            <p />This API is designed to achieve high performance
            sorting, by exposing a tight interaction with {@link
            FieldValueHitQueue} as it visits hits.  Whenever a hit is
            competitive, it's enrolled into a virtual slot, which is
            an int ranging from 0 to numHits-1.  The {@link
            FieldComparator} is made aware of segment transitions
            during searching in case any internal state it's tracking
            needs to be recomputed during these transitions.<p /><p />A comparator must define these functions:<p /><ul><li> {@link #compare} Compare a hit at 'slot a'
            with hit 'slot b'.</li><li> {@link #setBottom} This method is called by
            {@link FieldValueHitQueue} to notify the
            FieldComparator of the current weakest ("bottom")
            slot.  Note that this slot may not hold the weakest
            value according to your comparator, in cases where
            your comparator is not the primary one (ie, is only
            used to break ties from the comparators before it).</li><li> {@link #compareBottom} Compare a new hit (docID)
            against the "weakest" (bottom) entry in the queue.</li><li> {@link #copy} Installs a new hit into the
            priority queue.  The {@link FieldValueHitQueue}
            calls this method when a new hit is competitive.</li><li> {@link #setNextReader} Invoked
            when the search is switching to the next segment.
            You may need to update internal state of the
            comparator, for example retrieving new values from
            the {@link FieldCache}.</li><li> {@link #value} Return the sort value stored in
            the specified slot.  This is only called at the end
            of the search, in order to populate {@link
            FieldDoc#fields} when returning the top results.</li></ul><b>NOTE:</b> This API is experimental and might change in
            incompatible ways in the next release.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="51669422-c4d3-8879-9307-331fb4d8863f.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ByteComparator</a></td><td><div class="summary">Parses field's values as byte (using {@link
            FieldCache#getBytes} and sorts by ascending value 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="966a11cf-52e2-b899-6c36-c8f3644baabc.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>DocComparator</a></td><td><div class="summary">Sorts by ascending docID </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="ec60793d-0146-4138-3724-fbfa3d840737.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>DoubleComparator</a></td><td><div class="summary">Parses field's values as double (using {@link
            FieldCache#getDoubles} and sorts by ascending value 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a42e51be-5baf-d22b-5cf5-81e94e9cb8d3.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FloatComparator</a></td><td><div class="summary">Parses field's values as float (using {@link
            FieldCache#getFloats} and sorts by ascending value 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="9951ee2e-9ae3-de9d-696e-cf218b261b3e.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>IntComparator</a></td><td><div class="summary">Parses field's values as int (using {@link
            FieldCache#getInts} and sorts by ascending value 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b1a7ba66-0877-16fd-07ce-9e77a5e8fa34.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>LongComparator</a></td><td><div class="summary">Parses field's values as long (using {@link
            FieldCache#getLongs} and sorts by ascending value 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="001c9dd5-0c39-53b9-8f9f-c9fdaaeccd6c.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>RelevanceComparator</a></td><td><div class="summary">Sorts by descending relevance.  NOTE: if you are
            sorting only by descending relevance and then
            secondarily by ascending docID, peformance is faster
            using {@link TopScoreDocCollector} directly (which {@link
            IndexSearcher#search} uses when no {@link Sort} is
            specified). 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="62c5f5ae-587b-30d0-fd40-efe0168d1c81.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ShortComparator</a></td><td><div class="summary">Parses field's values as short (using {@link
            FieldCache#getShorts} and sorts by ascending value 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="f0f8e619-af3d-b484-5dca-09c658756fc8.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>StringComparatorLocale</a></td><td><div class="summary">Sorts by a field's value using the Collator for a
            given Locale.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="e19cadc9-e50a-7d93-a1c5-fc5588cf4e58.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>StringOrdValComparator</a></td><td><div class="summary">Sorts by field's natural String sort order, using
            ordinals.  This is functionally equivalent to {@link
            StringValComparator}, but it first resolves the string
            to their relative ordinal positions (using the index
            returned by {@link FieldCache#getStringIndex}), and
            does most comparisons using the ordinals.  For medium
            to large results, this comparator will be much faster
            than {@link StringValComparator}.  For very small
            result sets it may be slower. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5dfc65a6-636c-23d3-0abb-f048d4af29cd.htm">FieldComparator<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>StringValComparator</a></td><td><div class="summary">Sorts by field's natural String sort order.  All
            comparisons are done using String.compareTo, which is
            slow for medium to large result sets but possibly
            very fast for very small results sets. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="d45108ce-760a-7afb-0c18-ab97d5638ad7.htm">FieldComparatorSource</a></td><td><div class="summary"> Provides a {@link FieldComparator} for custom field sorting.
            
            <b>NOTE:</b> This API is experimental and might change in
            incompatible ways in the next release.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="bcaf61ba-cf04-1693-aa99-bac02487a3b7.htm">FieldDoc</a></td><td><div class="summary"> Expert: A ScoreDoc which also contains information about
            how to sort the referenced document.  In addition to the
            document number and score, this object contains an array
            of values for the document from the field(s) used to sort.
            For example, if the sort criteria was to sort by fields
            "a", "b" then "c", the <span id="cbc_25" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">fields</pre></div></span> object array
            will have three elements, corresponding respectively to
            the term values for the document in fields "a", "b" and "c".
            The class of each element in the array will be either
            Integer, Float or String depending on the type of values
            in the terms of each field.
            
            <p />Created: Feb 11, 2004 1:23:38 PM
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5162faf3-7f74-69a5-bb0f-b819dd8d133e.htm">FieldSortedHitQueue</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Expert: A hit queue for sorting by hits by terms in more than one field.
            Uses <span id="cbc_24" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">FieldCache.DEFAULT</pre></div></span> for maintaining internal term lookup tables.
            
            <p />Created: Dec 8, 2003 12:56:03 PM
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="61a602a5-190a-b6e8-3968-998eb9485444.htm">FieldValueHitQueue</a></td><td><div class="summary"> Expert: A hit queue for sorting by hits by terms in more than one field.
            Uses <span id="cbc_42" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">FieldCache.DEFAULT</pre></div></span> for maintaining
            internal term lookup tables.
            
            This class will not resolve SortField.AUTO types, and expects the type
            of all SortFields used for construction to already have been resolved. 
            {@link SortField#DetectFieldType(IndexReader, String)} is a utility method which
            may be used for field type detection.
            
            <b>NOTE:</b> This API is experimental and might change in
            incompatible ways in the next release.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="3c556ad0-64da-13cf-755e-31bb2f91b888.htm">Filter</a></td><td><div class="summary">Abstract base class for restricting which documents may be returned during searching.
            <p /><b>Note:</b> In Lucene 3.0 {@link #Bits(IndexReader)} will be removed
            and {@link #GetDocIdSet(IndexReader)} will be defined as abstract.
            All implementing classes must therefore implement {@link #GetDocIdSet(IndexReader)}
            in order to work with Lucene 3.0.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="2a41c1fe-6bed-2f63-63a4-87f11949eb07.htm">FilteredDocIdSet</a></td><td><div class="summary"> Abstract decorator class for a DocIdSet implementation
            that provides on-demand filtering/validation
            mechanism on a given DocIdSet.
            
            <p />
            
            Technically, this same functionality could be achieved
            with ChainedFilter (under contrib/misc), however the
            benefit of this class is it never materializes the full
            bitset for the filter.  Instead, the {@link #match}
            method is invoked on-demand, per docID visited during
            searching.  If you know few docIDs will be visited, and
            the logic behind {@link #match} is relatively costly,
            this may be a better way to filter than ChainedFilter.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b8022c82-7180-a03d-487c-a9af5f5275b7.htm">FilteredDocIdSetIterator</a></td><td><div class="summary"> Abstract decorator class of a DocIdSetIterator
            implementation that provides on-demand filter/validation
            mechanism on an underlying DocIdSetIterator.  See {@link
            FilteredDocIdSet}.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="cc79680f-406b-ae5b-8673-a67b0bd916bf.htm">FilteredQuery</a></td><td><div class="summary"> A query that applies a filter to the results of another query.
            
            <p />Note: the bits are retrieved from the filter each time this
            query is used in a search - use a CachingWrapperFilter to avoid
            regenerating the bits every time.
            
            <p />Created: Apr 20, 2004 8:58:29 AM
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="d5453ad2-b1ac-5d62-37eb-3f28f2696e3f.htm">FilteredTermEnum</a></td><td><div class="summary">Abstract class for enumerating a subset of all terms. 
            <p />Term enumerations are always ordered by Term.compareTo().  Each term in
            the enumeration is greater than all that precede it.  
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="96a1ae16-dfd9-8e78-45a7-6b2d81bd546a.htm">FilterManager</a></td><td><div class="summary"> Filter caching singleton.  It can be used 
            to save filters locally for reuse.
            This class makes it possble to cache Filters even when using RMI, as it
            keeps the cache on the seaercher side of the RMI connection.
            
            Also could be used as a persistent storage for any filter as long as the
            filter provides a proper hashCode(), as that is used as the key in the cache.
            
            The cache is periodically cleaned up from a separate thread to ensure the
            cache doesn't exceed the maximum size.
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="757528ca-73a9-a5aa-2e11-38aef62b4691.htm">FilterManager<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FilterCleaner</a></td><td><div class="summary"> Keeps the cache from getting too big.
            If we were using Java 1.5, we could use LinkedHashMap and we would not need this thread
            to clean out the cache.
            
            The SortedSet sortedFilterItems is used only to sort the items from the cache,
            so when it's time to clean up we have the TreeSet sort the FilterItems by
            timestamp.
            
            Removes 1.5 * the numbers of items to make the cache smaller.
            For example:
            If cache clean size is 10, and the cache is at 15, we would remove (15 - 10) * 1.5 = 7.5 round up to 8.
            This way we clean the cache a bit more, and avoid having the cache cleaner having to do it frequently.
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="c84b8964-d4cf-d8ce-89cd-ed54e6b49f29.htm">FilterManager<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FilterItem</a></td><td><div class="summary"> Holds the filter and the last time the filter was used, to make LRU-based
            cache cleaning possible.
            TODO: Clean this up when we switch to Java 1.5
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="dd4c3f2b-62b9-4fb2-55cf-59daba29ba1a.htm">FuzzyLikeThisQuery</a></td><td><div class="summary">
            Fuzzifies ALL terms provided as strings and then picks the best n differentiating terms.
            In effect this mixes the behaviour of FuzzyQuery and MoreLikeThis but with special consideration
            of fuzzy scoring factors.
            This generally produces good results for queries where users may provide details in a number of 
            fields and have no knowledge of boolean query syntax and also want a degree of fuzzy matching and
            a fast query.
            
            For each source term the fuzzy variants are held in a BooleanQuery with no coord factor (because
            we are not looking for matches on multiple variants in any one doc). Additionally, a specialized
            TermQuery is used for variants and does not use that variant term's IDF because this would favour rarer 
            terms eg misspellings. Instead, all variants use the same IDF ranking (the one for the source query 
            term) and this is factored into the variant's boost. If the source query term does not exist in the
            index the average IDF of the variants is used.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="45a21381-c1a7-eea7-dbd8-a30f7b7909ff.htm">FuzzyQuery</a></td><td><div class="summary">Implements the fuzzy search query. The similarity measurement
            is based on the Levenshtein (edit distance) algorithm.
            
            Warning: this query is not very scalable with its default prefix
            length of 0 - in this case, *every* term will be enumerated and
            cause an edit score calculation.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="2c3aee3f-3f96-c0b2-227d-93d9385137f5.htm">FuzzyQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ScoreTerm</a></td><td /></tr><tr data="class; public"><td><img src="../icons/protclass.gif" alt="Protected class" title="Protected class" /></td><td><a href="352ba6f3-9da0-10fb-ac1a-074ee3edc195.htm">FuzzyQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ScoreTermQueue</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="83774ab1-11b9-0707-d807-ea5584db6b4e.htm">FuzzyTermEnum</a></td><td><div class="summary">Subclass of FilteredTermEnum for enumerating all terms that are similiar
            to the specified filter term.
            
            <p />Term enumerations are always ordered by Term.compareTo().  Each term in
            the enumeration is greater than all that precede it.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="3e1170eb-aae1-8a12-77c5-034541cffeda.htm">Hit</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Wrapper used by {@link HitIterator} to provide a lazily loaded hit
            from {@link Hits}.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="253ccbe5-b5b5-98bf-25f3-319d3b7f9b2c.htm">HitCollector</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Lower-level search API. <br />
            HitCollectors are primarily meant to be used to implement queries, sorting
            and filtering. See {@link Collector} for a lower level and higher performance
            (on a multi-segment index) API.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="158e14d9-cf17-b757-a260-841bdcd40c13.htm">HitCollectorWrapper</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Wrapper for ({@link HitCollector}) implementations, which simply re-bases the
            incoming docID before calling {@link HitCollector#collect}.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="c7a979b3-ce30-0a9b-5697-4a85fbab34bb.htm">HitIterator</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> An iterator over {@link Hits} that provides lazy fetching of each document.
            {@link Hits#Iterator()} returns an instance of this class.  Calls to {@link #next()}
            return a {@link Hit} instance.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="497dfa46-7353-3811-bf29-9b0b5ac4659d.htm">HitQueue</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="d1711e6e-a750-9269-e88b-e76a9be918af.htm">Hits</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> A ranked list of documents, used to hold search results.
            <p /><b>Caution:</b> Iterate only over the hits needed. Iterating over all hits is
            generally not desirable and may be the source of performance issues. If you
            need to iterate over many or all hits, consider using the search method that
            takes a {@link HitCollector}.
            <p /><p /><b>Note:</b> Deleting matching documents concurrently with traversing the
            hits, might, when deleting hits that were not yet retrieved, decrease
            {@link #Length()}. In such case,
            {@link java.util.ConcurrentModificationException
            ConcurrentModificationException} is thrown when accessing hit <span id="cbc_3" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">n</pre></div></span>
            &gt; current_{@link #Length()} (but <span id="cbc_4" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">n</pre></div></span> &lt; {@link #Length()}
            _at_start).
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5a9b7524-9c41-a79d-68ab-0c875e7e49bb.htm">IndexSearcher</a></td><td><div class="summary">Implements search over a single IndexReader.
            
            <p />Applications usually need only call the inherited {@link #Search(Query)}
            or {@link #Search(Query,Filter)} methods. For performance reasons it is 
            recommended to open only one IndexSearcher and use it for all of your searches.
            
            <p />Note that you can only access Hits from an IndexSearcher as long as it is
            not yet closed, otherwise an IOException will be thrown. 
            
            <a name="thread-safety" /><p /><b>NOTE</b>: {@link
            <span id="cbc_26" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexSearcher</pre></div></span>} instances are completely
            thread safe, meaning multiple threads can call any of its
            methods, concurrently.  If your application requires
            external synchronization, you should <b>not</b>
            synchronize on the <span id="cbc_27" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexSearcher</pre></div></span> instance;
            use your own (non-Lucene) objects instead.<p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="2cccbad2-a3db-9b86-aa64-dec0ccd5b645.htm">MatchAllDocsQuery</a></td><td><div class="summary"> A query that matches all documents.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5b95eb54-7111-7bc2-d771-45335ed1563b.htm">MultiPhraseQuery</a></td><td><div class="summary"> MultiPhraseQuery is a generalized version of PhraseQuery, with an added
            method {@link #Add(Term[])}.
            To use this class, to search for the phrase "Microsoft app*" first use
            add(Term) on the term "Microsoft", then find all terms that have "app" as
            prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
            terms) to add them to the query.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="631fb83e-a2ad-51c5-0071-672383db42df.htm">MultiSearcher</a></td><td><div class="summary">Implements search over a set of <span id="cbc_10" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Searchables</pre></div></span>.
            
            <p />Applications usually need only call the inherited {@link #Search(Query)}
            or {@link #Search(Query,Filter)} methods.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="330bec05-ea94-54a7-bbc5-174c3e4a4758.htm">MultiTermQuery</a></td><td><div class="summary"> An abstract {@link Query} that matches documents
            containing a subset of terms provided by a {@link
            FilteredTermEnum} enumeration.
            
            <p />This query cannot be used directly; you must subclass
            it and define {@link #getEnum} to provide a {@link
            FilteredTermEnum} that iterates through the terms to be
            matched.
            
            <p /><b>NOTE</b>: if {@link #setRewriteMethod} is either
            {@link #CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE} or {@link
            #SCORING_BOOLEAN_QUERY_REWRITE}, you may encounter a
            {@link BooleanQuery.TooManyClauses} exception during
            searching, which happens when the number of terms to be
            searched exceeds {@link
            BooleanQuery#GetMaxClauseCount()}.  Setting {@link
            #setRewriteMethod} to {@link #CONSTANT_SCORE_FILTER_REWRITE}
            prevents this.
            
            <p />The recommended rewrite method is {@link
            #CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}: it doesn't spend CPU
            computing unhelpful scores, and it tries to pick the most
            performant rewrite method given the query.
            
            Note that {@link QueryParser} produces
            MultiTermQueries using {@link
            #CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} by default.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a2d12711-baaf-94c0-cc28-eb4006108f7a.htm">MultiTermQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>AnonymousClassConstantScoreAutoRewrite</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a8713789-57cb-4220-b8d1-70c76bdce5e1.htm">MultiTermQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ConstantScoreAutoRewrite</a></td><td><div class="summary">A rewrite method that tries to pick the best
            constant-score rewrite method based on term and
            document counts from the query.  If both the number of
            terms and documents is small enough, then {@link
            #CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE} is used.
            Otherwise, {@link #CONSTANT_SCORE_FILTER_REWRITE} is
            used.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="df6f1e8c-de2e-665b-d69e-9e772970c186.htm">MultiTermQuery<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>RewriteMethod</a></td><td><div class="summary">Abstract class that defines how the query is rewritten. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="dc4df7f6-3cca-fe41-8115-9b4804ee8313.htm">MultiTermQueryWrapperFilter</a></td><td><div class="summary"> A wrapper for {@link MultiTermQuery}, that exposes its
            functionality as a {@link Filter}.
            <p /><span id="cbc_16" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">MultiTermQueryWrapperFilter</pre></div></span> is not designed to
            be used by itself. Normally you subclass it to provide a Filter
            counterpart for a {@link MultiTermQuery} subclass.
            <p />
            For example, {@link TermRangeFilter} and {@link PrefixFilter} extend
            <span id="cbc_17" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">MultiTermQueryWrapperFilter</pre></div></span>.
            This class also provides the functionality behind
            {@link MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE};
            this is why it is not abstract.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="27232719-c355-9b22-c80d-abdb2759cc88.htm">NumericRangeFilter</a></td><td><div class="summary"> A {@link Filter} that only accepts numeric values within
            a specified range. To use this, you must first index the
            numeric values using {@link NumericField} (expert: {@link
            NumericTokenStream}).
            
            <p />You create a new NumericRangeFilter with the static
            factory methods, eg:
            
            <pre>
            Filter f = NumericRangeFilter.newFloatRange("weight",
            new Float(0.3f), new Float(0.10f),
            true, true);
            </pre>
            
            accepts all documents whose float valued "weight" field
            ranges from 0.3 to 0.10, inclusive.
            See {@link NumericRangeQuery} for details on how Lucene
            indexes and searches numeric valued fields.
            
            <p /><font color="red"><b>NOTE:</b> This API is experimental and
            might change in incompatible ways in the next
            release.</font></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="54e9c44c-814f-7f09-5484-defe9d119fcb.htm">NumericRangeQuery</a></td><td><div class="summary"><p />A {@link Query} that matches numeric values within a
            specified range.  To use this, you must first index the
            numeric values using {@link NumericField} (expert: {@link
            NumericTokenStream}).  If your terms are instead textual,
            you should use {@link TermRangeQuery}.  {@link
            NumericRangeFilter} is the filter equivalent of this
            query.<p /><p />You create a new NumericRangeQuery with the static
            factory methods, eg:
            
            <pre>
            Query q = NumericRangeQuery.newFloatRange("weight",
            new Float(0.3f), new Float(0.10f),
            true, true);
            </pre>
            
            matches all documents whose float valued "weight" field
            ranges from 0.3 to 0.10, inclusive.
            
            <p />The performance of NumericRangeQuery is much better
            than the corresponding {@link TermRangeQuery} because the
            number of terms that must be searched is usually far
            fewer, thanks to trie indexing, described below.<p /><p />You can optionally specify a <a href="#precisionStepDesc"><span id="cbc_29" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionStep</pre></div></span></a>
            when creating this query.  This is necessary if you've
            changed this configuration from its default (4) during
            indexing.  Lower values consume more disk space but speed
            up searching.  Suitable values are between <b>1</b> and
            <b>8</b>. A good starting point to test is <b>4</b>,
            which is the default value for all <span id="cbc_30" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Numeric*</pre></div></span>
            classes.  See <a href="#precisionStepDesc">below</a> for
            details.
            
            <p />This query defaults to {@linkplain
            MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} for
            32 bit (int/float) ranges with precisionStep &lt;8 and 64
            bit (long/double) ranges with precisionStep &lt;6.
            Otherwise it uses {@linkplain
            MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE} as the
            number of terms is likely to be high.  With precision
            steps of &lt;4, this query can be run with one of the
            BooleanQuery rewrite methods without changing
            BooleanQuery's default max clause count.
            
            <p /><font color="red"><b>NOTE:</b> This API is experimental and
            might change in incompatible ways in the next release.</font><br /><h3>How it works</h3><p />See the publication about <a target="_blank" href="http://www.panfmp.org">panFMP</a>,
            where this algorithm was described (referred to as <span id="cbc_31" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">TrieRangeQuery</pre></div></span>):
            
            <blockquote><strong>Schindler, U, Diepenbroek, M</strong>, 2008.
            <em>Generic XML-based Framework for Metadata Portals.</em>
            Computers &amp; Geosciences 34 (12), 1947-1955.
            <a href="http://dx.doi.org/10.1016/j.cageo.2008.02.023" target="_blank">doi:10.1016/j.cageo.2008.02.023</a></blockquote><p /><em>A quote from this paper:</em> Because Apache Lucene is a full-text
            search engine and not a conventional database, it cannot handle numerical ranges
            (e.g., field value is inside user defined bounds, even dates are numerical values).
            We have developed an extension to Apache Lucene that stores
            the numerical values in a special string-encoded format with variable precision
            (all numerical values like doubles, longs, floats, and ints are converted to
            lexicographic sortable string representations and stored with different precisions
            (for a more detailed description of how the values are stored,
            see {@link NumericUtils}). A range is then divided recursively into multiple intervals for searching:
            The center of the range is searched only with the lowest possible precision in the <em>trie</em>,
            while the boundaries are matched more exactly. This reduces the number of terms dramatically.<p /><p />For the variant that stores long values in 8 different precisions (each reduced by 8 bits) that
            uses a lowest precision of 1 byte, the index contains only a maximum of 256 distinct values in the
            lowest precision. Overall, a range could consist of a theoretical maximum of
            <span id="cbc_32" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-number">7</span>*<span class="highlight-number">255</span>*<span class="highlight-number">2</span> + <span class="highlight-number">255</span> = <span class="highlight-number">3825</span></pre></div></span> distinct terms (when there is a term for every distinct value of an
            8-byte-number in the index and the range covers almost all of them; a maximum of 255 distinct values is used
            because it would always be possible to reduce the full 256 values to one term with degraded precision).
            In practice, we have seen up to 300 terms in most cases (index with 500,000 metadata records
            and a uniform value distribution).<p /><a name="precisionStepDesc" /><h3>Precision Step</h3><p />You can choose any <span id="cbc_33" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionStep</pre></div></span> when encoding values.
            Lower step values mean more precisions and so more terms in index (and index gets larger).
            On the other hand, the maximum number of terms to match reduces, which optimized query speed.
            The formula to calculate the maximum term count is:
            <pre>
            n = [ (bitsPerValue/precisionStep - 1) * (2^precisionStep - 1 ) * 2 ] + (2^precisionStep - 1 )
            </pre><p /><em>(this formula is only correct, when <span id="cbc_34" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">bitsPerValue/precisionStep</pre></div></span> is an integer;
            in other cases, the value must be rounded up and the last summand must contain the modulo of the division as
            precision step)</em>.
            For longs stored using a precision step of 4, <span id="cbc_35" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">n = <span class="highlight-number">15</span>*<span class="highlight-number">15</span>*<span class="highlight-number">2</span> + <span class="highlight-number">15</span> = <span class="highlight-number">465</span></pre></div></span>, and for a precision
            step of 2, <span id="cbc_36" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">n = <span class="highlight-number">31</span>*<span class="highlight-number">3</span>*<span class="highlight-number">2</span> + <span class="highlight-number">3</span> = <span class="highlight-number">189</span></pre></div></span>. But the faster search speed is reduced by more seeking
            in the term enum of the index. Because of this, the ideal <span id="cbc_37" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionStep</pre></div></span> value can only
            be found out by testing. <b>Important:</b> You can index with a lower precision step value and test search speed
            using a multiple of the original step value.<p /><p />Good values for <span id="cbc_38" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionStep</pre></div></span> are depending on usage and data type:
            <ul><li>The default for all data types is <b>4</b>, which is used, when no <span id="cbc_39" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionStep</pre></div></span> is given.</li><li>Ideal value in most cases for <em>64 bit</em> data types <em>(long, double)</em> is <b>6</b> or <b>8</b>.</li><li>Ideal value in most cases for <em>32 bit</em> data types <em>(int, float)</em> is <b>4</b>.</li><li>Steps <b>&gt;64</b> for <em>long/double</em> and <b>&gt;32</b> for <em>int/float</em> produces one token
            per value in the index and querying is as slow as a conventional {@link TermRangeQuery}. But it can be used
            to produce fields, that are solely used for sorting (in this case simply use {@link Integer#MAX_VALUE} as
            <span id="cbc_40" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionStep</pre></div></span>). Using {@link NumericField NumericFields} for sorting
            is ideal, because building the field cache is much faster than with text-only numbers.
            Sorting is also possible with range query optimized fields using one of the above <span id="cbc_41" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">precisionSteps</pre></div></span>.</li></ul><p />Comparisons of the different types of RangeQueries on an index with about 500,000 docs showed
            that {@link TermRangeQuery} in boolean rewrite mode (with raised {@link BooleanQuery} clause count)
            took about 30-40 secs to complete, {@link TermRangeQuery} in constant score filter rewrite mode took 5 secs
            and executing this class took &lt;100ms to complete (on an Opteron64 machine, Java 1.5, 8 bit
            precision step). This query type was developed for a geographic portal, where the performance for
            e.g. bounding boxes or exact date/time stamps is important.<p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="14bdeafb-e12b-dea3-c30b-4c5c0229780b.htm">ParallelMultiSearcher</a></td><td><div class="summary">Implements parallel search over a set of <span id="cbc_44" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Searchables</pre></div></span>.
            
            <p />Applications usually need only call the inherited {@link #Search(Query)}
            or {@link #Search(Query,Filter)} methods.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="ce7a97b0-975e-a5d8-796f-7954131a5f3b.htm">PhraseQuery</a></td><td><div class="summary">A Query that matches documents containing a particular sequence of terms.
            A PhraseQuery is built by QueryParser for input like <span id="cbc_28" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-literal">"new york"</span></pre></div></span>.
            
            <p />This query may be combined with other terms or queries with a {@link BooleanQuery}.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a672f4ab-49e2-bbca-0bd9-0acecd4f8ad1.htm">PositiveScoresOnlyCollector</a></td><td><div class="summary"> A {@link Collector} implementation which wraps another
            {@link Collector} and makes sure only documents with
            scores &gt; 0 are collected.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="74826dc1-4096-50d3-f6ed-8c0131a4ae21.htm">PrefixFilter</a></td><td><div class="summary"> A Filter that restricts search results to values that have a matching prefix in a given
            field.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="0158ef43-4096-d67d-198d-9b66801f55a1.htm">PrefixQuery</a></td><td><div class="summary">A Query that matches documents containing terms with a specified prefix. A PrefixQuery
            is built by QueryParser for input like <span id="cbc_43" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">app*</pre></div></span>.
            
            <p />This query uses the {@link
            MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}
            rewrite method. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="59c72d3c-aafc-1693-5a44-978978b9b386.htm">PrefixTermEnum</a></td><td><div class="summary"> Subclass of FilteredTermEnum for enumerating all terms that match the
            specified prefix filter term.
            <p />
            Term enumerations are always ordered by Term.compareTo().  Each term in
            the enumeration is greater than all that precede it.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="92f5b96d-ab32-4c16-79a2-bdc2e707f1fe.htm">Query</a></td><td><div class="summary">The abstract base class for queries.
            <p />Instantiable subclasses are:
            <ul><li> {@link TermQuery} </li><li> {@link MultiTermQuery} </li><li> {@link BooleanQuery} </li><li> {@link WildcardQuery} </li><li> {@link PhraseQuery} </li><li> {@link PrefixQuery} </li><li> {@link MultiPhraseQuery} </li><li> {@link FuzzyQuery} </li><li> {@link TermRangeQuery} </li><li> {@link NumericRangeQuery} </li><li> {@link Lucene.Net.Search.Spans.SpanQuery} </li></ul><p />A parser for queries is contained in:
            <ul><li>{@link Lucene.Net.QueryParsers.QueryParser QueryParser} </li></ul></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a6a72501-df3f-3a72-2176-61cf32530a36.htm">QueryFilter</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary">Constrains search results to only match those which also match a provided
            query.  Results are cached, so that searches after the first on the same
            index using this filter are much faster.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="db380eee-8d47-aac2-9186-f30b3208632d.htm">QueryTermVector</a></td><td><div class="summary" /></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="fac4769a-6b61-2854-8f0b-28a6899a1d07.htm">QueryWrapperFilter</a></td><td><div class="summary"> Constrains search results to only match those which also match a provided
            query.  
            
            <p /> This could be used, for example, with a {@link TermRangeQuery} on a suitably
            formatted date field to implement date filtering.  One could re-use a single
            QueryFilter that matches, e.g., only documents modified within the last
            week.  The QueryFilter and TermRangeQuery would only need to be reconstructed
            once per day.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="01520638-de49-01c4-2583-b86853e7af2f.htm">RangeFilter</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> A Filter that restricts search results to a range of values in a given
            field.
            
            <p />This filter matches the documents looking for terms that fall into the
            supplied range according to {@link String#compareTo(String)}. It is not intended
            for numerical ranges, use {@link NumericRangeFilter} instead.
            
            <p />If you construct a large number of range filters with different ranges but on the 
            same field, {@link FieldCacheRangeFilter} may have significantly better performance. 
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="349d6bc5-b23b-bf8e-0db0-45ec3257aa75.htm">RangeQuery</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> A Query that matches documents within an exclusive range of terms.
            
            <p />This query matches the documents looking for terms that fall into the
            supplied range according to {@link Term#CompareTo(Term)}. It is not intended
            for numerical ranges, use {@link NumericRangeQuery} instead.
            
            <p />This query uses {@linkplain
            MultiTermQuery#SCORING_BOOLEAN_QUERY_REWRITE}.  If you
            want to change this, use the new {@link TermRangeQuery}
            instead.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="8b8aebd7-59c9-bc26-3692-b652586c0c01.htm">ScoreCachingWrappingScorer</a></td><td><div class="summary"> A {@link Scorer} which wraps another scorer and caches the score of the
            current document. Successive calls to {@link #Score()} will return the same
            result and will not invoke the wrapped Scorer's score() method, unless the
            current document has changed.<br />
            This class might be useful due to the changes done to the {@link Collector}
            interface, in which the score is not computed for a document by default, only
            if the collector requests it. Some collectors may need to use the score in
            several places, however all they have in hand is a {@link Scorer} object, and
            might end up computing the score of a document more than once.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="2179f5db-147c-57a2-542b-e8a00d427b01.htm">ScoreDoc</a></td><td><div class="summary">Expert: Returned by low-level search implementations.</div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b799607c-c1a3-6091-e697-9560f9b1165b.htm">Scorer</a></td><td><div class="summary"> Expert: Common scoring functionality for different types of queries.
            
            <p />
            A <span id="cbc_1" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Scorer</pre></div></span> iterates over documents matching a
            query in increasing order of doc Id.
            <p /><p />
            Document scores are computed using a given <span id="cbc_2" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Similarity</pre></div></span>
            implementation.
            <p /><p /><b>NOTE</b>: The values Float.Nan,
            Float.NEGATIVE_INFINITY and Float.POSITIVE_INFINITY are
            not valid scores.  Certain collectors (eg {@link
            TopScoreDocCollector}) will not properly collect hits
            with these scores.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="83067494-1956-99a4-0b0b-83aa5504c424.htm">Searcher</a></td><td><div class="summary"> An abstract base class for search implementations. Implements the main search
            methods.
            
            <p />
            Note that you can only access hits from a Searcher as long as it is not yet
            closed, otherwise an IOException will be thrown.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="cf113347-e96f-3c18-5b30-ccddb57ae08c.htm">Similarity</a></td><td><div class="summary">Expert: Scoring API.
            <p />Subclasses implement search scoring.
            
            <p />The score of query <span id="cbc_18" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">q</pre></div></span> for document <span id="cbc_19" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">d</pre></div></span> correlates to the
            cosine-distance or dot-product between document and query vectors in a
            <a href="http://en.wikipedia.org/wiki/Vector_Space_Model">
            Vector Space Model (VSM) of Information Retrieval</a>.
            A document whose vector is closer to the query vector in that model is scored higher.
            
            The score is computed as follows:
            
            <p /><table cellpadding="1" cellspacing="0" border="1" align="center"><tr><td><table cellpadding="1" cellspacing="0" border="0" align="center"><tr><td valign="middle" align="right" rowspan="1">
            score(q,d)   =  
            coord(q,d)  · 
            queryNorm(q)  · 
            </td><td valign="bottom" align="center" rowspan="1">∑</td><td valign="middle" align="right" rowspan="1">(tf(t in d)  · 
            idf(t)<sup>2</sup>  · 
            t.getBoost() · 
            norm(t,d))</td></tr><tr valigh="top"><td /><td align="center">t in q</td><td /></tr></table></td></tr></table><p /> where
            <ol><li><b>tf(t in d)</b>
            correlates to the term's <i>frequency</i>,
            defined as the number of times term <i>t</i> appears in the currently scored document <i>d</i>.
            Documents that have more occurrences of a given term receive a higher score.
            The default computation for <i>tf(t in d)</i> in
            {@link Lucene.Net.Search.DefaultSimilarity#Tf(float) DefaultSimilarity} is:
            
            <br /> <br /><table cellpadding="2" cellspacing="2" border="0" align="center"><tr><td valign="middle" align="right" rowspan="1">
            {@link Lucene.Net.Search.DefaultSimilarity#Tf(float) tf(t in d)}   =  
            </td><td valign="top" align="center" rowspan="1">
            frequency<sup>½</sup></td></tr></table><br /> <br /></li><li><b>idf(t)</b> stands for Inverse Document Frequency. This value
            correlates to the inverse of <i>docFreq</i>
            (the number of documents in which the term <i>t</i> appears).
            This means rarer terms give higher contribution to the total score.
            The default computation for <i>idf(t)</i> in
            {@link Lucene.Net.Search.DefaultSimilarity#Idf(int, int) DefaultSimilarity} is:
            
            <br /> <br /><table cellpadding="2" cellspacing="2" border="0" align="center"><tr><td valign="middle" align="right">
            {@link Lucene.Net.Search.DefaultSimilarity#Idf(int, int) idf(t)}  =  
            </td><td valign="middle" align="center">
            1 + log (</td><td valign="middle" align="center"><table><tr><td align="center">numDocs</td></tr><tr><td align="center">–––––––––</td></tr><tr><td align="center">docFreq+1</td></tr></table></td><td valign="middle" align="center">)</td></tr></table><br /> <br /></li><li><b>coord(q,d)</b>
            is a score factor based on how many of the query terms are found in the specified document.
            Typically, a document that contains more of the query's terms will receive a higher score
            than another document with fewer query terms.
            This is a search time factor computed in
            {@link #Coord(int, int) coord(q,d)}
            by the Similarity in effect at search time.
            <br /> <br /></li><li><b>
            queryNorm(q)
            </b>
            is a normalizing factor used to make scores between queries comparable.
            This factor does not affect document ranking (since all ranked documents are multiplied by the same factor),
            but rather just attempts to make scores from different queries (or even different indexes) comparable.
            This is a search time factor computed by the Similarity in effect at search time.
            
            The default computation in
            {@link Lucene.Net.Search.DefaultSimilarity#QueryNorm(float) DefaultSimilarity}
            is:
            <br /> <br /><table cellpadding="1" cellspacing="0" border="0" align="center"><tr><td valign="middle" align="right" rowspan="1">
            queryNorm(q)    =  
            {@link Lucene.Net.Search.DefaultSimilarity#QueryNorm(float) queryNorm(sumOfSquaredWeights)}
              =  
            </td><td valign="middle" align="center" rowspan="1"><table><tr><td align="center">1</td></tr><tr><td align="center">
            ––––––––––––––
            </td></tr><tr><td align="center">sumOfSquaredWeights<sup>½</sup></td></tr></table></td></tr></table><br /> <br />
            
            The sum of squared weights (of the query terms) is
            computed by the query {@link Lucene.Net.Search.Weight} object.
            For example, a {@link Lucene.Net.Search.BooleanQuery boolean query}
            computes this value as:
            
            <br /> <br /><table cellpadding="1" cellspacing="0" border="0" align="center"><tr><td valign="middle" align="right" rowspan="1">
            {@link Lucene.Net.Search.Weight#SumOfSquaredWeights() sumOfSquaredWeights}   =  
            {@link Lucene.Net.Search.Query#GetBoost() q.getBoost()} <sup>2</sup>
             · 
            </td><td valign="bottom" align="center" rowspan="1">∑</td><td valign="middle" align="right" rowspan="1">(idf(t)  · 
            t.getBoost()) <sup>2</sup></td></tr><tr valigh="top"><td /><td align="center">t in q</td><td /></tr></table><br /> <br /></li><li><b>t.getBoost()</b>
            is a search time boost of term <i>t</i> in the query <i>q</i> as
            specified in the query text
            (see query syntax),
            or as set by application calls to
            {@link Lucene.Net.Search.Query#SetBoost(float) setBoost()}.
            Notice that there is really no direct API for accessing a boost of one term in a multi term query,
            but rather multi terms are represented in a query as multi
            {@link Lucene.Net.Search.TermQuery TermQuery} objects,
            and so the boost of a term in the query is accessible by calling the sub-query
            {@link Lucene.Net.Search.Query#GetBoost() getBoost()}.
            <br /> <br /></li><li><b>norm(t,d)</b> encapsulates a few (indexing time) boost and length factors:
            
            <ul><li><b>Document boost</b> - set by calling
            {@link Lucene.Net.Documents.Document#SetBoost(float) doc.setBoost()}
            before adding the document to the index.
            </li><li><b>Field boost</b> - set by calling
            {@link Lucene.Net.Documents.Fieldable#SetBoost(float) field.setBoost()}
            before adding the field to a document.
            </li><li>{@link #LengthNorm(String, int) <b>lengthNorm</b>(field)} - computed
            when the document is added to the index in accordance with the number of tokens
            of this field in the document, so that shorter fields contribute more to the score.
            LengthNorm is computed by the Similarity class in effect at indexing.
            </li></ul><p />
            When a document is added to the index, all the above factors are multiplied.
            If the document has multiple fields with the same name, all their boosts are multiplied together:
            
            <br /> <br /><table cellpadding="1" cellspacing="0" border="0" align="center"><tr><td valign="middle" align="right" rowspan="1">
            norm(t,d)   =  
            {@link Lucene.Net.Documents.Document#GetBoost() doc.getBoost()}
             · 
            {@link #LengthNorm(String, int) lengthNorm(field)}
             · 
            </td><td valign="bottom" align="center" rowspan="1">∏</td><td valign="middle" align="right" rowspan="1">
            {@link Lucene.Net.Documents.Fieldable#GetBoost() f.getBoost}()
            </td></tr><tr valigh="top"><td /><td align="center">field <i><b>f</b></i> in <i>d</i> named as <i><b>t</b></i></td><td /></tr></table><br /> <br />
            However the resulted <i>norm</i> value is {@link #EncodeNorm(float) encoded} as a single byte
            before being stored.
            At search time, the norm byte value is read from the index
            {@link Lucene.Net.Store.Directory directory} and
            {@link #DecodeNorm(byte) decoded} back to a float <i>norm</i> value.
            This encoding/decoding, while reducing index size, comes with the price of
            precision loss - it is not guaranteed that decode(encode(x)) = x.
            For instance, decode(encode(0.89)) = 0.75.
            Also notice that search time is too late to modify this <i>norm</i> part of scoring, e.g. by
            using a different {@link Similarity} for search.
            <br /> <br /></li></ol></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="59bcc1bf-3265-0fdd-867d-3e3366bb41ea.htm">SimilarityDelegator</a></td><td><div class="summary">Expert: Delegating scoring implementation.  Useful in {@link
            Query#GetSimilarity(Searcher)} implementations, to override only certain
            methods of a Searcher's Similiarty implementation.. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="4a31bfb6-0ab7-714e-6d19-5338f10ff01b.htm">SimpleFacetedSearch</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="0a1ddcb8-2f76-77c8-682a-fa6e1c307ed3.htm">SimpleFacetedSearch<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>FacetName</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="abcc51ea-56f5-983f-1941-5c020d4d92a7.htm">SimpleFacetedSearch<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>Hits</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="0b39ffdb-0812-62ab-623c-06ea2f1bed61.htm">SimpleFacetedSearch<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>HitsPerFacet</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="df5c765f-9920-87d3-27ec-a2e470ad250d.htm">Sort</a></td><td><div class="summary"> Encapsulates sort criteria for returned hits.
            
            <p />The fields used to determine sort order must be carefully chosen.
            Documents must contain a single term in such a field,
            and the value of the term should indicate the document's relative position in
            a given sort order.  The field must be indexed, but should not be tokenized,
            and does not need to be stored (unless you happen to want it back with the
            rest of your document data).  In other words:
            
            <p /><span id="cbc_45" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">document.add (<span class="highlight-keyword">new</span> Field (<span class="highlight-literal">"byNumber"</span>, Integer.toString(x), Field.Store.NO, Field.Index.NOT_ANALYZED));</pre></div></span><p /><p /><h3>Valid Types of Values</h3><p />There are four possible kinds of term values which may be put into
            sorting fields: Integers, Longs, Floats, or Strings.  Unless
            {@link SortField SortField} objects are specified, the type of value
            in the field is determined by parsing the first term in the field.
            
            <p />Integer term values should contain only digits and an optional
            preceding negative sign.  Values must be base 10 and in the range
            <span id="cbc_46" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Integer.MIN_VALUE</pre></div></span> and <span id="cbc_47" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Integer.MAX_VALUE</pre></div></span> inclusive.
            Documents which should appear first in the sort
            should have low value integers, later documents high values
            (i.e. the documents should be numbered <span id="cbc_48" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-number">1</span>..n</pre></div></span> where
            <span id="cbc_49" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-number">1</span></pre></div></span> is the first and <span id="cbc_50" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">n</pre></div></span> the last).
            
            <p />Long term values should contain only digits and an optional
            preceding negative sign.  Values must be base 10 and in the range
            <span id="cbc_51" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Long.MIN_VALUE</pre></div></span> and <span id="cbc_52" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Long.MAX_VALUE</pre></div></span> inclusive.
            Documents which should appear first in the sort
            should have low value integers, later documents high values.
            
            <p />Float term values should conform to values accepted by
            {@link Float Float.valueOf(String)} (except that <span id="cbc_53" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">NaN</pre></div></span>
            and <span id="cbc_54" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Infinity</pre></div></span> are not supported).
            Documents which should appear first in the sort
            should have low values, later documents high values.
            
            <p />String term values can contain any valid String, but should
            not be tokenized.  The values are sorted according to their
            {@link Comparable natural order}.  Note that using this type
            of term value has higher memory requirements than the other
            two types.
            
            <p /><h3>Object Reuse</h3><p />One of these objects can be
            used multiple times and the sort order changed between usages.
            
            <p />This class is thread safe.
            
            <p /><h3>Memory Usage</h3><p />Sorting uses of caches of term values maintained by the
            internal HitQueue(s).  The cache is static and contains an integer
            or float array of length <span id="cbc_55" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexReader.maxDoc()</pre></div></span> for each field
            name for which a sort is performed.  In other words, the size of the
            cache in bytes is:
            
            <p /><span id="cbc_56" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-number">4</span> * IndexReader.maxDoc() * (# of different fields actually used to sort)</pre></div></span><p />For String fields, the cache is larger: in addition to the
            above array, the value of every term in the field is kept in memory.
            If there are many unique terms in the field, this could
            be quite large.
            
            <p />Note that the size of the cache is not affected by how many
            fields are in the index and <i>might</i> be used to sort - only by
            the ones actually used to sort a result set.
            
            <p />Created: Feb 12, 2004 10:53:57 AM
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="d9262c12-6c3a-6b9f-cf2b-cacdce379bc3.htm">SortComparator</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Abstract base class for sorting hits returned by a Query.
            
            <p />
            This class should only be used if the other SortField types (SCORE, DOC,
            STRING, INT, FLOAT) do not provide an adequate sorting. It maintains an
            internal cache of values which could be quite large. The cache is an array of
            Comparable, one for each document in the index. There is a distinct
            Comparable for each unique term in the field - if some documents have the
            same term in the field, the cache array will have entries which reference the
            same Comparable.
            
            This class will be used as part of a key to a FieldCache value. You must
            implement hashCode and equals to avoid an explosion in RAM usage if you use
            instances that are not the same instance. If you are searching using the
            Remote contrib, the same instance of this class on the client will be a new
            instance on every call to the server, so hashCode/equals is very important in
            that situation.
            
            <p />
            Created: Apr 21, 2004 5:08:38 PM
            
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="edb7b041-a8ee-7b6c-3659-0ed51b507224.htm">SortField</a></td><td><div class="summary"> Stores information about how to sort documents by terms in an individual
            field.  Fields must be indexed in order to sort by them.
            
            <p />Created: Feb 11, 2004 1:25:29 PM
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="627945a3-a44b-a553-75e7-de7f9711166f.htm">SpanFilter</a></td><td><div class="summary">Abstract base class providing a mechanism to restrict searches to a subset
            of an index and also maintains and returns position information.
            This is useful if you want to compare the positions from a SpanQuery with the positions of items in
            a filter.  For instance, if you had a SpanFilter that marked all the occurrences of the word "foo" in documents,
            and then you entered a new SpanQuery containing bar, you could not only filter by the word foo, but you could
            then compare position information for post processing.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="9a78cb0a-93a1-e3ea-aef9-f8f0c77bc102.htm">SpanFilterResult</a></td><td><div class="summary">  The results of a SpanQueryFilter.  Wraps the BitSet and the position information from the SpanQuery
            
            <p />
            NOTE: This API is still experimental and subject to change. 
            
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="4b15784a-b71c-9dad-bc04-fde74a2bcdb0.htm">SpanFilterResult<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>PositionInfo</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="22f7a321-5fc6-aadc-e369-44fb53b05612.htm">SpanFilterResult<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>StartEnd</a></td><td /></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="5807fb4a-1a5f-d714-532a-fcd64fff9b03.htm">SpanQueryFilter</a></td><td><div class="summary"> Constrains search results to only match those which also match a provided
            query. Also provides position information about where each document matches
            at the cost of extra space compared with the QueryWrapperFilter.
            There is an added cost to this above what is stored in a {@link QueryWrapperFilter}.  Namely,
            the position information for each matching document is stored.
            <p />
            This filter does not cache.  See the {@link Lucene.Net.Search.CachingSpanFilter} for a wrapper that
            caches.
            
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="472e5582-9ad1-0003-0d2a-655aff996bec.htm">StringIndex</a></td><td><div class="summary">Expert: Stores term text values and document ordering data. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="f1b437ad-e9e3-b205-071d-80103d3b7dff.htm">TermQuery</a></td><td><div class="summary">A Query that matches documents containing a term.
            This may be combined with other terms with a {@link BooleanQuery}.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="88b52f0d-c44d-dea7-ecb9-092ef354c488.htm">TermRangeFilter</a></td><td><div class="summary"> A Filter that restricts search results to a range of values in a given
            field.
            
            <p />This filter matches the documents looking for terms that fall into the
            supplied range according to {@link String#compareTo(String)}. It is not intended
            for numerical ranges, use {@link NumericRangeFilter} instead.
            
            <p />If you construct a large number of range filters with different ranges but on the 
            same field, {@link FieldCacheRangeFilter} may have significantly better performance. 
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="be15b874-7e51-838a-0f34-f6d35f510906.htm">TermRangeQuery</a></td><td><div class="summary"> A Query that matches documents within an exclusive range of terms.
            
            <p />This query matches the documents looking for terms that fall into the
            supplied range according to {@link String#compareTo(String)}. It is not intended
            for numerical ranges, use {@link NumericRangeQuery} instead.
            
            <p />This query uses the {@link
            MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}
            rewrite method.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="13f1310a-5899-a287-8e0a-459b8bb9e90c.htm">TermRangeTermEnum</a></td><td><div class="summary"> Subclass of FilteredTermEnum for enumerating all terms that match the
            specified range parameters.
            <p />
            Term enumerations are always ordered by Term.compareTo().  Each term in
            the enumeration is greater than all that precede it.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="737c0afa-fa8d-79ec-384a-f488bb2fcb14.htm">TermScorer</a></td><td><div class="summary">Expert: A <span id="cbc_11" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Scorer</pre></div></span> for documents matching a <span id="cbc_12" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Term</pre></div></span>.</div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="8a8cbb79-f79d-0dc6-b94f-d4e825aed1dc.htm">TermsFilter</a></td><td><div class="summary">
            A filter that contains multiple terms.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="344fd0ac-d2fe-4e4c-9958-e14d9985fb37.htm">TimeLimitedCollector</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"><p />
            The TimeLimitedCollector is used to timeout search requests that take longer
            than the maximum allowed search time limit. After this time is exceeded, the
            search thread is stopped by throwing a TimeExceeded Exception.
            <p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="9a51427d-acda-d1f2-12fb-1bf028fdf5b4.htm">TimeLimitedCollector<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>TimeExceededException</a></td><td><div class="summary"> Thrown when elapsed search time exceeds allowed search time. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="2b52cf54-e736-ee9d-08db-7682eb977107.htm">TimeLimitingCollector</a></td><td><div class="summary"> The {@link TimeLimitingCollector} is used to timeout search requests that
            take longer than the maximum allowed search time limit. After this time is
            exceeded, the search thread is stopped by throwing a
            {@link TimeExceededException}.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="d4fa87d3-e3ab-a804-29e7-7bafb96879d1.htm">TimeLimitingCollector<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>TimeExceededException</a></td><td><div class="summary">Thrown when elapsed search time exceeds allowed search time. </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="f65e5259-e16a-ca88-6991-726626cb3270.htm">TopDocCollector</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary">A {@link HitCollector} implementation that collects the top-scoring
            documents, returning them as a {@link TopDocs}.  This is used by {@link
            IndexSearcher} to implement {@link TopDocs}-based search.
            
            <p />This may be extended, overriding the collect method to, e.g.,
            conditionally invoke <span id="cbc_14" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">super()</pre></div></span> in order to filter which
            documents are collected.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="6c8501ee-1d97-beb3-b632-efa33880dea7.htm">TopDocs</a></td><td><div class="summary"> Represents hits returned by {@link
            * Searcher#search(Query,Filter,int)} and {@link
            * Searcher#search(Query,int)
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="a3940450-ec1a-c984-b4ef-056bd2138b89.htm">TopDocsCollector</a></td><td><div class="summary"> A base class for all collectors that return a {@link TopDocs} output. This
            collector allows easy extension by providing a single constructor which
            accepts a {@link PriorityQueue} as well as protected members for that
            priority queue and a counter of the number of total hits.<br />
            Extending classes can override {@link #TopDocs(int, int)} and
            {@link #GetTotalHits()} in order to provide their own implementation.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="0ab813c2-8719-f2d0-2c90-785e946f95e7.htm">TopFieldCollector</a></td><td><div class="summary"> A {@link Collector} that sorts by {@link SortField} using
            {@link FieldComparator}s.
            <p />
            See the {@link #create(Lucene.Net.Search.Sort, int, boolean, boolean, boolean, boolean)} method
            for instantiating a TopFieldCollector.
            
            <p /><b>NOTE:</b> This API is experimental and might change in
            incompatible ways in the next release.<p /></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="499b5478-09db-d154-c39f-cbf9a1f19a01.htm">TopFieldDocCollector</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary">A {@link HitCollector} implementation that collects the top-sorting
            documents, returning them as a {@link TopFieldDocs}.  This is used by {@link
            IndexSearcher} to implement {@link TopFieldDocs}-based search.
            
            <p />This may be extended, overriding the collect method to, e.g.,
            conditionally invoke <span id="cbc_15" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">super()</pre></div></span> in order to filter which
            documents are collected.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="90c28660-5efc-f641-6b41-af6b11e4d952.htm">TopFieldDocs</a></td><td><div class="summary">
            Represents hits returned by {@link Searcher#search(Query,Filter,int,Sort)}.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="bed57452-941b-5ce0-3ce3-7aa549f846d4.htm">TopScoreDocCollector</a></td><td><div class="summary"> A {@link Collector} implementation that collects the top-scoring hits,
            returning them as a {@link TopDocs}. This is used by {@link IndexSearcher} to
            implement {@link TopDocs}-based search. Hits are sorted by score descending
            and then (when the scores are tied) docID ascending. When you create an
            instance of this collector you should know in advance whether documents are
            going to be collected in doc Id order or not.
            
            <p /><b>NOTE</b>: The values {@link Float#NaN} and
            {Float#NEGATIVE_INFINITY} are not valid scores.  This
            collector will not properly collect hits with such
            scores.
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b7b145f3-1dc1-318f-38d7-6b39af2a3217.htm">Weight</a></td><td><div class="summary"> Expert: Calculate query weights and build query scorers.
            <p />
            The purpose of {@link Weight} is to ensure searching does not
            modify a {@link Query}, so that a {@link Query} instance can be reused. <br />
            {@link Searcher} dependent state of the query should reside in the
            {@link Weight}. <br />
            {@link IndexReader} dependent state should reside in the {@link Scorer}.
            <p />
            A <span id="cbc_5" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Weight</pre></div></span> is used in the following way:
            <ol><li>A <span id="cbc_6" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Weight</pre></div></span> is constructed by a top-level query, given a
            <span id="cbc_7" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Searcher</pre></div></span> ({@link Query#CreateWeight(Searcher)}).</li><li>The {@link #SumOfSquaredWeights()} method is called on the
            <span id="cbc_8" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Weight</pre></div></span> to compute the query normalization factor
            {@link Similarity#QueryNorm(float)} of the query clauses contained in the
            query.</li><li>The query normalization factor is passed to {@link #Normalize(float)}. At
            this point the weighting is complete.</li><li>A <span id="cbc_9" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">Scorer</pre></div></span> is constructed by {@link #Scorer(IndexReader,boolean,boolean)}.</li></ol></div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="b3142a6c-d27e-058e-024a-10937b769c21.htm">WildcardQuery</a></td><td><div class="summary">Implements the wildcard search query. Supported wildcards are <span id="cbc_20" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">*</pre></div></span>, which
            matches any character sequence (including the empty one), and <span id="cbc_21" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">?</pre></div></span>,
            which matches any single character. Note this query can be slow, as it
            needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,
            a Wildcard term should not start with one of the wildcards <span id="cbc_22" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">*</pre></div></span> or
            <span id="cbc_23" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">?</pre></div></span>.
            
            <p />This query uses the {@link
            MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}
            rewrite method.
            
            </div></td></tr><tr data="class; public"><td><img src="../icons/pubclass.gif" alt="Public class" title="Public class" /></td><td><a href="8160935a-ad83-0dd3-db5f-1cad1731cbea.htm">WildcardTermEnum</a></td><td><div class="summary"> Subclass of FilteredTermEnum for enumerating all terms that match the
            specified wildcard filter term.
            <p />
            Term enumerations are always ordered by Term.compareTo().  Each term in
            the enumeration is greater than all that precede it.
            
            </div></td></tr></table></div><h1 class="heading"><span onclick="ExpandCollapse(structureToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(structureToggle, event)" tabindex="0"><img id="structureToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Structures</span></h1><div id="structureSection" class="section" name="collapseableSection" style=""><table id="typeList" class="members" frame="lhs" cellpadding="2"><col width="10%" /><tr><th class="iconColumn">
           
       </th><th class="nameColumn">Structure</th><th class="descriptionColumn">Description</th></tr><tr data="structure; public"><td><img src="../icons/pubstructure.gif" alt="Public structure" title="Public structure" /></td><td><a href="133e4097-502f-58a5-44d9-60126e471648.htm">FieldCache_Fields</a></td><td /></tr><tr data="structure; public"><td><img src="../icons/pubstructure.gif" alt="Public structure" title="Public structure" /></td><td><a href="4b1fe891-bd41-be13-cc30-93c2e582ea64.htm">ScoreDocComparator_Fields</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Expert: Compares two ScoreDoc objects for sorting.
            
            <p />Created: Feb 3, 2004 9:00:16 AM 
            
            </div></td></tr></table></div><h1 class="heading"><span onclick="ExpandCollapse(interfaceToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(interfaceToggle, event)" tabindex="0"><img id="interfaceToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Interfaces</span></h1><div id="interfaceSection" class="section" name="collapseableSection" style=""><table id="typeList" class="members" frame="lhs" cellpadding="2"><col width="10%" /><tr><th class="iconColumn">
           
       </th><th class="nameColumn">Interface</th><th class="descriptionColumn">Description</th></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="164e93c2-db13-2a3d-b1d9-5513d0bdebe9.htm">ByteParser</a></td><td><div class="summary">Interface to parse bytes from document fields.</div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="8356d143-2590-449d-2c75-cb93ca597f72.htm">DoubleParser</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary">Interface to parse doubles from document fields.</div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="71e21d9c-ba20-1515-c229-6b69b5eb3020.htm">FieldCache</a></td><td /></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="9ef41eac-5af0-e6ff-3728-e233e9e157f0.htm">FloatParser</a></td><td><div class="summary">Interface to parse floats from document fields.</div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="4df569c0-6904-d6d6-be1b-b75ab400be45.htm">IntParser</a></td><td><div class="summary">Interface to parse ints from document fields.</div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="d2434a9e-d6ae-0770-6a0e-995f8eea1e5d.htm">LongParser</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary">Interface to parse long from document fields.</div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="d9e5a178-4c0e-d6a8-168b-280d9d118a4a.htm">Parser</a></td><td><div class="summary"> Marker interface as super-interface to all parsers. It
            is used to specify a custom parser to {@link
            SortField#SortField(String, FieldCache.Parser)}.
            </div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="19d25770-18b7-2b10-1b10-6ae532280e4b.htm">ScoreDocComparator</a></td><td /></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="70bd0e32-fd29-d563-317f-ceab17905df5.htm">Searchable</a></td><td><div class="summary"> The interface for search implementations.
            
            <p />
            Searchable is the abstract network protocol for searching. Implementations
            provide search over a single index, over multiple indices, and over indices
            on remote servers.
            
            <p />
            Queries, filters and sort criteria are designed to be compact so that they
            may be efficiently passed to a remote index, with only the top-scoring hits
            being returned, rather than every matching hit.
            
            <b>NOTE:</b> this interface is kept public for convenience. Since it is not
            expected to be implemented directly, it may be changed unexpectedly between
            releases.
            </div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="121dd00b-645f-ac34-9383-49ddaa43cce7.htm">ShortParser</a></td><td><div class="summary">Interface to parse shorts from document fields.</div></td></tr><tr data="interface; public"><td><img src="../icons/pubinterface.gif" alt="Public interface" title="Public interface" /></td><td><a href="2120bebb-0f21-3163-5a37-552fc76a87fe.htm">SortComparatorSource</a></td><td> <font color="red"><b>Obsolete. </b></font><div class="summary"> Expert: returns a comparator for sorting ScoreDocs.
            
            <p />
            Created: Apr 21, 2004 3:49:28 PM
            
            This class will be used as part of a key to a FieldCache value. You must
            implement hashCode and equals to avoid an explosion in RAM usage if you use
            instances that are not the same instance. If you are searching using the
            Remote contrib, the same instance of this class on the client will be a new
            instance on every call to the server, so hashCode/equals is very important in
            that situation.
            
            </div></td></tr></table></div></div><div id="footer"><div class="footerLine"><img width="100%" height="3px" src="../icons/footer.gif" alt="Footer image" title="Footer image" /></div><A NAME="feedback"></A><span id="fb" class="feedbackcss"></span></div></div></body></html>
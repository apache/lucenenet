<html dir="LTR">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=Windows-1252" />
    <meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" />
    <title>Lucene.Net.Util</title>
    <xml>
    </xml>
    <link rel="stylesheet" type="text/css" href="MSDN.css" />
  </head>
  <body id="bodyID" class="dtBODY">
    <div id="nsbanner">
      <div id="bannerrow1">
        <table class="bannerparthead" cellspacing="0">
          <tr id="hdr">
            <td class="runninghead">Apache Lucene.Net 2.4.0 Class Library API</td>
            <td class="product">
            </td>
          </tr>
        </table>
      </div>
      <div id="TitleRow">
        <h1 class="dtH1">Lucene.Net.Util Namespace</h1>
      </div>
    </div>
    <div id="nstext">
      <p>
        <a href="Lucene.Net.UtilHierarchy.html">Namespace hierarchy</a>
      </p>
      <h3 class="dtH3">Classes</h3>
      <div class="tablediv">
        <table class="dtTABLE" cellspacing="0">
          <tr valign="top">
            <th width="50%">Class</th>
            <th width="50%">Description</th>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.ArrayUtil.html">ArrayUtil</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.BitUtil.html">BitUtil</a>
            </td>
            <td width="50%"> A variety of high efficiencly bit twiddling routines. (from org.apache.solr.util rev 555343) </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.BitVector.html">BitVector</a>
            </td>
            <td width="50%">Optimized implementation of a vector of bits. This is more-or-less like java.util.BitSet, but also includes the following: <ul>
            <li>a count() method, which efficiently computes the number of one bits;</li>
            <li>optimized read from and write to disk;</li>
            <li>inlinable get() method;</li>
            <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
            </ul>
            </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.CloseableThreadLocal.html">CloseableThreadLocal</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.Constants.html">Constants</a>
            </td>
            <td width="50%"> Some useful constants. </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.DocIdBitSet.html">DocIdBitSet</a>
            </td>
            <td width="50%">Simple DocIdSet and DocIdSetIterator backed by a BitArray</td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a>
            </td>
            <td width="50%"> An "open" BitSet implementation that allows direct access to the array of words storing the bits. <p></p> Unlike java.util.bitset, the fact that bits are packed into an array of longs is part of the interface. This allows efficient implementation of other algorithms by someone other than the author. It also allows one to efficiently implement alternate serialization or interchange formats. <p></p>
            <pre class="code">OpenBitSet</pre> is faster than <pre class="code">java.util.BitSet</pre> in most operations and *much* faster at calculating cardinality of sets and results of set operations. It can also handle sets of larger cardinality (up to 64 * 2**32-1) <p></p> The goals of <pre class="code">OpenBitSet</pre> are the fastest implementation possible, and maximum code reuse. Extra safety and encapsulation may always be built on top, but if that's built in, the cost can never be removed (and hence people re-implement their own version in order to get better performance). If you want a "safe", totally encapsulated (and slower and limited) BitSet class, use <pre class="code">java.util.BitSet</pre>. <p></p>
            <h3>Performance Results</h3>
            </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.OpenBitSetDISI.html">OpenBitSetDISI</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.OpenBitSetIterator.html">OpenBitSetIterator</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.Parameter.html">Parameter</a>
            </td>
            <td width="50%"> A serializable Enum class.</td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.PriorityQueue.html">PriorityQueue</a>
            </td>
            <td width="50%">A PriorityQueue maintains a partial ordering of its elements such that the least element can always be found in constant time. Put()'s and pop()'s require log(size) time. </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.ScorerDocQueue.html">ScorerDocQueue</a>
            </td>
            <td width="50%">A ScorerDocQueue maintains a partial ordering of its Scorers such that the least Scorer can always be found in constant time. Put()'s and pop()'s require log(size) time. The ordering is by Scorer.doc(). </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.SmallFloat.html">SmallFloat</a>
            </td>
            <td width="50%"> Floating point numbers smaller than 32 bits. </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.SortedVIntList.html">SortedVIntList</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.StringHelper.html">StringHelper</a>
            </td>
            <td width="50%"> Methods for manipulating strings. </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.ToStringUtils.html">ToStringUtils</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.UnicodeUtil.html">UnicodeUtil</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.UnicodeUtil.UTF16Result.html">UnicodeUtil.UTF16Result</a>
            </td>
            <td width="50%"> </td>
          </tr>
          <tr valign="top">
            <td width="50%">
              <a href="Lucene.Net.Util.UnicodeUtil.UTF8Result.html">UnicodeUtil.UTF8Result</a>
            </td>
            <td width="50%"> </td>
          </tr>
        </table>
      </div>
    </div>
  </body>
</html>
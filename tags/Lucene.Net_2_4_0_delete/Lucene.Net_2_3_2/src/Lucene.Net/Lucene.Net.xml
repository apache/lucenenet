<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.VerifyingLockFactory" -->
        <member name="T:Lucene.Net.Store.LockFactory">
            <summary> <p>Base class for Locking implementation.  {@link Directory} uses
            instances of this class to implement locking.</p>
            
            <p>Note that there are some useful tools to verify that
            your LockFactory is working correctly: {@link
            VerifyingLockFactory}, {@link LockStressTest}, {@link
            LockVerifyServer}.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockVerifyServer">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.LockStressTest">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.SetLockPrefix(System.String)">
            <summary> Set the prefix in use for all locks created in this
            LockFactory.  This is normally called once, when a
            Directory gets this LockFactory instance.  However, you
            can also call this (after this instance is assigned to
            a Directory) to override the prefix in use.  This
            is helpful if you're running Lucene on machines that
            have different mount points for the same shared
            directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.GetLockPrefix">
            <summary> Get the prefix in use for all locks created in this LockFactory.</summary>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.MakeLock(System.String)">
            <summary> Return a new Lock instance identified by lockName.</summary>
            <param name="lockName">name of the lock to be created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.ClearLock(System.String)">
            <summary> Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use.
            </summary>
            <param name="lockName">name of the lock to be cleared.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.VerifyingLockFactory.#ctor(System.Byte,Lucene.Net.Store.LockFactory,System.String,System.Int32)">
            <param name="id">should be a unique id across all clients
            </param>
            <param name="lf">the LockFactory that we are testing
            </param>
            <param name="host">host or IP where {@link LockVerifyServer}
            is running
            </param>
            <param name="port">the port {@link LockVerifyServer} is
            listening on
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Lock" -->
        <member name="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER">
            <summary>Pass this value to {@link #Obtain(long)} to try
            forever to obtain the lock. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL">
            <summary>How long {@link #Obtain(long)} waits, in milliseconds,
            in between attempts to acquire the lock. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>Attempts to obtain exclusive access and immediately return
            upon success or failure.
            </summary>
            <returns> true iff exclusive access is obtained
            </returns>
        </member>
        <member name="F:Lucene.Net.Store.Lock.failureReason">
            <summary> If a lock obtain called, this failureReason may be set
            with the "root cause" Exception as to why the lock was
            not obtained.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>Attempts to obtain an exclusive lock within amount of
            time given. Polls once per {@link #LOCK_POLL_INTERVAL}
            (currently 1000) milliseconds until lockWaitTimeout is
            passed.
            </summary>
            <param name="lockWaitTimeout">length of time to wait in
            milliseconds or {@link
            #LOCK_OBTAIN_WAIT_FOREVER} to retry forever
            </param>
            <returns> true if lock was obtained
            </returns>
            <throws>  LockObtainFailedException if lock wait times out </throws>
            <throws>  IllegalArgumentException if lockWaitTimeout is </throws>
            <summary>         out of bounds
            </summary>
            <throws>  IOException if obtain() throws IOException </throws>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Release">
            <summary>Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.IsLocked">
            <summary>Returns true if the resource is currently locked.  Note that one must
            still call {@link #Obtain()} before using the resource. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With">
            <summary>Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>Constructs an executor that will grab the named lock. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.DoBody">
            <summary>Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.Run">
            <summary>Calls {@link #doBody} while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            {@link #doBody} exits.
            </summary>
            <throws>  LockObtainFailedException if lock could not </throws>
            <summary> be obtained
            </summary>
            <throws>  IOException if {@link Lock#obtain} throws IOException </throws>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
            <summary> A memory-resident {@link IndexInput} implementation.
            
            </summary>
            <version>  $Id: RAMInputStream.java 598693 2007-11-27 17:01:21Z mikemccand $
            </version>
        </member>
        <member name="T:Lucene.Net.Store.IndexInput">
            <summary>Abstract base class for input from a file in a {@link Directory}.  A
            random-access input stream.  Used for all Lucene index input operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadByte">
            <summary>Reads and returns a single byte.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteByte(System.Byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a specified number of bytes into an array at the specified offset.</summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>Reads a specified number of bytes into an array at the
            specified offset with control over whether the read
            should be buffered (callers who have their own buffer
            should pass in "false" for useBuffer).  Currently only
            {@link BufferedIndexInput} respects this parameter.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
            <param name="useBuffer">set to false if the caller will handle
            buffering.
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadInt">
            <summary>Reads four bytes and returns an int.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteInt(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadVInt">
            <summary>Reads an int stored in variable-length format.  Reads between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteVInt(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadLong">
            <summary>Reads eight bytes and returns a long.</summary>
            <seealso cref="!:IndexOutput#WriteLong(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadVLong">
            <summary>Reads a long stored in variable-length format.  Reads between one and
            nine bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadString">
            <summary>Reads a string.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteString(System.String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadChars(System.Char[],System.Int32,System.Int32)">
            <summary>Reads UTF-8 encoded characters into an array.</summary>
            <param name="buffer">the array to read characters into
            </param>
            <param name="start">the offset in the array to start storing characters
            </param>
            <param name="length">the number of characters to read
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteChars(System.String,System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.SkipChars(System.Int32)">
            <summary> Expert
            
            Similar to {@link #ReadChars(char[], int, int)} but does not do any conversion operations on the bytes it is reading in.  It still
            has to invoke {@link #ReadByte()} just as {@link #ReadChars(char[], int, int)} does, but it does not need a buffer to store anything
            and it does not have to do any of the bitwise operations, since we don't actually care what is in the byte except to determine
            how many more bytes to read
            </summary>
            <param name="length">The number of chars to read
            </param>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Close">
            <summary>Closes the stream to futher operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            <summary>Returns the current position in this file, where the next read will
            occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next read will occur.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.IndexInput.Clone" -->
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>Base class for span-based queries. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Query" -->
        <member name="M:Lucene.Net.Search.Query.SetBoost(System.Single)">
            <summary>Sets the boost for this query clause to <code>b</code>.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <code>b</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.GetBoost">
            <summary>Gets the boost for this clause.  Documents matching
            this clause will (in addition to the normal weightings) have their score
            multiplied by <code>b</code>.   The boost is 1.0 by default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.ToString(System.String)" -->
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>Prints a query to a string. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.Searcher)" -->
        <member name="M:Lucene.Net.Search.Query.Weight(Lucene.Net.Search.Searcher)">
            <summary>Expert: Constructs and initializes a Weight for a top-level query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Expert: called to re-write queries into primitive queries. For example,
            a PrefixQuery will be rewritten into a BooleanQuery that consists
            of TermQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Combine(Lucene.Net.Search.Query[])">
            <summary>Expert: called when re-writing queries under MultiSearcher.
            
            Create a single query suitable for use by all subsearchers (in 1-1
            correspondence with queries). This is an optimization of the OR of
            all queries. We handle the common optimization cases of equal
            queries and overlapping clauses of boolean OR queries (as generated
            by MultiTermQuery.rewrite() and RangeQuery.rewrite()).
            Be careful overriding this method as queries[0] determines which
            method will be called and is not necessarily of the same type as
            the other queries.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Hashtable)">
            <summary> Expert: adds all terms occuring in this query to the terms set. Only
            works if this query is in its {@link #rewrite rewritten} form.
            
            </summary>
            <throws>  UnsupportedOperationException if this query is not yet rewritten </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.MergeBooleanQueries(Lucene.Net.Search.Query[])" -->
        <member name="M:Lucene.Net.Search.Query.GetSimilarity(Lucene.Net.Search.Searcher)">
            <summary>Expert: Returns the Similarity implementation to be used for this query.
            Subclasses may override this method to specify their own Similarity
            implementation, perhaps one that delegates through that of the Searcher.
            By default the Searcher's Similarity implementation is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>Returns a clone of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.IndexReader)">
            <summary>Expert: Returns the matches for this query in an index.  Used internally
            to search for spans. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetField">
            <summary>Returns the name of the field matched by this query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:Query#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>Construct a SpanNearQuery.  Matches spans matching a span from each
            clause, with up to <code>slop</code> total unmatched positions between
            them.  * When <code>inOrder</code> is true, the spans from each clause
            must be * ordered as in <code>clauses</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetSlop">
            <summary>Return the maximum number of intervening unmatched positions permitted.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.IsInOrder">
            <summary>Return true if matches are required to be in-order.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Sort" -->
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary> Represents sorting by computed relevance. Using this sort criteria returns
            the same results as calling
            {@link Searcher#Search(Query) Searcher#search()}without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary> Sorts by computed relevance. This is the same sort criteria as calling
            {@link Searcher#Search(Query) Searcher#search()}without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String)">
            <summary> Sorts by the terms in <code>field</code> then by index order (document
            number). The type of value in <code>field</code> is determined
            automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String,System.Boolean)">
            <summary> Sorts possibly in reverse by the terms in <code>field</code> then by
            index order (document number). The type of value in <code>field</code> is
            determined automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String[])">
            <summary> Sorts in succession by the terms in each field. The type of value in
            <code>field</code> is determined automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>Sorts by the criteria in the given SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>Sorts in succession by the criteria in each SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String)">
            <summary> Sets the sort to the terms in <code>field</code> then by index order
            (document number).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String,System.Boolean)">
            <summary> Sets the sort to the terms in <code>field</code> possibly in reverse,
            then by index order (document number).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String[])">
            <summary>Sets the sort to the terms in each field in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetSort">
            <summary> Representation of the sort criteria.</summary>
            <returns> Array of SortField objects used in this sort criteria
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.Filter">
            <summary>Abstract base class providing a mechanism to restrict searches to a subset
            of an index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Filter.Bits(Lucene.Net.Index.IndexReader)">
            <summary>Returns a BitSet with true for documents which should be permitted in
            search results, and false for those that should not. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ConstantScoreRangeQuery" -->
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetField">
            <summary>Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetLowerVal">
            <summary>Returns the value of the lower endpoint of this range query, null if open ended </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetUpperVal">
            <summary>Returns the value of the upper endpoint of this range query, null if open ended </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.IncludesLower">
            <summary>Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.IncludesUpper">
            <summary>Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.specialToken">
            <summary> This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.NewToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            case MyParserConstants.ID : return new IDToken();
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedTermVectorMapper">
            <summary> Store a sorted collection of {@link Lucene.Net.Index.TermVectorEntry}s.  Collects all term information
            into a single, SortedSet.
            <br/>
            NOTE: This Mapper ignores all Field information for the Document.  This means that if you are using offset/positions you will not
            know what Fields they correlate with.
            <br/>
            This is not thread-safe  
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorMapper">
            <summary> The TermVectorMapper can be used to map Term Vectors into your own
            structure instead of the parallel array structure used by
            {@link Lucene.Net.Index.IndexReader#GetTermFreqVector(int,String)}.
            <p/>
            It is up to the implementation to make sure it is thread-safe.
            
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.#ctor(System.Boolean,System.Boolean)">
            <summary> </summary>
            <param name="ignoringPositions">true if this mapper should tell Lucene to ignore positions even if they are stored
            </param>
            <param name="ignoringOffsets">similar to ignoringPositions
            </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.SetExpectations(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary> Tell the mapper what to expect in regards to field, number of terms, offset and position storage.
            This method will be called once before retrieving the vector for a field.
            
            This method will be called before {@link #Map(String,int,TermVectorOffsetInfo[],int[])}.
            </summary>
            <param name="field">The field the vector is for
            </param>
            <param name="numTerms">The number of terms that need to be mapped
            </param>
            <param name="storeOffsets">true if the mapper should expect offset information
            </param>
            <param name="storePositions">true if the mapper should expect positions info
            </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.Map(System.String,System.Int32,Lucene.Net.Index.TermVectorOffsetInfo[],System.Int32[])">
            <summary> Map the Term Vector information into your own structure</summary>
            <param name="term">The term to add to the vector
            </param>
            <param name="frequency">The frequency of the term in the document
            </param>
            <param name="offsets">null if the offset is not specified, otherwise the offset into the field of the term
            </param>
            <param name="positions">null if the position is not specified, otherwise the position in the field of the term
            </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.IsIgnoringPositions">
            <summary> Indicate to Lucene that even if there are positions stored, this mapper is not interested in them and they
            can be skipped over.  Derived classes should set this to true if they want to ignore positions.  The default
            is false, meaning positions will be loaded if they are stored.
            </summary>
            <returns> false
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.IsIgnoringOffsets">
            <summary> </summary>
            <seealso cref="!:IsIgnoringPositions() Same principal as &lt;@link #IsIgnoringPositions()&gt;, but applied to offsets.  false by default.">
            </seealso>
            <returns> false
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.SetDocumentNumber(System.Int32)">
            <summary> Passes down the index of the document whose term vector is currently being mapped,
            once for each top level call to a term vector reader.
            <p/>
            Default implementation IGNORES the document number.  Override if your implementation needs the document number.
            <p/> 
            NOTE: Document numbers are internal to Lucene and subject to change depending on indexing operations.
            
            </summary>
            <param name="documentNumber">index of document currently being mapped
            </param>
        </member>
        <member name="F:Lucene.Net.Index.SortedTermVectorMapper.ALL">
            <summary> Stand-in name for the field in {@link TermVectorEntry}.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedTermVectorMapper.#ctor(System.Collections.Generic.IComparer{System.Object})">
            <summary> </summary>
            <param name="comparator">A Comparator for sorting {@link TermVectorEntry}s
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedTermVectorMapper.Map(System.String,System.Int32,Lucene.Net.Index.TermVectorOffsetInfo[],System.Int32[])">
            <summary> </summary>
            <param name="term">The term to map
            </param>
            <param name="frequency">The frequency of the term
            </param>
            <param name="offsets">Offset information, may be null
            </param>
            <param name="positions">Position information, may be null
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedTermVectorMapper.GetTermVectorEntrySet">
            <summary> The TermVectorEntrySet.  A SortedSet of {@link TermVectorEntry} objects.  Sort is by the comparator passed into the constructor.
            <br/>
            This set will be empty until after the mapping process takes place.
            
            </summary>
            <returns> The SortedSet of {@link TermVectorEntry}.
            </returns>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_LOCKLESS">
            <summary>This format adds details used for lockless commits.  It differs
            slightly from the previous format in that file names
            are never re-used (write once).  Instead, each file is
            written to the next generation.  For example,
            segments_1, segments_2, etc.  This allows us to not use
            a commit lock.  See <a
            href="http://lucene.apache.org/java/docs/fileformats.html">file
            formats</a> for details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SINGLE_NORM_FILE">
            <summary>This format adds a "hasSingleNormFile" flag into each segment info.
            See <a href="http://issues.apache.org/jira/browse/LUCENE-756">LUCENE-756</a>
            for details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SHARED_DOC_STORE">
            <summary>This format allows multiple segments to share a single
            vectors and stored fields file. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.version">
            <summary> counts how often the index has been changed by adding or deleting docs.
            starting with the current time in milliseconds forces to create unique version numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.infoStream">
            <summary> If non-null, information about loading segments_N files</summary>
            <seealso cref="!:setInfoStream.">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentGeneration(System.String[])">
            <summary> Get the generation (N) of the current segments_N file
            from a list of files.
            
            </summary>
            <param name="files">-- array of file names to check
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentGeneration(Lucene.Net.Store.Directory)">
            <summary> Get the generation (N) of the current segments_N file
            in the directory.
            
            </summary>
            <param name="directory">-- directory to search for the latest segments_N file
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentFileName(System.String[])">
            <summary> Get the filename of the current segments_N file
            from a list of files.
            
            </summary>
            <param name="files">-- array of file names to check
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentFileName(Lucene.Net.Store.Directory)">
            <summary> Get the filename of the current segments_N file
            in the directory.
            
            </summary>
            <param name="directory">-- directory to search for the latest segments_N file
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentFileName">
            <summary> Get the segments_N filename in use by this segment infos.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GenerationFromSegmentsFileName(System.String)">
            <summary> Parse the generation off the segments file name and
            return it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetNextSegmentFileName">
            <summary> Get the next segments_N filename that will be written.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory,System.String)">
            <summary> Read a particular segmentFileName.  Note that this may
            throw an IOException if a commit is in process.
            
            </summary>
            <param name="directory">-- directory containing the segments file
            </param>
            <param name="segmentFileName">-- segment file to load
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory)">
            <summary> This version of read uses the retry logic (for lock-less
            commits) to find the right segments file to load.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clone">
            <summary> Returns a copy of this instance, also copying each
            SegmentInfo.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetVersion">
            <summary> version number when this SegmentInfos was generated.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ReadCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Current version number from segments file.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetInfoStream(System.IO.StreamWriter)">
            <summary>If non-null, information about retries when loading
            the segments file will be printed to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetDefaultGenFileRetryCount(System.Int32)">
            <summary> Advanced: set how many times to try loading the
            segments.gen file contents to determine current segment
            generation.  This file is only referenced when the
            primary method (listing the directory) fails.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetDefaultGenFileRetryCount">
            <seealso cref="!:setDefaultGenFileRetryCount">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetDefaultGenFileRetryPauseMsec(System.Int32)">
            <summary> Advanced: set how many milliseconds to pause in between
            attempts to load the segments.gen file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetDefaultGenFileRetryPauseMsec">
            <seealso cref="!:setDefaultGenFileRetryPauseMsec">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetDefaultGenLookaheadCount(System.Int32)">
            <summary> Advanced: set how many times to try incrementing the
            gen when loading the segments file.  This only runs if
            the primary (listing directory) and secondary (opening
            segments.gen file) methods fail to find the segments
            file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetDefaultGenLookahedCount">
            <seealso cref="!:setDefaultGenLookaheadCount">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetInfoStream">
            <seealso cref="!:setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Range(System.Int32,System.Int32)">
            <summary> Returns a new SegmentInfos containg the SegmentInfo
            instances in the specified range first (inclusive) to
            last (exclusive), so total number of segments returned
            is last-first.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfos.FindSegmentsFile">
            <summary> Utility class for executing code that needs to do
            something with the current segments file.  This is
            necessary with lock-less commits because from the time
            you locate the current segments file name, until you
            actually open it, read its contents, or check modified
            time, etc., it could have been deleted due to a writer
            commit finishing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)">
            <summary> Subclass must implement this.  The assumption is an
            IOException will be thrown if something goes wrong
            during the processing that could have been caused by
            a writer committing.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileNameFilter">
            <summary> Filename filter that accept filenames and extensions only created by Lucene.
            
            </summary>
            <author>  Daniel Naber / Bernhard Messer
            </author>
            <version>  $rcs = ' $Id: Exp $ ' ;
            </version>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNameFilter.IsCFSFile(System.String)">
            <summary> Returns true if this is a file that would be contained
            in a CFS file.  This function should only be called on
            files that pass the above "accept" (ie, are already
            known to be a Lucene index file).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>Access to the Fieldable Info file that describes document fields and whether or
            not they are indexed. Each segment has a separate Fieldable Info file. Objects
            of this class are thread-safe for multiple readers, but only one thread can
            be adding documents at a time, with no other reader or writer threads
            accessing this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary> Construct a FieldInfos object using the directory and the name of the file
            IndexInput
            </summary>
            <param name="d">The directory to open the IndexInput from
            </param>
            <param name="name">The name of the file to open the IndexInput from in the Directory
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Clone">
            <summary> Returns a deep clone of this FieldInfos instance.</summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(Lucene.Net.Documents.Document)">
            <summary>Adds field info for a Document. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.AddIndexed(System.Collections.ICollection,System.Boolean,System.Boolean,System.Boolean)">
            <summary> Add fields that are indexed. Whether they have termvectors has to be specified.
            
            </summary>
            <param name="names">The names of the fields
            </param>
            <param name="storeTermVectors">Whether the fields store term vectors or not
            </param>
            <param name="storePositionWithTermVector">treu if positions should be stored.
            </param>
            <param name="storeOffsetWithTermVector">true if offsets should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.Collections.ICollection,System.Boolean)">
            <summary> Assumes the fields are not storing term vectors.
            
            </summary>
            <param name="names">The names of the fields
            </param>
            <param name="isIndexed">Whether the fields are indexed or not
            
            </param>
            <seealso cref="!:Add(String, boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean)">
            <summary> Calls 5 parameter add with false for all TermVector parameters.
            
            </summary>
            <param name="name">The name of the Fieldable
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <seealso cref="!:Add(String, boolean, boolean, boolean, boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean)">
            <summary> Calls 5 parameter add with false for term vector positions and offsets.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed"> true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
            <param name="omitNorms">true if the norms for the indexed field should be omitted
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
            <param name="omitNorms">true if the norms for the indexed field should be omitted
            </param>
            <param name="storePayloads">true if payloads should be stored for this field
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldName(System.Int32)">
            <summary> Return the fieldName identified by its number.
            
            </summary>
            <param name="">fieldNumber
            </param>
            <returns> the fieldName or an empty string when the field
            with the given number doesn't exist.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.Int32)">
            <summary> Return the fieldinfo object referenced by the fieldNumber.</summary>
            <param name="fieldNumber">
            </param>
            <returns> the FieldInfo object or null when the given fieldNumber
            doesn't exist.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.PorterStemFilter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenFilter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenStream" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.Next">
            <summary>Returns the next token in the stream, or null at EOS.
            The returned Token is a "full private copy" (not
            re-used across calls to next()) but will be slower
            than calling {@link #Next(Token)} instead.. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStream.Next(Lucene.Net.Analysis.Token)" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.Reset">
            <summary>Resets this stream to the beginning. This is an
            optional operation, so subclasses may or may not
            implement this method. Reset() is not needed for
            the standard indexing process. However, if the Tokens 
            of a TokenStream are intended to be consumed more than 
            once, it is necessary to implement reset(). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Close">
            <summary>Releases resources associated with this stream. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenFilter.input">
            <summary>The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct a token stream filtering the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Close">
            <summary>Close the input TokenStream. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopFieldDocs" -->
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.totalHits">
            <summary>Expert: The total number of hits for the query.</summary>
            <seealso cref="M:Lucene.Net.Search.Hits.Length">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.scoreDocs">
            <summary>Expert: The top hits for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.maxScore">
            <summary>Expert: Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.GetMaxScore">
            <summary>Expert: Returns the maximum score value encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.SetMaxScore(System.Single)">
            <summary>Expert: Sets the maximum score value encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],System.Single)">
            <summary>Expert: Constructs a TopDocs.</summary>
        </member>
        <member name="F:Lucene.Net.Search.TopFieldDocs.fields">
            <summary>The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[],System.Single)">
            <summary>Creates one of these objects.</summary>
            <param name="totalHits"> Total number of hits for the query.
            </param>
            <param name="scoreDocs"> The top hits for the query.
            </param>
            <param name="fields">    The sort criteria used to find the top hits.
            </param>
            <param name="maxScore">  The maximum score encountered.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ReverseOrdFieldSource" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ValueSource" -->
        <member name="M:Lucene.Net.Search.Function.ValueSource.GetValues(Lucene.Net.Index.IndexReader)">
            <summary> Return the DocValues used by the function query.</summary>
            <param name="reader">the IndexReader used to read these values.
            If any caching is involved, that caching would also be IndexReader based.  
            </param>
            <throws>  IOException for any error. </throws>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSource.Description">
            <summary> description of field, used in explain() </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSource.Equals(System.Object)">
            <summary> Needed for possible caching of query results - used by {@link ValueSourceQuery#equals(Object)}.</summary>
            <seealso cref="!:Object.equals(Object)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSource.GetHashCode">
            <summary> Needed for possible caching of query results - used by {@link ValueSourceQuery#hashCode()}.</summary>
            <seealso cref="!:Object.hashCode()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.ReverseOrdFieldSource.#ctor(System.String)">
            <summary> Contructor for a certain field.</summary>
            <param name="field">field whose values reverse order is used.  
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.DocValues" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.FloatVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.IntVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.LongVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.DoubleVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.StrVal(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Function.DocValues.ToString(System.Int32)">
            <summary> Return a string representation of a doc value, as reuired for Explanations.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.DocValues.Explain(System.Int32)">
            <summary> Explain the scoring value for the input doc.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.GetInnerArray" -->
        <member name="M:Lucene.Net.Search.Function.DocValues.GetMinValue">
            <summary> Optional op.
            Returns the minimum of all values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.DocValues.GetMaxValue">
            <summary> Optional op.
            Returns the maximum of all values. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.DocValues.GetAverageValue">
            <summary> Returns the average of all values. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.OrdFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.OrdFieldSource.#ctor(System.String)">
            <summary> Contructor for a certain field.</summary>
            <param name="field">field whose values order is used.  
            </param>
        </member>
        <member name="T:Lucene.Net.Index.TermFreqVector">
            <summary>Provides access to stored term vector of 
            a document field.  The vector consists of the name of the field, an array of the terms tha occur in the field of the
            {@link Lucene.Net.Documents.Document} and a parallel array of frequencies.  Thus, getTermFrequencies()[5] corresponds with the
            frequency of getTerms()[5], assuming there are at least 5 terms in the Document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetField">
            <summary> The {@link Lucene.Net.Documents.Fieldable} name. </summary>
            <returns> The name of the field this vector is associated with.
            
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.Size">
            <returns> The number of terms in the term vector.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTerms">
            <returns> An Array of term texts in ascending order.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTermFrequencies">
            <summary>Array of term frequencies. Locations of the array correspond one to one
            to the terms in the array obtained from <code>getTerms</code>
            method. Each location in the array contains the number of times this
            term occurs in the document or the document field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexOf(System.String)">
            <summary>Return an index in the term numbers array returned from
            <code>getTerms</code> at which the term with the specified
            <code>term</code> appears. If this term does not appear in the array,
            return -1.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexesOf(System.String[],System.Int32,System.Int32)">
            <summary>Just like <code>indexOf(int)</code> but searches for a number of terms
            at the same time. Returns an array that has the same size as the number
            of terms searched for, each slot containing the result of searching for
            that term number.
            
            </summary>
            <param name="terms">array containing terms to look for
            </param>
            <param name="start">index in the array where the list of terms starts
            </param>
            <param name="len">the number of terms in the list
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermVector.GetField">
            <summary> </summary>
            <returns> The number of the field this vector is associated with
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.LogByteSizeMergePolicy">
            <summary>This is a {@link LogMergePolicy} that measures size of a
            segment as the total byte size of the segment's files. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.LogMergePolicy" -->
        <member name="T:Lucene.Net.Index.MergePolicy">
            <summary> <p>Expert: a MergePolicy determines the sequence of
            primitive merge operations to be used for overall merge
            and optimize operations.</p>
            
            <p>Whenever the segments in an index have been altered by
            {@link IndexWriter}, either the addition of a newly
            flushed segment, addition of many segments from
            addIndexes* calls, or a previous merge that may now need
            to cascade, {@link IndexWriter} invokes {@link
            #findMerges} to give the MergePolicy a chance to pick
            merges that are now required.  This method returns a
            {@link MergeSpecification} instance describing the set of
            merges that should be done, or null if no merges are
            necessary.  When IndexWriter.optimize is called, it calls
            {@link #findMergesForOptimize} and the MergePolicy should
            then return the necessary merges.</p>
            
            <p>Note that the policy can return more than one merge at
            a time.  In this case, if the writer is using {@link
            SerialMergeScheduler}, the merges will be run
            sequentially but if it is using {@link
            ConcurrentMergeScheduler} they will be run concurrently.</p>
            
            <p>The default MergePolicy is {@link
            LogByteSizeMergePolicy}.</p>
            <p><b>NOTE:</b> This API is new and still experimental
            (subject to change suddenly in the next release)</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter)">
            <summary> Determine what set of merge operations are now
            necessary on the index.  The IndexWriter calls this
            whenever there is a change to the segments.  This call
            is always synchronized on the IndexWriter instance so
            only one thread at a time will call this method.
            
            </summary>
            <param name="segmentInfos">the total set of segments in the index
            </param>
            <param name="writer">IndexWriter instance
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMergesForOptimize(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter,System.Int32,System.Collections.Hashtable)">
            <summary> Determine what set of merge operations are necessary in
            order to optimize the index.  The IndexWriter calls
            this when its optimize() method is called.  This call
            is always synchronized on the IndexWriter instance so
            only one thread at a time will call this method.
            
            </summary>
            <param name="segmentInfos">the total set of segments in the index
            </param>
            <param name="writer">IndexWriter instance
            </param>
            <param name="maxSegmentCount">requested maximum number of
            segments in the index (currently this is always 1)
            </param>
            <param name="segmentsToOptimize">contains the specific
            SegmentInfo instances that must be merged away.  This
            may be a subset of all SegmentInfos.
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Close">
            <summary> Release all resources for the policy.</summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundFile(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentInfo)">
            <summary> Returns true if a newly flushed (not from merge)
            segment should use the compound file format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundDocStore(Lucene.Net.Index.SegmentInfos)">
            <summary> Returns true if the doc store files should use the
            compound file format.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.OneMerge">
            <summary>OneMerge provides the information necessary to perform
            an individual primitive merge operation, resulting in
            a single new segment.  The merge spec includes the
            subset of segments to be merged as well as whether the
            new segment should use the compound file format. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SetException(System.Exception)">
            <summary>Record that an exception occurred while executing
            this merge 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetException">
            <summary>Retrieve previous exception set by {@link
            #setException}. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.Abort">
            <summary>Mark this merge as aborted.  If this is called
            before the merge is committed then the merge will
            not be committed. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.IsAborted">
            <summary>Returns true if this merge was aborted. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeSpecification">
            <summary> A MergeSpecification instance provides the information
            necessary to perform multiple merges.  It simply
            contains a list of {@link OneMerge} instances.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.MergeSpecification.merges">
            <summary> The subset of segments to be included in the primitive merge.</summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeException">
            <summary>Exception thrown if there are any problems while
            executing a merge. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.LEVEL_LOG_SPAN">
            <summary>Defines the allowed range of log(size) for each
            level.  A level is computed by taking the max segment
            log size, minuse LEVEL_LOG_SPAN, and finding all
            segments falling within that range. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            <summary>Default merge factor, which is how many segments are
            merged at a time 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MAX_MERGE_DOCS">
            <summary>Default maximum segment size.  A segment of this size</summary>
            <seealso cref="!:setMaxMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetMergeFactor">
            <summary><p>Returns the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.</p> 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LogMergePolicy.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.LogMergePolicy.SetUseCompoundFile(System.Boolean)">
            <summary>Sets whether compound file format should be used for
            newly flushed and newly merged segments. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetUseCompoundFile">
            <summary>Returns true if newly flushed and newly merge segments</summary>
            <seealso cref="!:">
            #setUseCompoundFile 
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SetUseCompoundDocStore(System.Boolean)">
            <summary>Sets whether compound file format should be used for
            newly flushed and newly merged doc store
            segment files (term vectors and stored fields). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetUseCompoundDocStore">
            <summary>Returns true if newly flushed and newly merge doc
            store segment files (term vectors and stored fields)
            </summary>
            <seealso cref="!:">
            #setUseCompoundDocStore 
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.IsOptimized(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfo)">
            <summary>Returns true if this single nfo is optimized (has no
            pending norms or deletes, is in the same dir as the
            writer, and matches the current compound file setting 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMergesForOptimize(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter,System.Int32,System.Collections.Hashtable)">
            <summary>Returns the merges necessary to optimize the index.
            This merge policy defines "optimized" to mean only one
            segment in the index, where that segment has no
            deletions pending nor separate norms, and it is in
            compound file format if the current useCompoundFile
            setting is true.  This method returns multiple merges
            (mergeFactor at a time) so the {@link MergeScheduler}
            in use may make use of concurrency. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMerges(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter)">
            <summary>Checks if any merges are now necessary and returns a
            {@link MergePolicy.MergeSpecification} if so.  A merge
            is necessary when there are more than {@link
            #setMergeFactor} segments at a given level.  When
            multiple levels have too many segments, this method
            will return multiple merges, allowing the {@link
            MergeScheduler} to use concurrency. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SetMaxMergeDocs(System.Int32)">
            <summary><p>Determines the largest segment (measured by
            document count) that may be merged with other segments.
            Small values (e.g., less than 10,000) are best for
            interactive indexing, as this limits the length of
            pauses while indexing to a few seconds.  Larger values
            are best for batched indexing and speedier
            searches.</p>
            
            <p>The default value is {@link Integer#MAX_VALUE}.</p>
            
            <p>The default merge policy ({@link
            LogByteSizeMergePolicy}) also allows you to set this
            limit by net size (in MB) of the segment, using {@link
            LogByteSizeMergePolicy#setMaxMergeMB}.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetMaxMergeDocs">
            <summary>Returns the largest segment (measured by document
            count) that may be merged with other segments.
            </summary>
            <seealso cref="!:setMaxMergeDocs">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB">
            <seealso cref="!:setMinMergeMB">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB">
            <summary>Default maximum segment size.  A segment of this size</summary>
            <seealso cref="M:Lucene.Net.Index.LogByteSizeMergePolicy.SetMaxMergeMB(System.Double)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.SetMaxMergeMB(System.Double)">
            <summary><p>Determines the largest segment (measured by total
            byte size of the segment's files, in MB) that may be
            merged with other segments.  Small values (e.g., less
            than 50 MB) are best for interactive indexing, as this
            limits the length of pauses while indexing to a few
            seconds.  Larger values are best for batched indexing
            and speedier searches.</p>
            
            <p>Note that {@link #setMaxMergeDocs} is also
            used to check whether a segment is too large for
            merging (it's either or).</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.GetMaxMergeMB">
            <summary>Returns the largest segment (meaured by total byte
            size of the segment's files, in MB) that may be merged
            with other segments.
            </summary>
            <seealso cref="!:setMaxMergeMB">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.SetMinMergeMB(System.Double)">
            <summary>Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.GetMinMergeMB">
            <summary>Get the minimum size for a segment to remain
            un-merged.
            </summary>
            <seealso cref="!:setMinMergeMB *">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardFilter">
            <summary>Normalizes tokens extracted with {@link StandardTokenizer}. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct filtering <i>in</i>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Standard.StandardFilter.Next(Lucene.Net.Analysis.Token)" -->
        <member name="T:Lucene.Net.Util.Parameter">
            <summary> A serializable Enum class.</summary>
        </member>
        <member name="M:Lucene.Net.Util.Parameter.ReadResolve">
            <summary> Resolves the deserialized instance to the local reference for accurate
            equals() and == comparisons.
            
            </summary>
            <returns> a reference to Parameter as resolved in the local VM
            </returns>
            <throws>  ObjectStreamException </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.MMapDirectory" -->
        <member name="T:Lucene.Net.Store.FSDirectory">
            <summary> Straightforward implementation of {@link Directory} as a directory of files.
            Locking implementation is by default the {@link SimpleFSLockFactory}, but
            can be changed either by passing in a {@link LockFactory} instance to
            <code>getDirectory</code>, or specifying the LockFactory class by setting
            <code>Lucene.Net.Store.FSDirectoryLockFactoryClass</code> Java system
            property, or by calling {@link #setLockFactory} after creating
            the Directory.
            <p>Directories are cached, so that, for a given canonical
            path, the same FSDirectory instance will always be
            returned by <code>getDirectory</code>.  This permits
            synchronization on directories.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
            <author>  Doug Cutting
            </author>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Directory" -->
        <member name="F:Lucene.Net.Store.Directory.lockFactory">
            <summary>Holds the LockFactory instance (implements locking for
            this Directory instance). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.List">
            <summary>Returns an array of strings, one for each file in the
            directory.  This method may return null (for example for
            {@link FSDirectory} if the underlying directory doesn't
            exist in the filesystem or there are permissions
            problems).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.
            If a file already exists with the new name, then it is replaced.
            This replacement is not guaranteed to be atomic.
            </summary>
            <deprecated> 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>Returns the length of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String,System.Int32)">
            <summary>Returns a stream reading an existing file, with the
            specified read buffer size.  The particular Directory
            implementation may ignore the buffer size.  Currently
            the only Directory implementations that respect this
            parameter are {@link FSDirectory} and {@link
            Lucene.Net.Index.CompoundFileReader}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ClearLock(System.String)">
            <summary> Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use.
            </summary>
            <param name="name">name of the lock to be cleared.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Close">
            <summary>Closes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)">
            <summary> Set the LockFactory that this Directory instance should
            use for its locking implementation.  Each * instance of
            LockFactory should only be used for one directory (ie,
            do not share a single instance across multiple
            Directories).
            
            </summary>
            <param name="lockFactory">instance of {@link LockFactory}.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.GetLockFactory">
            <summary> Get the LockFactory that this Directory instance is
            using for its locking implementation.  Note that this
            may be null for Directory implementations that provide
            their own locking implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.GetLockID">
            <summary> Return a string identifier that uniquely differentiates
            this Directory instance from other Directory instances.
            This ID should be the same if two Directory instances
            (even in different JVMs and/or on different machines)
            are considered "the same index".  This is how locking
            "scopes" to the right index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Copy(Lucene.Net.Store.Directory,Lucene.Net.Store.Directory,System.Boolean)">
            <summary> Copy contents of a directory src to a directory dest.
            If a file in src already exists in dest then the
            one in dest will be blindly overwritten.
            
            </summary>
            <param name="src">source directory
            </param>
            <param name="dest">destination directory
            </param>
            <param name="closeDirSrc">if <code>true</code>, call {@link #close()} method on source directory
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.DIRECTORIES">
            <summary>This cache of directories ensures that there is a unique Directory
            instance per path, so that synchronization on the Directory can be used to
            synchronize access between readers and writers.  We use
            refcounts to ensure when the last use of an FSDirectory
            instance for a given canonical path is closed, we remove the
            instance from the cache.  See LUCENE-776
            for some relevant discussion.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.SetDisableLocks(System.Boolean)">
            <summary> Set whether Lucene's use of lock files is disabled. By default, 
            lock files are enabled. They should only be disabled if the index
            is on a read-only medium like a CD-ROM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDisableLocks">
            <summary> Returns whether Lucene's use of lock files is disabled.</summary>
            <returns> true if locks are disabled, false if locks are enabled.
            </returns>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.LOCK_DIR">
            <summary> Directory specified by <code>Lucene.Net.lockDir</code>
            or <code>java.io.tmpdir</code> system property.
            </summary>
            <deprecated> As of 2.1, <code>LOCK_DIR</code> is unused
            because the write.lock is now stored by default in the
            index directory.  If you really want to store locks
            elsewhere you can create your own {@link
            SimpleFSLockFactory} (or {@link NativeFSLockFactory},
            etc.) passing in your preferred lock directory.  Then,
            pass this <code>LockFactory</code> instance to one of
            the <code>getDirectory</code> methods that take a
            <code>lockFactory</code> (for example, {@link #GetDirectory(String, LockFactory)}).
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.IMPL">
            <summary>The default class which implements filesystem-based directories. </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.buffer">
            <summary>A buffer optionally used in renameTo method </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="path">the path to the directory.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String,Lucene.Net.Store.LockFactory)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="path">the path to the directory.
            </param>
            <param name="lockFactory">instance of {@link LockFactory} providing the
            locking implementation.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="file">the path to the directory.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo,Lucene.Net.Store.LockFactory)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="file">the path to the directory.
            </param>
            <param name="lockFactory">instance of {@link LockFactory} providing the
            locking implementation.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String,System.Boolean)">
            <summary>Returns the directory instance for the named location.
            
            </summary>
            <deprecated> Use IndexWriter's create flag, instead, to
            create a new index.
            
            </deprecated>
            <param name="path">the path to the directory.
            </param>
            <param name="create">if true, create, or erase any existing contents.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo,System.Boolean)">
            <summary>Returns the directory instance for the named location.
            
            </summary>
            <deprecated> Use IndexWriter's create flag, instead, to
            create a new index.
            
            </deprecated>
            <param name="file">the path to the directory.
            </param>
            <param name="create">if true, create, or erase any existing contents.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.List">
            <summary>Returns an array of strings, one for each Lucene index file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.IO.FileInfo,System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory. 
            Warning: This is not atomic.
            </summary>
            <deprecated> 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.HEX_DIGITS">
            <summary> So we can do some byte-to-hexchar conversion below</summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Close">
            <summary>Closes the store to future operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>For debug output. </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexInput">
            <summary>Base implementation class for buffered {@link IndexInput}. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE">
            <summary>Default buffer size </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.#ctor(System.Int32)">
            <summary>Inits BufferedIndexInput with a specific bufferSize </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SetBufferSize(System.Int32)">
            <summary>Change the buffer size used by this IndexInput </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.GetBufferSize">
            <seealso cref="!:setBufferSize">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current position
            in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="length">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where the
            next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>IndexInput methods </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexInput.IsFDValid">
            <summary>Method used for testing. Returns true if the underlying
            file descriptor is valid.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexOutput">
            <summary>Base implementation class for buffered {@link IndexOutput}. </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexOutput">
            <summary>Abstract base class for output to a file in a Directory.  A random-access
            output stream.  Used for all Lucene index output operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.IndexInput">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadByte">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="offset">the offset in the byte array
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteInt(System.Int32)">
            <summary>Writes an int as four bytes.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadInt">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteVInt(System.Int32)">
            <summary>Writes an int in a variable-length format.  Writes between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadVInt">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteLong(System.Int64)">
            <summary>Writes a long as eight bytes.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadLong">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteVLong(System.Int64)">
            <summary>Writes an long in a variable-length format.  Writes between one and five
            bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadVLong">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteString(System.String)">
            <summary>Writes a string.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadString">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteChars(System.String,System.Int32,System.Int32)">
            <summary>Writes a sequence of UTF-8 encoded characters from a string.</summary>
            <param name="s">the source of the characters
            </param>
            <param name="start">the first character in the sequence
            </param>
            <param name="length">the number of characters in the sequence
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadChars(System.Char[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteChars(System.Char[],System.Int32,System.Int32)">
            <summary>Writes a sequence of UTF-8 encoded characters from a char[].</summary>
            <param name="s">the source of the characters
            </param>
            <param name="start">the first character in the sequence
            </param>
            <param name="length">the number of characters in the sequence
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadChars(System.Char[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.CopyBytes(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>Copy numBytes bytes from input to ourself. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadByte">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>Expert: implements buffer write.  Writes bytes at the current position in
            the output.
            </summary>
            <param name="b">the bytes to write
            </param>
            <param name="len">the number of bytes to write
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer write.  Writes bytes at the current position in
            the output.
            </summary>
            <param name="b">the bytes to write
            </param>
            <param name="offset">the offset in the byte array
            </param>
            <param name="len">the number of bytes to write
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexOutput.Seek(System.Int64)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexOutput.GetFilePointer">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>output methods: </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Seek(System.Int64)">
            <summary>Random-access methods </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopFieldDocCollector" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopDocCollector" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.HitCollector" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.HitCollector.Collect(System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Search.TopDocCollector.#ctor(System.Int32)">
            <summary>Construct to collect a given number of hits.</summary>
            <param name="numHits">the maximum number of hits to collect
            </param>
        </member>
        <member name="M:Lucene.Net.Search.TopDocCollector.GetTotalHits">
            <summary>The total number of documents that matched this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocCollector.TopDocs">
            <summary>The top-scoring hits. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocCollector.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Search.Sort,System.Int32)">
            <summary>Construct to collect a given number of hits.</summary>
            <param name="reader">the index to be searched
            </param>
            <param name="sort">the sort criteria
            </param>
            <param name="numHits">the maximum number of hits to collect
            </param>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
            <summary>Matches spans near the beginning of a field. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>Construct a SpanFirstQuery matching spans in <code>match</code> whose end
            position is less than or equal to <code>end</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetMatch">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetEnd">
            <summary>Return the maximum end position permitted in a match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>Move to the next match, returning true iff any such exists. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Start">
            <summary>Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.End">
            <summary>Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparator" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparatorSource" -->
        <member name="M:Lucene.Net.Search.SortComparatorSource.NewComparator(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Creates a comparator for the field in the given index.</summary>
            <param name="reader">Index to create comparator for.
            </param>
            <param name="fieldname"> Name of the field to create comparator for.
            </param>
            <returns> Comparator of ScoreDoc objects.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SortComparator.GetComparable(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ScoreDocComparator.Compare(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.ScoreDoc)" -->
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortValue(Lucene.Net.Search.ScoreDoc)">
            <summary> Returns the value used to sort the given document.  The
            object returned must implement the java.io.Serializable
            interface.  This is used by multisearchers to determine how
            to collate results from their searchers.
            </summary>
            <seealso cref="T:Lucene.Net.Search.FieldDoc">
            </seealso>
            <param name="i">Document
            </param>
            <returns> Serializable object
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortType">
            <summary> Returns the type of sort.  Should return <code>SortField.SCORE</code>,
            <code>SortField.DOC</code>, <code>SortField.STRING</code>,
            <code>SortField.INTEGER</code>, <code>SortField.FLOAT</code> or
            <code>SortField.CUSTOM</code>.  It is not valid to return
            <code>SortField.AUTO</code>.
            This is used by multisearchers to determine how to collate results
            from their searchers.
            </summary>
            <returns> One of the constants in SortField.
            </returns>
            <seealso cref="T:Lucene.Net.Search.SortField">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.RemoteCachingWrapperFilter">
            <summary> Provides caching of {@link Filter}s themselves on the remote end of an RMI connection.
            The cache is keyed on Filter's hashCode(), so if it sees the same filter twice
            it will reuse the original version.
            <p/>
            NOTE: This does NOT cache the Filter bits, but rather the Filter itself.
            Thus, this works hand-in-hand with {@link CachingWrapperFilter} to keep both
            file Filter cache and the Filter bits on the remote end, close to the searcher.
            <p/>
            Usage:
            <p/>
            To cache a result you must do something like 
            RemoteCachingWrapperFilter f = new RemoteCachingWrapperFilter(new CachingWrapperFilter(myFilter));
            <p/>
            </summary>
            <author>  Matt Ericson
            </author>
        </member>
        <member name="M:Lucene.Net.Search.RemoteCachingWrapperFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Uses the {@link FilterManager} to keep the cache for a filter on the 
            searcher side of a remote connection.
            </summary>
            <param name="reader">the index reader for the Filter
            </param>
            <returns> the bitset
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.MultiPhraseQuery">
            <summary> MultiPhraseQuery is a generalized version of PhraseQuery, with an added
            method {@link #Add(Term[])}.
            To use this class, to search for the phrase "Microsoft app*" first use
            add(Term) on the term "Microsoft", then find all terms that have "app" as
            prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
            terms) to add them to the query.
            
            </summary>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.SetSlop(System.Int32)">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#SetSlop(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetSlop">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#GetSlop()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>Add a single term at the next position in the phrase.</summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])">
            <summary>Add multiple terms at the next position in the phrase.  Any of the terms
            may match.
            
            </summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)">
            <summary> Allows to specify the relative position of terms within the phrase.
            
            </summary>
            <seealso cref="!:int)">
            </seealso>
            <param name="">terms
            </param>
            <param name="">position
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.GetTermArrays" -->
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Weight" -->
        <member name="M:Lucene.Net.Search.Weight.GetQuery">
            <summary>The query that this concerns. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetValue">
            <summary>The weight for this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.SumOfSquaredWeights">
            <summary>The sum of squared weights of contained query clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single)">
            <summary>Assigns the query normalization factor to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.IndexReader)">
            <summary>Constructs a scorer for this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>An explanation of the score computation for the named document. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Hits" -->
        <member name="M:Lucene.Net.Search.Hits.GetMoreDocs(System.Int32)">
            <summary> Tries to add new documents to hitDocs.
            Ensures that the hit numbered <code>min</code> has been retrieved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Length">
            <summary>Returns the total number of hits available in this set. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Hits.Doc(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Hits.Score(System.Int32)">
            <summary>Returns the score for the n<sup>th</sup> document in this set. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Id(System.Int32)">
            <summary>Returns the id for the n<sup>th</sup> document in this set.
            Note that ids may change when the index changes, so you cannot
            rely on the id to be stable.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Iterator">
            <summary> Returns a {@link HitIterator} to navigate the Hits.  Each item returned
            from {@link Iterator#next()} is a {@link Hit}.
            <p>
            <b>Caution:</b> Iterate only over the hits needed.  Iterating over all
            hits is generally not desirable and may be the source of
            performance issues. If you need to iterate over many or all hits, consider
            using a search method that takes a {@link HitCollector}.
            </p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FloatFieldSource" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FieldCacheSource" -->
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.#ctor(System.String)">
            <summary> Create a cached field source for the input field.  </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.GetCachedFieldValues(Lucene.Net.Search.FieldCache,System.String,Lucene.Net.Index.IndexReader)">
            <summary> Return cached DocValues for input field and reader.</summary>
            <param name="cache">FieldCache so that values of a field are loaded once per reader (RAM allowing)
            </param>
            <param name="field">Field for which values are required.
            </param>
            <seealso cref="T:Lucene.Net.Search.Function.ValueSource">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.CachedFieldSourceEquals(Lucene.Net.Search.Function.FieldCacheSource)">
            <summary> Check if equals to another {@link FieldCacheSource}, already knowing that cache and field are equal.  </summary>
            <seealso cref="!:Object.equals(java.lang.Object)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.CachedFieldSourceHashCode">
            <summary> Return a hash code of a {@link FieldCacheSource}, without the hash-codes of the field 
            and the cache (those are taken care of elsewhere).  
            </summary>
            <seealso cref="!:Object.hashCode()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FloatFieldSource.#ctor(System.String)">
            <summary> Create a cached float field source with default string-to-float parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.FloatFieldSource.#ctor(System.String,Lucene.Net.Search.FloatParser)">
            <summary> Create a cached float field source with a specific string-to-float parser. </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery">
            <summary> A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
            score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
            This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
            combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
            not the sum of the field scores (as BooleanQuery would give).
            If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
            another gets a higher score than "albino" matching both fields.
            To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
            each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
            The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
            include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
            in the multiple fields.
            </summary>
            <author>  Chuck Williams
            </author>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Single)">
            <summary>Creates a new empty DisjunctionMaxQuery.  Use add() to add the subqueries.</summary>
            <param name="tieBreakerMultiplier">this score of each non-maximum disjunct for a document is multiplied by this weight
            and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
            10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
            word in the lower scored field (i.e., one that is not in any higher scored field.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Collections.ICollection,System.Single)" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(Lucene.Net.Search.Query)">
            <summary>Add a subquery to this disjunction</summary>
            <param name="query">the disjunct added
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.Add(System.Collections.ICollection)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.Iterator" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Optimize our representation and our subqueries representations</summary>
            <param name="reader">the IndexReader we query
            </param>
            <returns> an optimized copy of us (which may not be a copy if there is nothing to optimize) 
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Clone">
            <summary>Create a shallow copy of us -- used in rewriting if necessary</summary>
            <returns> a copy of us (but reuse, don't copy, our subqueries) 
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.ToString(System.String)">
            <summary>Prettyprint us.</summary>
            <param name="field">the field to which we are applied
            </param>
            <returns> a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Equals(System.Object)">
            <summary>Return true iff we represent the same query as o</summary>
            <param name="o">another object
            </param>
            <returns> true iff o is a DisjunctionMaxQuery with the same boost and the same subqueries, in the same order, as us
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.GetHashCode">
            <summary>Compute a hash code for hashing us</summary>
            <returns> the hash code
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.Scorer">
            <summary> Expert: Common scoring functionality for different types of queries.
            
            <p>
            A <code>Scorer</code> either iterates over documents matching a
            query in increasing order of doc Id, or provides an explanation of
            the score for a query for a given document.
            </p>
            <p>
            Document scores are computed using a given <code>Similarity</code>
            implementation.
            </p>
            </summary>
            <seealso cref="!:BooleanQuery.setAllowDocsOutOfOrder">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Constructs a Scorer.</summary>
            <param name="similarity">The <code>Similarity</code> implementation used by this scorer.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetSimilarity">
            <summary>Returns the Similarity implementation used by this scorer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector,System.Int32)">
            <summary>Expert: Collects matching documents in a range.  Hook for optimization.
            Note that {@link #Next()} must be called once before this method is called
            for the first time.
            </summary>
            <param name="hc">The collector to which all matching documents are passed through
            {@link HitCollector#Collect(int, float)}.
            </param>
            <param name="max">Do not score documents past this.
            </param>
            <returns> true if more matching documents may remain.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Next">
            <summary> Advances to the document matching this Scorer with the lowest doc Id
            greater than the current value of {@link #Doc()} (or to the matching
            document with the lowest doc Id if next has never been called on
            this Scorer).
            
            <p>
            When this method is used the {@link #Explain(int)} method should not
            be used.
            </p>
            
            </summary>
            <returns> true iff there is another document matching the query.
            </returns>
            <seealso cref="!:BooleanQuery.setAllowDocsOutOfOrder">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Doc">
            <summary>Returns the current document number matching the query.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} or {@link #SkipTo(int)}
            is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Explain(System.Int32)" -->
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>A simple hash table of document scores within a range. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateField" -->
        <member name="M:Lucene.Net.Documents.DateField.DateToString(System.DateTime)">
            <summary> Converts a Date to a string suitable for indexing.</summary>
            <throws>  SystemException if the date specified in the </throws>
            <summary> method argument is before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.TimeToString(System.Int64)">
            <summary> Converts a millisecond time to a string suitable for indexing.</summary>
            <throws>  SystemException if the time specified in the </throws>
            <summary> method argument is negative, that is, before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToTime(System.String)">
            <summary>Converts a string-encoded date into a millisecond time. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToDate(System.String)">
            <summary>Converts a string-encoded date into a Date object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.LowerCaseTokenizer" -->
        <member name="T:Lucene.Net.Analysis.LetterTokenizer">
            <summary>A LetterTokenizer is a tokenizer that divides text at non-letters.  That's
            to say, it defines tokens as maximal strings of adjacent letters, as defined
            by java.lang.Character.isLetter() predicate.
            Note: this does a decent job for most European languages, but does a terrible
            job for some Asian languages, where words are not separated by spaces. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CharTokenizer">
            <summary>An abstract base class for simple, character-oriented tokenizers.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenizer" -->
        <member name="F:Lucene.Net.Analysis.Tokenizer.input">
            <summary>The text source for this Tokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor">
            <summary>Construct a tokenizer with null input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Close">
            <summary>By default, closes the input Reader. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Reset(System.IO.TextReader)">
            <summary>Expert: Reset the tokenizer to a new reader.  Typically, an
            analyzer (in its reusableTokenStream method) will use
            this to re-use a previously created tokenizer. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.IsTokenChar(System.Char)">
            <summary>Returns true iff a character should be included in a token.  This
            tokenizer generates as tokens adjacent sequences of characters which
            satisfy this predicate.  Characters for which this is false are used to
            define token boundaries and are not included in tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.Normalize(System.Char)">
            <summary>Called on each token character to normalize it before it is added to the
            token.  The default implementation does nothing.  Subclasses may use this
            to, e.g., lowercase tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LetterTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LowerCaseTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.Normalize(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockStressTest" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ParallelMultiSearcher" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiSearcher" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Searcher" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Searchable" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Searchable.Close">
            <summary>Frees resources associated with this Searcher.
            Be careful not to call this method while you are still using objects
            like {@link Hits}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreq(Lucene.Net.Index.Term)">
            <summary>Expert: Returns the number of documents containing <code>term</code>.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreqs(Lucene.Net.Index.Term[])">
            <summary>Expert: For each term in the terms array, calculates the number of
            documents containing <code>term</code>. Returns an array with these
            document frequencies. Used to minimize number of remote calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.MaxDoc">
            <summary>Expert: Returns one greater than the largest possible document number.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.MaxDoc">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32)" -->
        <member name="M:Lucene.Net.Search.Searchable.Doc(System.Int32)">
            <summary>Expert: Returns the stored fields of document <code>i</code>.
            Called by {@link HitCollector} implementations.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Doc(System.Int32,Lucene.Net.Documents.FieldSelector)">
            <summary> Get the {@link Lucene.Net.Documents.Document} at the <code>n</code><sup>th</sup> position. The {@link Lucene.Net.Documents.FieldSelector}
            may be used to determine what {@link Lucene.Net.Documents.Field}s to load and how they should be loaded.
            
            <b>NOTE:</b> If the underlying Reader (more specifically, the underlying <code>FieldsReader</code>) is closed before the lazy {@link Lucene.Net.Documents.Field} is
            loaded an exception may be thrown.  If you want the value of a lazy {@link Lucene.Net.Documents.Field} to be available after closing you must
            explicitly load it or fetch the Document again with a new loader.
            
            
            </summary>
            <param name="n">Get the document at the <code>n</code><sup>th</sup> position
            </param>
            <param name="fieldSelector">The {@link Lucene.Net.Documents.FieldSelector} to use to determine what Fields should be loaded on the Document.  May be null, in which case all Fields will be loaded.
            </param>
            <returns> The stored fields of the {@link Lucene.Net.Documents.Document} at the nth position
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <summary> 
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Documents.FieldSelector)">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.Fieldable">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.FieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.SetBasedFieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.LoadFirstFieldSelector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Rewrite(Lucene.Net.Search.Query)">
            <summary>Expert: called to re-write queries into primitive queries.</summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Explain(Lucene.Net.Search.Weight,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query)">
            <summary>Returns the documents matching <code>query</code>. </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>Returns the documents matching <code>query</code> and
            <code>filter</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> sorted by
            <code>sort</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> and <code>filter</code>,
            sorted by <code>sort</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.HitCollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Explain(Lucene.Net.Search.Query,System.Int32)" -->
        <member name="F:Lucene.Net.Search.Searcher.similarity">
            <summary>The Similarity implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this Searcher.
            
            </summary>
            <seealso cref="!:Similarity#SetDefault(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.GetSimilarity" -->
        <member name="M:Lucene.Net.Search.Searcher.CreateWeight(Lucene.Net.Search.Query)">
            <summary> creates a weight for <code>query</code></summary>
            <returns> new weight
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.GetSearchables">
            <summary>Return the array of {@link Searchable}s this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubSearcher(System.Int32)">
            <summary>Returns index of the searcher for document <code>n</code> in the array
            used to construct this searcher. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubDoc(System.Int32)">
            <summary>Returns the document number of document <code>n</code> within its
            sub-index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.CreateWeight(Lucene.Net.Search.Query)">
            <summary> Create weight in multiple index scenario.
            
            Distributed query processing is done in the following steps:
            1. rewrite query
            2. extract necessary terms
            3. collect dfs for these terms from the Searchables
            4. create query weight using aggregate dfs.
            5. distribute that weight to Searchables
            6. merge results
            
            Steps 1-4 are done here, 5+6 in the search() methods
            
            </summary>
            <returns> rewritten queries
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.MultiSearcher.CachedDfSource">
            <summary> Document Frequency cache acting as a Dummy-Searcher.
            This class is no full-fledged Searcher, but only supports
            the methods necessary to initialize Weights.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.DocFreq(Lucene.Net.Index.Term)">
            <summary> TODO: parallelize this one too</summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32)">
            <summary> A search implementation which spans a new thread for each
            Searchable, waits for each search to complete and merge
            the results back together.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            <summary> A search implementation allowing sorting which spans a new thread for each
            Searchable, waits for each search to complete and merges
            the results back together.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="T:Lucene.Net.Search.MultiSearcherThread">
            <summary> A thread subclass for searching a single searchable </summary>
        </member>
        <member name="T:SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="T:IThreadRunnable">
            <summary>
            This interface should be implemented by any class whose instances are intended 
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:IThreadRunnable.Run">
            <summary>
            This method has to be implemented in order that starting of the thread causes the object's 
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="T:SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="T:SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="F:SupportClass.ThreadClass.threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
            <param name="NanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread. Calling this method 
            usually terminates the thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread while also providing
            exception information about the thread termination. 
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current Object
            </summary>
            <returns>A String that represents the current Object</returns>
        </member>
        <member name="M:SupportClass.ThreadClass.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="P:SupportClass.ThreadClass.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="T:SupportClass.FileSupport">
            <summary>
            Represents the methods to support some operations over files.
            </summary>
        </member>
        <member name="M:SupportClass.FileSupport.GetFiles(System.IO.FileInfo)">
            <summary>
            Returns an array of abstract pathnames representing the files and directories of the specified path.
            </summary>
            <param name="path">The abstract pathname to list it childs.</param>
            <returns>An array of abstract pathnames childs of the path specified or null if the path is not a directory</returns>
        </member>
        <member name="M:SupportClass.FileSupport.GetLuceneIndexFiles(System.String,Lucene.Net.Index.IndexFileNameFilter)">
            <summary>
            Returns a list of files in a give directory.
            </summary>
            <param name="fullName">The full path name to the directory.</param>
            <param name="indexFileNameFilter"></param>
            <returns>An array containing the files.</returns>
        </member>
        <member name="T:SupportClass.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Int64)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Single)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Int64,System.Int32)">
            <summary>
            Converts a number to System.String in the specified radix.
            </summary>
            <param name="i">A number to be converted.</param>
            <param name="radix">A radix.</param>
            <returns>A System.String representation of the number in the specified redix.</returns>
        </member>
        <member name="M:SupportClass.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="M:SupportClass.Number.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SupportClass.Number.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SupportClass.Number.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the index of the first bit that is set to true that occurs 
            on or after the specified starting index. If no such bit exists 
            then -1 is returned.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="fromIndex">The index to start checking from (inclusive).</param>
            <returns>The index of the next set bit.</returns>
        </member>
        <member name="M:SupportClass.Number.Cardinality(System.Collections.BitArray)">
            <summary>
            Returns the number of bits set to true in this BitSet.
            </summary>
            <param name="bits">The BitArray object.</param>
            <returns>The number of bits set to true in this BitSet.</returns>
        </member>
        <member name="M:SupportClass.Number.ToInt64(System.String)">
            <summary>
            Converts a System.String number to long.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Character">
            <summary>
            Mimics Java's Character class.
            </summary>
        </member>
        <member name="M:SupportClass.Character.ForDigit(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="digit"></param>
            <param name="radix"></param>
            <returns></returns>
        </member>
        <member name="P:SupportClass.Character.MAX_RADIX">
            <summary>
            </summary>
        </member>
        <member name="P:SupportClass.Character.MIN_RADIX">
            <summary>
            </summary>
        </member>
        <member name="T:SupportClass.Date">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Date.GetTime(System.DateTime)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Single">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.ToString(System.Single)">
            <summary>
            
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.ToString(System.Single,System.String)">
            <summary>
            
            </summary>
            <param name="f"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.AppSettings">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="Key"></param>
            <param name="Value"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Compare">
            <summary>
            Summary description for TestSupportClass.
            </summary>
        </member>
        <member name="M:SupportClass.Compare.CompareTermArrays(Lucene.Net.Index.Term[],Lucene.Net.Index.Term[])">
            <summary>
            Compares two Term arrays for equality.
            </summary>
            <param name="t1">First Term array to compare</param>
            <param name="t2">Second Term array to compare</param>
            <returns>true if the Terms are equal in both arrays, false otherwise</returns>
        </member>
        <member name="M:SupportClass.Compare.CompareStringArrays(System.String[],System.String[])">
            <summary>
            Compares two string arrays for equality.
            </summary>
            <param name="l1">First string array list to compare</param>
            <param name="l2">Second string array list to compare</param>
            <returns>true if the strings are equal in both arrays, false otherwise</returns>
        </member>
        <member name="T:SupportClass.CompressionSupport">
            <summary>
            Use for .NET 1.1 Framework only.
            </summary>
        </member>
        <member name="T:SupportClass.WeakHashTable">
            <summary>
            A Hashtable which holds weak references to its keys so they
            can be collected during GC. 
            </summary>
        </member>
        <member name="F:SupportClass.WeakHashTable.collectableObject">
            <summary>
            Serves as a simple "GC Monitor" that indicates whether cleanup is needed. 
            If collectableObject.IsAlive is false, GC has occurred and we should perform cleanup
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.KeyEquals(System.Object,System.Object)">
            <summary>
            Customize the hashtable lookup process by overriding KeyEquals. KeyEquals
            will compare both WeakKey to WeakKey and WeakKey to real keys
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.CleanIfNeeded">
            <summary>
            Perform cleanup if GC occurred
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.Clean">
            <summary>
            Iterate over all keys and remove keys that were collected
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.Add(System.Object,System.Object)">
            <summary>
            Wrap each key with a WeakKey and add it to the hashtable
            </summary>
        </member>
        <member name="P:SupportClass.WeakHashTable.Keys">
            <summary>
            Create a temporary copy of the real keys and return that
            </summary>
        </member>
        <member name="T:SupportClass.WeakHashTable.WeakKey">
            <summary>
            A weak referene wrapper for the hashtable keys. Whenever a key\value pair 
            is added to the hashtable, the key is wrapped using a WeakKey. WeakKey saves the
            value of the original object hashcode for fast comparison.
            </summary>
        </member>
        <member name="T:SupportClass.WeakHashTable.WeakDictionaryEnumerator">
            <summary>
            A Dictionary enumerator which wraps the original hashtable enumerator 
            and performs 2 tasks: Extract the real key from a WeakKey and skip keys
            that were already collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ExtendedFieldCacheImpl">
            <summary> 
            
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheImpl" -->
        <member name="M:Lucene.Net.Search.FieldCache.GetBytes(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as a single byte and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the single byte values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetBytes(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.ByteParser)">
            <summary>Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as bytes and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the bytes.
            </param>
            <param name="parser"> Computes byte for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetShorts(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as shorts and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the shorts.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetShorts(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.ShortParser)">
            <summary>Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as shorts and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the shorts.
            </param>
            <param name="parser"> Computes short for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetInts(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as integers and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the integers.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetInts(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.IntParser)">
            <summary>Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as integers and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the integers.
            </param>
            <param name="parser"> Computes integer for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetFloats(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as floats and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the floats.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetFloats(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.FloatParser)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as floats and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the floats.
            </param>
            <param name="parser"> Computes float for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStrings(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>field</code> and returns an array
            of size <code>reader.maxDoc()</code> containing the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the strings.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStringIndex(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the term values in <code>field</code> and returns
            an array of them in natural order, along with an array telling
            which element in the term array each document uses.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the strings.
            </param>
            <returns> Array of terms and index into the array for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found reads <code>field</code> to see if it contains integers, floats
            or strings, and then calls one of the other methods in this class to get the
            values.  For string values, a StringIndex is returned.  After
            calling this method, there is an entry in the cache for both
            type <code>AUTO</code> and the actual found type.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the values.
            </param>
            <returns> int[], float[] or StringIndex.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetCustom(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.SortComparator)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the terms out of <code>field</code> and calls the given SortComparator
            to get the sort values.  A hit in the cache will happen if <code>reader</code>,
            <code>field</code>, and <code>comparator</code> are the same (using <code>equals()</code>)
            as a previous call to this method.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the values.
            </param>
            <param name="comparator">Used to convert terms into something to sort by.
            </param>
            <returns> Array of sort objects, one for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>The pattern used to detect float values in a field </summary>
            <summary> removed for java 1.3 compatibility
            protected static final Object pFloats = Pattern.compile ("[0-9+\\-\\.eEfFdD]+");
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ByteParser">
            <summary>Interface to parse bytes from document fields.</summary>
            <seealso cref="!:FieldCache.GetBytes(IndexReader, String, FieldCache.ByteParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ByteParser.ParseByte(System.String)">
            <summary>Return a single Byte representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ShortParser">
            <summary>Interface to parse shorts from document fields.</summary>
            <seealso cref="!:FieldCache.GetShorts(IndexReader, String, FieldCache.ShortParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ShortParser.ParseShort(System.String)">
            <summary>Return a short representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.IntParser">
            <summary>Interface to parse ints from document fields.</summary>
            <seealso cref="!:FieldCache.GetInts(IndexReader, String, FieldCache.IntParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.IntParser.ParseInt(System.String)">
            <summary>Return an integer representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FloatParser">
            <summary>Interface to parse floats from document fields.</summary>
            <seealso cref="!:FieldCache.GetFloats(IndexReader, String, FieldCache.FloatParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FloatParser.ParseFloat(System.String)">
            <summary>Return an float representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Cache">
            <summary>Expert: Internal cache. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Entry">
            <summary>Expert: Every composite-key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Int32,System.Globalization.CultureInfo)">
            <summary>Creates one of these objects. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Object)">
            <summary>Creates one of these objects for a custom comparator. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.Equals(System.Object)">
            <summary>Two of these are equal iff they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.GetHashCode">
            <summary>Composes a hashcode based on the field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetLongs(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as longs and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the longs.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  java.io.IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetLongs(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.LongParser)">
            <summary> Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as longs and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the longs.
            </param>
            <param name="parser">Computes integer for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetDoubles(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as integers and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the doubles.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetDoubles(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.DoubleParser)">
            <summary> Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as doubles and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the doubles.
            </param>
            <param name="parser">Computes integer for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.LongParser.ParseLong(System.String)">
            <summary> Return an long representation of this field's value.</summary>
        </member>
        <member name="M:Lucene.Net.Search.DoubleParser.ParseDouble(System.String)">
            <summary> Return an long representation of this field's value.</summary>
        </member>
        <member name="T:Lucene.Net.Search.CachingSpanFilter">
            <summary> Wraps another SpanFilter's result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add caching.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SpanFilter">
            <summary>Abstract base class providing a mechanism to restrict searches to a subset
            of an index and also maintains and returns position information.
            This is useful if you want to compare the positions from a SpanQuery with the positions of items in
            a filter.  For instance, if you had a SpanFilter that marked all the occurrences of the word "foo" in documents,
            and then you entered a new SpanQuery containing bar, you could not only filter by the word foo, but you could
            then compare position information for post processing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilter.BitSpans(Lucene.Net.Index.IndexReader)">
            <summary>Returns a SpanFilterResult with true for documents which should be permitted in
            search results, and false for those that should not and Spans for where the true docs match.
            </summary>
            <param name="reader">The {@link Lucene.Net.Index.IndexReader} to load position and bitset information from
            </param>
            <returns> A {@link SpanFilterResult}
            </returns>
            <throws>  java.io.IOException if there was an issue accessing the necessary information </throws>
            <summary> 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingSpanFilter.cache">
            <summary> A transient Filter cache.  To cache Filters even when using {@link Lucene.Net.Search.RemoteSearchable} use
            {@link Lucene.Net.Search.RemoteCachingWrapperFilter} instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingSpanFilter.#ctor(Lucene.Net.Search.SpanFilter)">
            <param name="filter">Filter to cache results of
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BooleanScorer2" -->
        <member name="F:Lucene.Net.Search.BooleanScorer2.countingSumScorer">
            <summary>The scorer to which all scoring will be delegated,
            except for computing and using the coordination factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.minNrShouldMatch">
            <summary>The number of optionalScorers that need to match (if there are any) </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.allowDocsOutOfOrder">
            <summary>Whether it is allowed to return documents out of order.
            This can accelerate the scoring of disjunction queries.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.Similarity,System.Int32,System.Boolean)">
            <summary>Create a BooleanScorer2.</summary>
            <param name="similarity">The similarity to be used.
            </param>
            <param name="minNrShouldMatch">The minimum number of optional added scorers
            that should match during the search.
            In case no required scorers are added,
            at least one of the optional scorers will have to
            match during the search.
            </param>
            <param name="allowDocsOutOfOrder">Whether it is allowed to return documents out of order.
            This can accelerate the scoring of disjunction queries.                         
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.Similarity,System.Int32)">
            <summary>Create a BooleanScorer2.
            In no required scorers are added,
            at least one of the optional scorers will have to match during the search.
            </summary>
            <param name="similarity">The similarity to be used.
            </param>
            <param name="minNrShouldMatch">The minimum number of optional added scorers
            that should match during the search.
            In case no required scorers are added,
            at least one of the optional scorers will have to
            match during the search.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Create a BooleanScorer2.
            In no required scorers are added,
            at least one of the optional scorers will have to match during the search.
            </summary>
            <param name="similarity">The similarity to be used.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.InitCountingSumScorer" -->
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses requiredScorers, optionalScorers and prohibitedScorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.AddProhibitedScorers(Lucene.Net.Search.Scorer)">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses the given required scorer and the prohibitedScorers.
            </summary>
            <param name="requiredCountingSumScorer">A required scorer already built.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.Score(Lucene.Net.Search.HitCollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.Score(Lucene.Net.Search.HitCollector,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.BooleanScorer2.Explain(System.Int32)">
            <summary>Throws an UnsupportedOperationException.
            TODO: Implement an explanation of the coordination factor.
            </summary>
            <param name="doc">The document number for the explanation.
            </param>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer">
            <summary>A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
            This Scorer implements {@link Scorer#SkipTo(int)} and uses skipTo() on the given Scorers. 
            </summary>
            <todo>  Implement score(HitCollector, int). </todo>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.nrScorers">
            <summary>The number of subscorers. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.subScorers">
            <summary>The subscorers. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.minimumNrMatchers">
            <summary>The minimum number of scorers that should match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.DisjunctionSumScorer.scorerDocQueue" -->
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.currentDoc">
            <summary>The document number of the current match. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.nrMatchers">
            <summary>The number of subscorers that provide the current match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(System.Collections.IList,System.Int32)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(System.Collections.IList)">
            <summary>Construct a <code>DisjunctionScorer</code>, using one as the minimum number
            of matching subscorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.InitScorerDocQueue">
            <summary>Called the first time next() or skipTo() is called to
            initialize <code>scorerDocQueue</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.Score(Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Score(Lucene.Net.Search.HitCollector,System.Int32)">
            <summary>Expert: Collects matching documents in a range.  Hook for optimization.
            Note that {@link #Next()} must be called once before this method is called
            for the first time.
            </summary>
            <param name="hc">The collector to which all matching documents are passed through
            {@link HitCollector#Collect(int, float)}.
            </param>
            <param name="max">Do not score documents past this.
            </param>
            <returns> true if more matching documents may remain.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.AdvanceAfterCurrent" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.NrMatchers">
            <summary>Returns the number of subscorers matching the current document.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Explain(System.Int32)">
            <returns> An explanation for the score of a given document. 
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2.SingleMatchScorer">
            <summary>Count a scorer as a single match. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddAllDocVectors(Lucene.Net.Index.TermFreqVector[])">
            <summary> Add a complete document specified by all its term vectors. If document has no
            term vectors, add value for tvx.
            
            </summary>
            <param name="vectors">
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.Close">
            <summary>Close all streams. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorsReader">
            <version>  $Id: TermVectorsReader.java 601337 2007-12-05 13:59:37Z mikemccand $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Size">
            <summary> </summary>
            <returns> The number of documents in the reader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32,System.String)">
            <summary> Retrieve the term vector for the given document and field</summary>
            <param name="docNum">The document number to retrieve the vector for
            </param>
            <param name="field">The field within the document to retrieve
            </param>
            <returns> The TermFreqVector for the document and field or null if there is no termVector for this field.
            </returns>
            <throws>  IOException if there is an error reading the term vector files </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32)">
            <summary> Return all term vectors stored for this document or null if the could not be read in.
            
            </summary>
            <param name="docNum">The document number to retrieve the vector for
            </param>
            <returns> All term frequency vectors
            </returns>
            <throws>  IOException if there is an error reading the term vector files  </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.ReadTermVector(System.String,System.Int64,Lucene.Net.Index.TermVectorMapper)">
            <summary> </summary>
            <param name="field">The field to read in
            </param>
            <param name="tvfPointer">The pointer within the tvf file where we should start reading
            </param>
            <param name="mapper">The mapper used to map the TermVector
            </param>
            <returns> The TermVector located at that position
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Index.ParallelArrayTermVectorMapper">
            <summary> Models the existing parallel array structure</summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelArrayTermVectorMapper.MaterializeVector">
            <summary> Construct the vector</summary>
            <returns> The {@link TermFreqVector} based on the mappings.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermDocs" -->
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.Term)">
            <summary>Sets this to the data for a term.
            The enumeration is reset to the start of the data for this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.TermEnum)">
            <summary>Sets this to the data for the current term in a {@link TermEnum}.
            This may be optimized in some implementations.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Doc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Freq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Read(System.Int32[],System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Index.TermDocs.Close">
            <summary>Frees associated resources. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipProx(System.Int64)">
            <summary>Overridden by SegmentTermPositions to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>Optimized implementation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.Payload" -->
        <member name="F:Lucene.Net.Index.Payload.data">
            <summary>the byte array containing the payload data </summary>
        </member>
        <member name="F:Lucene.Net.Index.Payload.offset">
            <summary>the offset within the byte array </summary>
        </member>
        <member name="F:Lucene.Net.Index.Payload.length">
            <summary>the length of the payload data </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.#ctor">
            <summary>Creates an empty payload and does not allocate a byte array. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.#ctor(System.Byte[])">
            <summary> Creates a new payload with the the given array as data.
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            
            </summary>
            <param name="data">the data of this payload
            </param>
        </member>
        <member name="M:Lucene.Net.Index.Payload.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary> Creates a new payload with the the given array as data. 
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            
            </summary>
            <param name="data">the data of this payload
            </param>
            <param name="offset">the offset in the data byte array
            </param>
            <param name="length">the length of the data
            </param>
        </member>
        <member name="M:Lucene.Net.Index.Payload.SetData(System.Byte[])">
            <summary> Sets this payloads data. 
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary> Sets this payloads data. 
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.GetData">
            <summary> Returns a reference to the underlying byte array
            that holds this payloads data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.GetOffset">
            <summary> Returns the offset in the underlying byte array </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.Length">
            <summary> Returns the length of the payload data. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.ByteAt(System.Int32)">
            <summary> Returns the byte at the given index.</summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.ToByteArray">
            <summary> Allocates a new byte array, copies the payload data into it and returns it. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.CopyTo(System.Byte[],System.Int32)">
            <summary> Copies the payload data to a byte array.
            
            </summary>
            <param name="target">the target byte array
            </param>
            <param name="targetOffset">the offset in the target byte array
            </param>
        </member>
        <member name="M:Lucene.Net.Index.Payload.Clone">
            <summary> Clones this payload by creating a copy of the underlying
            byte array.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogDocMergePolicy">
            <summary>This is a {@link LogMergePolicy} that measures size of a
            segment as the number of documents (not taking deletions
            into account). 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS">
            <seealso cref="!:setMinMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.SetMinMergeDocs(System.Int32)">
            <summary>Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.GetMinMergeDocs">
            <summary>Get the minimum size for a segment to remain
            un-merged.
            </summary>
            <seealso cref="!:setMinMergeDocs *">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CompoundFileWriter" -->
        <member name="M:Lucene.Net.Index.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
            <throws>  NullPointerException if <code>dir</code> or <code>name</code> is null </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetDirectory">
            <summary>Returns the directory of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetName">
            <summary>Returns the name of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.AddFile(System.String)">
            <summary>Add a source stream. <code>file</code> is the string by which the 
            sub-stream will be known in the compound stream.
            
            </summary>
            <throws>  IllegalStateException if this writer is closed </throws>
            <throws>  NullPointerException if <code>file</code> is null </throws>
            <throws>  IllegalArgumentException if a file with the same name </throws>
            <summary>   has been added already
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.Close">
            <summary>Merge files with the extensions added up to now.
            All files with these extensions are combined sequentially into the
            compound stream. After successful merge, the source files
            are deleted.
            </summary>
            <throws>  IllegalStateException if close() had been called before or </throws>
            <summary>   if no file has been added to this object
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.CopyFile(Lucene.Net.Index.CompoundFileWriter.FileEntry,Lucene.Net.Store.IndexOutput,System.Byte[])">
            <summary>Copy the contents of the file with specified extension into the
            provided output stream. Use the provided buffer for moving data
            to reduce memory allocation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.file">
            <summary>source file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.directoryOffset">
            <summary>temporary holder for the start of directory entry for this file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.dataOffset">
            <summary>temporary holder for the start of this file's data section </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader">
            <summary> Class for accessing a compound stream.
            This class implements a directory, but is limited to only read operations.
            Directory methods that would normally modify data throw an exception.
            
            
            </summary>
            <version>  $Id: CompoundFileReader.java 564236 2007-08-09 15:21:19Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileModified(System.String)">
            <summary>Returns the time the compound file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.TouchFile(System.String)">
            <summary>Set the modified time of the compound file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.DeleteFile(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.RenameFile(System.String,System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileLength(System.String)">
            <summary>Returns the length of a file in the directory.</summary>
            <throws>  IOException if the file does not exist  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CreateOutput(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.MakeLock(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader.CSIndexInput">
            <summary>Implementation of an IndexInput that reads from a portion of the
            compound file. The visibility is left as "package" *only* because
            this helps with testing since JUnit test cases in a different class
            can then access package fields of this class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current
            position in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where
            the next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.Close">
            <summary>Closes the stream to further operations. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldSelector">
            <summary> Similar to a {@link java.io.FileFilter}, the FieldSelector allows one to make decisions about
            what Fields get loaded on a {@link Document} by {@link Lucene.Net.Index.IndexReader#Document(int,Lucene.Net.Documents.FieldSelector)}
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldSelector.Accept(System.String)">
            <summary> </summary>
            <param name="fieldName">the field to accept or reject
            </param>
            <returns> an instance of {@link FieldSelectorResult}
            if the {@link Field} named <code>fieldName</code> should be loaded.
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceTokenizer">
            <summary>A WhitespaceTokenizer is a tokenizer that divides text at whitespace.
            Adjacent sequences of non-Whitespace characters form tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new WhitespaceTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which do not satisfy
            {@link Character#isWhitespace(char)}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.ISOLatin1AccentFilter" -->
        <member name="M:Lucene.Net.Analysis.ISOLatin1AccentFilter.RemoveAccents(System.Char[],System.Int32)">
            <summary> To replace accented characters in a String by unaccented equivalents.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Analyzer" -->
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Creates a TokenStream which tokenizes all the text in the provided
            Reader.  Default implementation forwards to tokenStream(Reader) for 
            compatibility with older version.  Override to allow Analyzer to choose 
            strategy based on document and/or field.  Must be able to handle null
            field name for backward compatibility. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.ReusableTokenStream(System.String,System.IO.TextReader)">
            <summary>Creates a TokenStream that is allowed to be re-used
            from the previous time that the same thread called
            this method.  Callers that do not need to use more
            than one TokenStream at the same time from this
            analyzer should use this method for better
            performance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPreviousTokenStream">
            <summary>Used by Analyzers that implement reusableTokenStream
            to retrieve previously saved TokenStreams for re-use
            by the same thread. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.SetPreviousTokenStream(System.Object)">
            <summary>Used by Analyzers that implement reusableTokenStream
            to save a TokenStream for later re-use by the same
            thread. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)">
            <summary> Invoked before indexing a Fieldable instance if
            terms have already been added to that field.  This allows custom
            analyzers to place an automatic position increment gap between
            Fieldable instances using the same field name.  The default value
            position increment gap is 0.  With a 0 position increment gap and
            the typical default token position increment of 1, all terms in a field,
            including across Fieldable instances, are in successive positions, allowing
            exact PhraseQuery matches, for instance, across Fieldable instance boundaries.
            
            </summary>
            <param name="fieldName">Fieldable name being indexed.
            </param>
            <returns> position increment gap, added to the next token emitted from {@link #TokenStream(String,Reader)}
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePositions">
            <summary> Position of a term in a document that takes into account the term offset within the phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.NextPosition">
            <summary> Go to next location of this term current document, and set 
            <code>position</code> as <code>location - offset</code>, so that a 
            matching exact phrase is easily identified when all PhrasePositions 
            have exactly the same <code>position</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.StringIndex" -->
        <member name="F:Lucene.Net.Search.StringIndex.lookup">
            <summary>All the term values, in natural order. </summary>
        </member>
        <member name="F:Lucene.Net.Search.StringIndex.order">
            <summary>For each document, an index into the lookup array. </summary>
        </member>
        <member name="M:Lucene.Net.Search.StringIndex.#ctor(System.Int32[],System.String[])">
            <summary>Creates one of these objects </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.STRING_INDEX">
            <summary>Indicator for StringIndex values in the cache. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.DEFAULT">
            <summary>Expert: The cache used internally by sorting and range query classes. </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxScorer">
            <summary> The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
            is generated in document number order.  The score for each document is the maximum of the scores computed
            by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
            for the other subqueries that generate the document.
            </summary>
            <author>  Chuck Williams
            </author>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.#ctor(System.Single,Lucene.Net.Search.Similarity)">
            <summary>Creates a new instance of DisjunctionMaxScorer</summary>
            <param name="tieBreakerMultiplier">Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.
            </param>
            <param name="similarity">-- not used since our definition involves neither coord nor terms directly 
            </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Add(Lucene.Net.Search.Scorer)">
            <summary>Add the scorer for a subquery</summary>
            <param name="scorer">the scorer of a subquery of our associated DisjunctionMaxQuery
            </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Next">
            <summary>Generate the next document matching our associated DisjunctionMaxQuery.</summary>
            <returns> true iff there is a next document
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Doc">
            <summary>Determine the current document number.  Initially invalid, until {@link #Next()} is called the first time.</summary>
            <returns> the document number of the currently generated document
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Score">
            <summary>Determine the current document score.  Initially invalid, until {@link #Next()} is called the first time.</summary>
            <returns> the score of the current generated document
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.SkipTo(System.Int32)">
            <summary>Advance to the first document beyond the current whose number is greater than or equal to target.</summary>
            <param name="target">the minimum number of the next desired document
            </param>
            <returns> true iff there is a document to be generated whose number is at least target
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Explain(System.Int32)">
            <summary>Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.</summary>
            <param name="doc">the number of a document we scored
            </param>
            <returns> the Explanation for our score
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary> Wraps another filter's result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add caching.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.cache">
            <summary> A transient Filter cache.  To cache Filters even when using {@link RemoteSearchable} use
            {@link RemoteCachingWrapperFilter} instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <param name="filter">Filter to cache results of
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentMerger" -->
        <member name="F:Lucene.Net.Index.SegmentMerger.MAX_RAW_MERGE_DOCS">
            <summary>Maximum number of contiguous documents to bulk-copy
            when merging stored fields 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentMerger.NORMS_HEADER">
            <summary>norms header placeholder </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>This ctor used only by test code.
            
            </summary>
            <param name="dir">The Directory to merge the other segments into
            </param>
            <param name="name">The name of the new segment
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Add(Lucene.Net.Index.IndexReader)">
            <summary> Add an IndexReader to the collection of readers that are to be merged</summary>
            <param name="reader">
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.SegmentReader(System.Int32)">
            <summary> </summary>
            <param name="i">The index of the reader to return
            </param>
            <returns> The ith reader to be merged
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary> Merges the readers specified by the {@link #add} method into the directory passed to the constructor</summary>
            <returns> The number of documents that were merged
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge(System.Boolean)">
            <summary> Merges the readers specified by the {@link #add} method
            into the directory passed to the constructor.
            </summary>
            <param name="mergeDocStores">if false, we will not merge the
            stored fields nor vectors files
            </param>
            <returns> The number of documents that were merged
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.CloseReaders">
            <summary> close all IndexReaders that have been added.
            Should not be called before merge().
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            <summary> </summary>
            <returns> The number of documents in all of the readers
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary> Merge the TermVectors from each of the segments into the new one.</summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeTermInfo(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Merge one term found in one or more segments. The array <code>smis</code>
            contains segments that are positioned at the same term. <code>N</code>
            is the number of cells in the array actually occupied.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.AppendPostings(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Process postings from multiple segments all positioned on the
            same term. Writes out merged entries into freqOutput and
            the proxOutput streams.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
            <returns> number of documents across all segments where this term was found
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.CheckAbort.Work(System.Double)">
            <summary> Records the fact that roughly units amount of work
            have been done since this method was last called.
            When adding time-consuming code into SegmentMerger,
            you should test different values for units to ensure
            that the time in between calls to merge.checkAborted
            is up to ~ 1 second.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexDeletionPolicy" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexDeletionPolicy.OnInit(System.Collections.IList)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit(System.Collections.IList)" -->
        <member name="T:Lucene.Net.Index.FieldSortedTermVectorMapper">
            <summary> For each Field, store a sorted collection of {@link TermVectorEntry}s
            <p/>
            This is not thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldSortedTermVectorMapper.#ctor(System.Collections.Generic.IComparer{System.Object})">
            <summary> </summary>
            <param name="comparator">A Comparator for sorting {@link TermVectorEntry}s
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldSortedTermVectorMapper.GetFieldToTerms">
            <summary> Get the mapping between fields and terms, sorted by the comparator
            
            </summary>
            <returns> A map between field names and {@link java.util.SortedSet}s per field.  SortedSet entries are {@link TermVectorEntry}
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.FieldReaderException">
            <summary> 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldReaderException.#ctor">
            <summary> Constructs a new runtime exception with <code>null</code> as its
            detail message.  The cause is not initialized, and may subsequently be
            initialized by a call to {@link #initCause}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FieldReaderException.#ctor(System.Exception)" -->
        <member name="M:Lucene.Net.Index.FieldReaderException.#ctor(System.String)">
            <summary> Constructs a new runtime exception with the specified detail message.
            The cause is not initialized, and may subsequently be initialized by a
            call to {@link #initCause}.
            
            </summary>
            <param name="message">the detail message. The detail message is saved for
            later retrieval by the {@link #getMessage()} method.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FieldReaderException.#ctor(System.String,System.Exception)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Standard.StandardTokenizer" -->
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.ACRONYM_DEP">
            <deprecated> this solves a bug where HOSTs that end with '.' are identified
            as ACRONYMs. It is deprecated and will be removed in the next
            release.
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.scanner">
            <summary>A private instance of the JFlex-constructed scanner </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.tokenImage">
            @deprecated Please use {@link #TOKEN_TYPES} instead 
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.replaceInvalidAcronym">
            <summary> Specifies whether deprecated acronyms should be replaced with HOST type.
            This is false by default to support backward compatibility.
            <p/>
            See http://issues.apache.org/jira/browse/LUCENE-1068
            
            </summary>
            <deprecated> this should be removed in the next release (3.0).
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.SetMaxTokenLength(System.Int32)">
            <summary>Set the max allowed token length.  Any token longer
            than this is skipped. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.GetMaxTokenLength">
            <seealso cref="!:setMaxTokenLength">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.#ctor(System.IO.TextReader)">
            <summary> Creates a new instance of the {@link StandardTokenizer}. Attaches the
            <code>input</code> to a newly created JFlex scanner.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.#ctor(System.IO.TextReader,System.Boolean)">
            <summary> Creates a new instance of the {@link Lucene.Net.Analysis.Standard.StandardTokenizer}.  Attaches
            the <code>input</code> to the newly created JFlex scanner.
            
            </summary>
            <param name="input">The input reader
            </param>
            <param name="replaceInvalidAcronym">Set to true to replace mischaracterized acronyms with HOST.
            
            See http://issues.apache.org/jira/browse/LUCENE-1068
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.IsReplaceInvalidAcronym">
            <summary> Prior to https://issues.apache.org/jira/browse/LUCENE-1068, StandardTokenizer mischaracterized as acronyms tokens like www.abc.com
            when they should have been labeled as hosts instead.
            </summary>
            <returns> true if StandardTokenizer now returns these tokens as Hosts, otherwise false
            
            </returns>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.SetReplaceInvalidAcronym(System.Boolean)">
            <summary> </summary>
            <param name="replaceInvalidAcronym">Set to true to replace mischaracterized acronyms as HOST.
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </deprecated>
        </member>
        <member name="T:Lucene.Net.Analysis.SinkTokenizer">
            <summary> A SinkTokenizer can be used to cache Tokens for use in an Analyzer
            
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TeeTokenFilter">
            
            
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.GetTokens">
            <summary> Get the tokens in the internal List.
            <p/>
            WARNING: Adding tokens to this list requires the {@link #Reset()} method to be called in order for them
            to be made available.  Also, this Tokenizer does nothing to protect against {@link java.util.ConcurrentModificationException}s
            in the case of adds happening while {@link #Next(Lucene.Net.Analysis.Token)} is being called.
            
            </summary>
            <returns> A List of {@link Lucene.Net.Analysis.Token}s
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.Next">
            <summary> Returns the next token out of the list of cached tokens</summary>
            <returns> The next {@link Lucene.Net.Analysis.Token} in the Sink.
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.Add(Lucene.Net.Analysis.Token)">
            <summary> Override this method to cache only certain tokens, or new tokens based
            on the old tokens.
            
            </summary>
            <param name="t">The {@link Lucene.Net.Analysis.Token} to add to the sink
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.Reset">
            <summary> Reset the internal data structures to the start at the front of the list of tokens.  Should be called
            if tokens were added to the list after an invocation of {@link #Next(Token)}
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Store.NativeFSLockFactory">
            <summary> <p>Implements {@link LockFactory} using native OS file
            locks.  Note that because this LockFactory relies on
            java.nio.* APIs for locking, any problems with those APIs
            will cause locking to fail.  Specifically, on certain NFS
            environments the java.nio.* locks will fail (the lock can
            incorrectly be double acquired) whereas {@link
            SimpleFSLockFactory} worked perfectly in those same
            environments.  For NFS based access to an index, it's
            recommended that you try {@link SimpleFSLockFactory}
            first and work around the one limitation that a lock file
            could be left when the JVM exits abnormally.</p>
            
            <p>The primary benefit of {@link NativeFSLockFactory} is
            that lock files will be properly removed (by the OS) if
            the JVM has an abnormal exit.</p>
            
            <p>Note that, unlike {@link SimpleFSLockFactory}, the existence of
            leftover lock files in the filesystem on exiting the JVM
            is fine because the OS will free the locks held against
            these files even though the files still remain.</p>
            
            <p>If you suspect that this or any other LockFactory is
            not working properly in your environment, you can easily
            test it by using {@link VerifyingLockFactory}, {@link
            LockVerifyServer} and {@link LockStressTest}.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Store.NativeFSLockFactory.lockDir">
            <summary> Directory specified by <code>Lucene.Net.lockDir</code>
            system property.  If that is not set, then <code>java.io.tmpdir</code>
            system property is used.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor">
            <summary> Create a NativeFSLockFactory instance, with null (unset)
            lock directory.  This is package-private and is only
            used by FSDirectory when creating this LockFactory via
            the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.String)">
            <summary> Create a NativeFSLockFactory instance, storing lock
            files into the specified lockDirName:
            
            </summary>
            <param name="lockDirName">where lock files are created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.IO.FileInfo)">
            <summary> Create a NativeFSLockFactory instance, storing lock
            files into the specified lockDir:
            
            </summary>
            <param name="lockDir">where lock files are created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.SetLockDir(System.IO.FileInfo)">
            <summary> Set the lock directory.  This is package-private and is
            only used externally by FSDirectory when creating this
            LockFactory via the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.WildcardQuery">
            <summary>Implements the wildcard search query. Supported wildcards are <code>*</code>, which
            matches any character sequence (including the empty one), and <code>?</code>,
            which matches any single character. Note this query can be slow, as it
            needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,
            a Wildcard term should not start with one of the wildcards <code>*</code> or
            <code>?</code>.
            
            </summary>
            <seealso cref="T:Lucene.Net.Search.WildcardTermEnum">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery" -->
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms matching <code>term</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTerm">
            <summary>Returns the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetEnum(Lucene.Net.Index.IndexReader)">
            <summary>Construct the enumeration to be used, expanding the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.RangeFilter">
            <summary> A Filter that restricts search results to a range of values in a given
            field.
            
            <p>
            This code borrows heavily from {@link RangeQuery}, but is implemented as a Filter
            
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.#ctor(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <param name="fieldName">The field this range applies to
            </param>
            <param name="lowerTerm">The lower bound on this range
            </param>
            <param name="upperTerm">The upper bound on this range
            </param>
            <param name="includeLower">Does this range include the lower bound?
            </param>
            <param name="includeUpper">Does this range include the upper bound?
            </param>
            <throws>  IllegalArgumentException if both terms are null or if </throws>
            <summary>  lowerTerm is null and includeLower is true (similar for upperTerm
            and includeUpper)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Less(System.String,System.String)">
            <summary> Constructs a filter for field <code>fieldName</code> matching
            less than or equal to <code>upperTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.More(System.String,System.String)">
            <summary> Constructs a filter for field <code>fieldName</code> matching
            greater than or equal to <code>lowerTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Returns a BitSet with true for documents which should be
            permitted in search results, and false for those that should
            not.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixFilter">
            <summary> </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Search.PrefixFilter.ToString">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.FastCharStream" -->
        <member name="T:Lucene.Net.QueryParsers.CharStream">
            <summary> This interface describes a character stream that maintains line and
            column number positions of the characters.  It also has the capability
            to backup the stream to some extent.  An implementation of this
            interface is used in the TokenManager implementation generated by
            JavaCCParser.
            
            All the methods except backup can be implemented in any fashion. backup
            needs to be implemented correctly for the correct operation of the lexer.
            Rest of the methods are all used to get information like line number,
            column number and the String that constitutes a token and are not used
            by the lexer. Hence their implementation won't affect the generated lexer's
            operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="M:Lucene.Net.QueryParsers.CharStream.GetEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorEntryFreqSortedComparator">
            <summary> Compares {@link Lucene.Net.Index.TermVectorEntry}s first by frequency and then by
            the term (case-sensitive)
            
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermPositions" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.NextPosition" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.GetPayloadLength" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.GetPayload(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.IsPayloadAvailable" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexReader" -->
        <member name="M:Lucene.Net.Index.IndexReader.IncRef">
            <summary> Increments the refCount of this IndexReader instance. RefCounts are used to determine
            when a reader can be closed safely, i. e. as soon as no other IndexReader is referencing
            it anymore.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DecRef">
            <summary> Decreases the refCount of this IndexReader instance. If the refCount drops
            to 0, then pending changes are committed to the index and this reader is closed.
            
            </summary>
            <throws>  IOException in case an IOException occurs in commit() or doClose() </throws>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.directory">
            <deprecated> will be deleted when IndexReader(Directory) is deleted
            </deprecated>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Directory">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.#ctor(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.IndexReader.EnsureOpen">
            <throws>  AlreadyClosedException if this IndexReader is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.String)">
            <summary>Returns an IndexReader reading the index in an FSDirectory in the named
            path.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <param name="path">the path to the index directory 
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.IO.FileInfo)">
            <summary>Returns an IndexReader reading the index in an FSDirectory in the named
            path.
            </summary>
            <param name="path">the path to the index directory
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>Returns an IndexReader reading the index in the given Directory.</summary>
            <param name="directory">the index directory
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>Expert: returns an IndexReader reading the index in the given
            Directory, with a custom {@link IndexDeletionPolicy}.
            </summary>
            <param name="directory">the index directory
            </param>
            <param name="deletionPolicy">a custom deletion policy (only used
            if you use this reader to perform deletes or to set
            norms); see {@link IndexWriter} for details.
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Reopen" -->
        <member name="M:Lucene.Net.Index.IndexReader.Directory">
            <summary> Returns the directory associated with this index.  The Default 
            implementation returns the directory specified by subclasses when 
            delegating to the IndexReader(Directory) constructor, or throws an 
            UnsupportedOperationException if one was not specified.
            </summary>
            <throws>  UnsupportedOperationException if no directory </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.String)">
            <summary> Returns the time the index in the named directory was last modified.
            Do not use this to check whether the reader is still up-to-date, use
            {@link #IsCurrent()} instead. 
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.IO.FileInfo)">
            <summary> Returns the time the index in the named directory was last modified. 
            Do not use this to check whether the reader is still up-to-date, use
            {@link #IsCurrent()} instead. 
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(Lucene.Net.Store.Directory)">
            <summary> Returns the time the index in the named directory was last modified. 
            Do not use this to check whether the reader is still up-to-date, use
            {@link #IsCurrent()} instead. 
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.String)">
            <summary> Reads version number from segments files. The version number is
            initialized with a timestamp and then increased by one for each change of
            the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.IO.FileInfo)">
            <summary> Reads version number from segments files. The version number is
            initialized with a timestamp and then increased by one for each change of
            the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Reads version number from segments files. The version number is
            initialized with a timestamp and then increased by one for each change of
            the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetVersion">
            <summary> Version number when this IndexReader was opened. Not implemented in the IndexReader base class.</summary>
            <throws>  UnsupportedOperationException unless overridden in subclass </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetTermInfosIndexDivisor(System.Int32)">
            <summary><p>For IndexReader implementations that use
            TermInfosReader to read terms, this sets the
            indexDivisor to subsample the number of indexed terms
            loaded into memory.  This has the same effect as {@link
            IndexWriter#setTermIndexInterval} except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value > 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.</p>
            
            <b>NOTE:</b> you must call this before the term
            index is loaded.  If the index is already loaded, 
            an IllegalStateException is thrown.
            </summary>
            <throws>  IllegalStateException if the term index has already been loaded into memory </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.GetTermInfosIndexDivisor" -->
        <member name="M:Lucene.Net.Index.IndexReader.IsCurrent">
            <summary> Check whether this IndexReader is still using the
            current (i.e., most recently committed) version of the
            index.  If a writer has committed any changes to the
            index since this reader was opened, this will return
            <code>false</code>, in which case you must open a new
            IndexReader in order to see the changes.  See the
            description of the <a href="IndexWriter.html#autoCommit"><code>autoCommit</code></a>
            flag which controls when the {@link IndexWriter}
            actually commits changes to the index.
            
            <p>
            Not implemented in the IndexReader base class.
            </p>
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <throws>  UnsupportedOperationException unless overridden in subclass </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsOptimized">
            <summary> Checks is the index is optimized (if it has a single segment and 
            no deletions).  Not implemented in the IndexReader base class.
            </summary>
            <returns> <code>true</code> if the index is optimized; <code>false</code> otherwise
            </returns>
            <throws>  UnsupportedOperationException unless overridden in subclass </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVectors(System.Int32)">
            <summary>  Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized field in the document.
            Each vector contains terms and frequencies for all terms in a given vectorized field.
            If no such fields existed, the method returns null. The term vectors that are
            returned my either be of type TermFreqVector or of type TermPositionsVector if
            positions or offsets have been stored.
            
            </summary>
            <param name="docNumber">document for which term frequency vectors are returned
            </param>
            <returns> array of term frequency vectors. May be null if no term vectors have been
            stored for the specified document.
            </returns>
            <throws>  IOException if index cannot be accessed </throws>
            <seealso cref="T:Lucene.Net.Documents.Field.TermVector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>  Return a term frequency vector for the specified document and field. The
            returned vector contains terms and frequencies for the terms in
            the specified field of this document, if the field had the storeTermVector
            flag set. If termvectors had been stored with positions or offsets, a 
            TermPositionsVector is returned.
            
            </summary>
            <param name="docNumber">document for which the term frequency vector is returned
            </param>
            <param name="field">field for which the term frequency vector is returned.
            </param>
            <returns> term frequency vector May be null if field does not exist in the specified
            document or term vector was not stored.
            </returns>
            <throws>  IOException if index cannot be accessed </throws>
            <seealso cref="T:Lucene.Net.Documents.Field.TermVector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String,Lucene.Net.Index.TermVectorMapper)">
            <summary> Load the Term Vector into a user-defined data structure instead of relying on the parallel arrays of
            the {@link TermFreqVector}.
            </summary>
            <param name="docNumber">The number of the document to load the vector for
            </param>
            <param name="field">The name of the field to load
            </param>
            <param name="mapper">The {@link TermVectorMapper} to process the vector.  Must not be null
            </param>
            <throws>  IOException if term vectors cannot be accessed or if they do not exist on the field and doc. specified. </throws>
            <summary> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,Lucene.Net.Index.TermVectorMapper)">
            <summary> Map all the term vectors for all fields in a Document</summary>
            <param name="docNumber">The number of the document to load the vector for
            </param>
            <param name="mapper">The {@link TermVectorMapper} to process the vector.  Must not be null
            </param>
            <throws>  IOException if term vectors cannot be accessed or if they do not exist on the field and doc. specified. </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.String)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            <code>false</code> is returned.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.IO.FileInfo)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>Returns the number of documents in this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>Returns one greater than the largest possible document number.
            This may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            <summary>Returns the stored fields of the <code>n</code><sup>th</sup>
            <code>Document</code> in this index.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Documents.FieldSelector)">
            <summary> Get the {@link Lucene.Net.Documents.Document} at the <code>n</code><sup>th</sup> position. The {@link Lucene.Net.Documents.FieldSelector}
            may be used to determine what {@link Lucene.Net.Documents.Field}s to load and how they should be loaded.
            
            <b>NOTE:</b> If this Reader (more specifically, the underlying <code>FieldsReader</code>) is closed before the lazy {@link Lucene.Net.Documents.Field} is
            loaded an exception may be thrown.  If you want the value of a lazy {@link Lucene.Net.Documents.Field} to be available after closing you must
            explicitly load it or fetch the Document again with a new loader.
            
            
            </summary>
            <param name="n">Get the document at the <code>n</code><sup>th</sup> position
            </param>
            <param name="fieldSelector">The {@link Lucene.Net.Documents.FieldSelector} to use to determine what Fields should be loaded on the Document.  May be null, in which case all Fields will be loaded.
            </param>
            <returns> The stored fields of the {@link Lucene.Net.Documents.Document} at the nth position
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <summary> 
            </summary>
            <seealso cref="T:Lucene.Net.Documents.Fieldable">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.FieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.SetBasedFieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.LoadFirstFieldSelector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsDeleted(System.Int32)">
            <summary>Returns true if document <i>n</i> has been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>Returns true if any documents have been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.HasNorms(System.String)">
            <summary>Returns true if there are norms stored for this field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String)">
            <summary>Returns the byte-encoded normalization factor for the named field of
            every document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Lucene.Net.Documents.Field.SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Reads the byte-encoded normalization factor for the named field of every
            document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Lucene.Net.Documents.Field.SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Byte)">
            <summary>Expert: Resets the normalization factor for the named field of the named
            document.  The norm represents the product of the field's {@link
            Lucene.Net.Documents.Fieldable#SetBoost(float) boost} and its {@link Similarity#LengthNorm(String,
            int) length normalization}.  Thus, to preserve the length normalization
            values when resetting this, one should base the new value upon the old.
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Norms(System.String)">
            </seealso>
            <seealso cref="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            </seealso>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoSetNorm(System.Int32,System.String,System.Byte)">
            <summary>Implements setNorm in subclass.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Single)">
            <summary>Expert: Resets the normalization factor for the named field of the named
            document.
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Norms(System.String)">
            </seealso>
            <seealso cref="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            
            </seealso>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms">
            <summary>Returns an enumeration of all the terms in the index. The
            enumeration is ordered by Term.compareTo(). Each term is greater
            than all that precede it in the enumeration. Note that after
            calling terms(), {@link TermEnum#Next()} must be called
            on the resulting enumeration before calling other methods such as
            {@link TermEnum#Term()}.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of all terms starting at a given term. If
            the given term does not exist, the enumeration is positioned at the
            first term greater than the supplied therm. The enumeration is
            ordered by Term.compareTo(). Each term is greater than all that
            precede it in the enumeration.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            <summary>Returns the number of documents containing the term <code>t</code>.</summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermDocs(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermDocs">
            <summary>Returns an unpositioned {@link TermDocs} enumerator.</summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermPositions(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermPositions">
            <summary>Returns an unpositioned {@link TermPositions} enumerator.</summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DeleteDocument(System.Int32)">
            <summary>Deletes the document numbered <code>docNum</code>.  Once a document is
            deleted it will not appear in TermDocs or TermPostitions enumerations.
            Attempts to read its field with the {@link #document}
            method will result in an error.  The presence of this document may still be
            reflected in the {@link #docFreq} statistic, though
            this will be corrected eventually as the index is further modified.
            
            </summary>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary> since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoDelete(System.Int32)">
            <summary>Implements deletion of the document numbered <code>docNum</code>.
            Applications should call {@link #DeleteDocument(int)} or {@link #DeleteDocuments(Term)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary>Deletes all documents that have a given <code>term</code> indexed.
            This is useful if one uses a document field to hold a unique ID string for
            the document.  Then to delete such a document, one merely constructs a
            term with the appropriate field and the unique ID string as its text and
            passes it to this method.
            See {@link #DeleteDocument(int)} for information about when this deletion will 
            become effective.
            
            </summary>
            <returns> the number of documents deleted
            </returns>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.UndeleteAll">
            <summary>Undeletes all documents currently marked as deleted in this index.
            
            </summary>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoUndeleteAll">
            <summary>Implements actual undeleteAll() in subclass. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.AcquireWriteLock">
            <summary>Does nothing by default. Subclasses that require a write lock for
            index modifications must implement this method. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Flush">
            <summary> </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Commit">
            <summary> Commit changes resulting from delete, undeleteAll, or
            setNorm operations
            
            If an exception is hit, then either no changes or all
            changes will have been committed to the index
            (transactional semantics).
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoCommit">
            <summary>Implements commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Close">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>Implements close. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <summary> Get a list of unique field names that exist in this index and have the specified
            field option information.
            </summary>
            <param name="fldOption">specifies which field option should be available for the returned fields
            </param>
            <returns> Collection of Strings indicating the names of the fields.
            </returns>
            <seealso cref="T:Lucene.Net.Index.IndexReader.FieldOption">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(System.String)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Unlock(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.IndexReader.Main(System.String[])">
            <summary> Prints the filename and size of each file within a given compound file.
            Add the -extract flag to extract files to the current working directory.
            In order to make the extracted version of the index work, you have to copy
            the segments file from the compound index into the directory where the extracted files are stored.
            </summary>
            <param name="args">Usage: Lucene.Net.Index.IndexReader [-extract] &lt;cfsfile&gt;
            </param>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader.FieldOption">
            <summary> Constants describing field properties, for example used for
            {@link IndexReader#GetFieldNames(FieldOption)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.ALL">
            <summary>All fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.INDEXED">
            <summary>All indexed fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.STORES_PAYLOADS">
            <summary>All fields that store payloads </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.UNINDEXED">
            <summary>All fields which are not indexed </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR">
            <summary>All fields which are indexed with termvectors enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.INDEXED_NO_TERMVECTOR">
            <summary>All fields which are indexed but don't have termvectors enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR">
            <summary>All fields with termvectors enabled. Please note that only standard termvector fields are returned </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR_WITH_POSITION">
            <summary>All fields with termvectors with position values enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET">
            <summary>All fields with termvectors with offset values enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET">
            <summary>All fields with termvectors with offset values and position values enabled </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldSelectorResult">
            <summary>  Provides information about what should be done with this Field 
            
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LOAD">
            <summary> Load this {@link Field} every time the {@link Document} is loaded, reading in the data as it is encounterd.
            {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should not return null.
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LAZY_LOAD">
            <summary> Lazily load this {@link Field}.  This means the {@link Field} is valid, but it may not actually contain its data until
            invoked.  {@link Document#GetField(String)} SHOULD NOT BE USED.  {@link Document#GetFieldable(String)} is safe to use and should
            return a valid instance of a {@link Fieldable}.
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.NO_LOAD">
            <summary> Do not load the {@link Field}.  {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should return null.
            {@link Document#Add(Fieldable)} is not called.
            <p/>
            {@link Document#Add(Fieldable)} should not be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LOAD_AND_BREAK">
            <summary> Load this field as in the {@link #LOAD} case, but immediately return from {@link Field} loading for the {@link Document}.  Thus, the
            Document may not have its complete set of Fields.  {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should
            both be valid for this {@link Field}
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LOAD_FOR_MERGE">
            <summary> Behaves much like {@link #LOAD} but does not uncompress any compressed data.  This is used for internal purposes.
            {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should not return null.
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.SIZE">
            <summary>Expert:  Load the size of this {@link Field} rather than its value.
            Size is measured as number of bytes required to store the field == bytes for a binary or any compressed value, and 2*chars for a String value.
            The size is stored as a binary value, represented as an int in a byte[], with the higher order byte first in [0]
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.SIZE_AND_BREAK">
            <summary>Expert: Like {@link #SIZE} but immediately break from the field loading loop, i.e., stop loading further fields, after the size is loaded </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Token" -->
        <member name="F:Lucene.Net.Analysis.Token.termText">
            <deprecated>: we will remove this when we remove the
            deprecated APIs 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor">
            <summary>Constructs a Token will null text. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.SetPositionIncrement(System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.GetPositionIncrement">
            <summary>Returns the position increment of this Token.</summary>
            <seealso cref="!:setPositionIncrement">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermText(System.String)">
            <summary>Sets the Token's term text.  <b>NOTE:</b> for better
            indexing speed you should instead use the char[]
            termBuffer methods to set the term text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermText">
            <summary>Returns the Token's term text.
            
            </summary>
            <deprecated> Use {@link #TermBuffer()} and {@link
            #TermLength()} instead. 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermBuffer(System.Char[],System.Int32,System.Int32)">
            <summary>Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer
            array. <b>NOTE:</b> for better indexing speed you
            should instead retrieve the termBuffer, using {@link
            #TermBuffer()} or {@link #ResizeTermBuffer(int)}, and
            fill it in directly to set the term text.  This saves
            an extra copy. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermBuffer">
            <summary>Returns the internal termBuffer character array which
            you can then directly alter.  If the array is too
            small for your token, use {@link
            #ResizeTermBuffer(int)} to increase it.  After
            altering the buffer be sure to call {@link
            #setTermLength} to record the number of valid
            characters that were placed into the termBuffer. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.ResizeTermBuffer(System.Int32)">
            <summary>Grows the termBuffer to at least size newSize.</summary>
            <param name="newSize">minimum size of the new termBuffer
            </param>
            <returns> newly created termBuffer with length >= newSize
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermLength">
            <summary>Return number of valid characters (length of the term)
            in the termBuffer array. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermLength(System.Int32)">
            <summary>Set number of valid characters (length of the term) in
            the termBuffer array. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.StartOffset">
            <summary>Returns this Token's starting offset, the position of the first character
            corresponding to this token in the source text.
            Note that the difference between endOffset() and startOffset() may not be
            equal to termText.length(), as the term text may have been altered by a
            stemmer or some other filter. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetStartOffset(System.Int32)">
            <summary>Set the starting offset.</summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.StartOffset">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.EndOffset">
            <summary>Returns this Token's ending offset, one greater than the position of the
            last character corresponding to this token in the source text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetEndOffset(System.Int32)">
            <summary>Set the ending offset.</summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.EndOffset">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Type">
            <summary>Returns this Token's lexical type.  Defaults to "word". </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetType(System.String)">
            <summary>Set the lexical type.</summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.Type">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.GetPayload">
            <summary> Returns this Token's payload.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetPayload(Lucene.Net.Index.Payload)">
            <summary> Sets this Token's payload.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Clear">
            <summary>Resets the term text, payload, and positionIncrement to default.
            Other fields such as startOffset, endOffset and the token type are
            not reset since they are normally overwritten by the tokenizer. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopFilter">
            <summary> Removes stop words from a token stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.String[])">
            <summary> Construct a token stream filtering the given input.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.String[],System.Boolean)">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the array of words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable,System.Boolean)">
            <summary> Construct a token stream filtering the given input.
            If <code>stopWords</code> is an instance of {@link CharArraySet} (true if
            <code>makeStopSet()</code> was used to construct the set) it will be directly used
            and <code>ignoreCase</code> will be ignored since <code>CharArraySet</code>
            directly controls case sensitivity.
            <p/>
            If <code>stopWords</code> is not an instance of {@link CharArraySet},
            a new CharArraySet will be constructed and <code>ignoreCase</code> will be
            used to specify the case sensitivity of that set.
            
            </summary>
            <param name="input">
            </param>
            <param name="stopWords">The set of Stop Words.
            </param>
            <param name="ignoreCase">-Ignore case when stopping.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable)">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the Set.
            
            </summary>
            <seealso cref="!:MakeStopSet(java.lang.String[])">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopSet(System.String[])">
            <summary> Builds a Set from an array of stop words,
            appropriate for passing into the StopFilter constructor.
            This permits this stopWords construction to be cached once when
            an Analyzer is constructed.
            
            </summary>
            <seealso cref="!:MakeStopSet(java.lang.String[], boolean) passing false to ignoreCase">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopSet(System.String[],System.Boolean)">
            <summary> </summary>
            <param name="stopWords">
            </param>
            <param name="ignoreCase">If true, all words are lower cased first.  
            </param>
            <returns> a Set containing the words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.Next(Lucene.Net.Analysis.Token)">
            <summary> Returns the next input Token whose termText() is not a stop word.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.GetEnablePositionIncrementsDefault">
            <seealso cref="!:setEnablePositionIncrementsDefault(boolean).">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.StopFilter.SetEnablePositionIncrementsDefault(System.Boolean)" -->
        <member name="M:Lucene.Net.Analysis.StopFilter.GetEnablePositionIncrements">
            <seealso cref="!:setEnablePositionIncrements(boolean).">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.StopFilter.SetEnablePositionIncrements(System.Boolean)" -->
        <member name="T:Lucene.Net.Analysis.Standard.StandardTokenizerImpl">
            <summary> This class is a scanner generated by 
            <a href="http://www.jflex.de/">JFlex</a> 1.4.1
            on 12/18/07 9:22 PM from the specification file
            <tt>/Volumes/User/grantingersoll/projects/lucene/java/lucene-clean/src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex</tt>
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.YYEOF">
            <summary>This character denotes the end of file </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_BUFFERSIZE">
            <summary>initial size of the lookahead buffer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.YYINITIAL">
            <summary>lexical states </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_CMAP_PACKED">
            <summary> Translates characters to character classes</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ACRONYM_DEP">
            <deprecated> this solves a bug where HOSTs that end with '.' are identified
            as ACRONYMs. It is deprecated and will be removed in the next
            release.
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_CMAP">
            <summary> Translates characters to character classes</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_ACTION">
            <summary> Translates DFA states to action switch labels.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_ROWMAP">
            <summary> Translates a state to a row index in the transition table</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_TRANS">
            <summary> The transition table of the DFA</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_ATTRIBUTE">
            <summary> ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code></summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzReader">
            <summary>the input device </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzState">
            <summary>the current state of the DFA </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzLexicalState">
            <summary>the current lexical state </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzBuffer">
            <summary>this buffer contains the current text to be matched and is
            the source of the yytext() string 
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzMarkedPos">
            <summary>the textposition at the last accepting state </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzPushbackPos">
            <summary>the textposition at the last state to be included in yytext </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzCurrentPos">
            <summary>the current text position in the buffer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzStartRead">
            <summary>startRead marks the beginning of the yytext() string in the buffer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzEndRead">
            <summary>endRead marks the last character in the buffer, that has been read
            from input 
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.yyline">
            <summary>number of newlines encountered up to the start of the matched text </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.yychar">
            <summary>the number of characters up to the start of the matched text </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.yycolumn">
            <summary> the number of characters from the last newline up to the start of the 
            matched text
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzAtBOL" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzAtEOF" -->
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.GetText(Lucene.Net.Analysis.Token)">
            <summary> Fills Lucene token with the current token text.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.#ctor(System.IO.TextReader)">
            <summary> Creates a new scanner
            There is also a java.io.InputStream version of this constructor.
            
            </summary>
            <param name="in"> the java.io.Reader to read input from.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.#ctor(System.IO.Stream)">
            <summary> Creates a new scanner.
            There is also java.io.Reader version of this constructor.
            
            </summary>
            <param name="in"> the java.io.Inputstream to read input from.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZzUnpackCMap(System.String)">
            <summary> Unpacks the compressed character translation table.
            
            </summary>
            <param name="packed">  the packed character translation table
            </param>
            <returns>         the unpacked character translation table
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZzRefill">
            <summary> Refills the input buffer.
            
            </summary>
            <returns>      <code>false</code>, iff there was new input.
            
            </returns>
            <exception cref="!:java.io.IOException"> if any I/O-Error occurs
            </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yyclose">
            <summary> Closes the input stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yyreset(System.IO.TextReader)">
            <summary> Resets the scanner to read from a new input stream.
            Does not close the old reader.
            
            All internal variables are reset, the old input stream 
            <b>cannot</b> be reused (internal buffer is discarded and lost).
            Lexical state is set to <tt>ZZ_INITIAL</tt>.
            
            </summary>
            <param name="reader">  the new input stream 
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yystate">
            <summary> Returns the current lexical state.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yybegin(System.Int32)">
            <summary> Enters a new lexical state
            
            </summary>
            <param name="newState">the new lexical state
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yytext">
            <summary> Returns the text matched by the current regular expression.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yycharat(System.Int32)">
            <summary> Returns the character at position <tt>pos</tt> from the 
            matched text. 
            
            It is equivalent to yytext().charAt(pos), but faster
            
            </summary>
            <param name="pos">the position of the character to fetch. 
            A value from 0 to yylength()-1.
            
            </param>
            <returns> the character at position pos
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yylength">
            <summary> Returns the length of the matched text region.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZzScanError(System.Int32)">
            <summary> Reports an error that occured while scanning.
            
            In a wellformed scanner (no or only correct usage of 
            yypushback(int) and a match-all fallback rule) this method 
            will only be called with things that "Can't Possibly Happen".
            If this method is called, something is seriously wrong
            (e.g. a JFlex bug producing a faulty scanner etc.).
            
            Usual syntax/scanner level error handling should be done
            in error fallback rules.
            
            </summary>
            <param name="errorCode"> the code of the errormessage to display
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yypushback(System.Int32)">
            <summary> Pushes the specified amount of characters back into the input stream.
            
            They will be read again by then next call of the scanning method
            
            </summary>
            <param name="number"> the number of characters to be read again.
            This number must not be greater than yylength()!
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.GetNextToken">
            <summary> Resumes scanning until the next regular expression is matched,
            the end of input is encountered or an I/O-Error occurs.
            
            </summary>
            <returns>      the next token
            </returns>
            <exception cref="!:java.io.IOException"> if any I/O-Error occurs
            </exception>
        </member>
        <member name="T:Lucene.Net.Util.ScorerDocQueue">
            <summary>A ScorerDocQueue maintains a partial ordering of its Scorers such that the
            least Scorer can always be found in constant time.  Put()'s and pop()'s
            require log(size) time. The ordering is by Scorer.doc().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.#ctor(System.Int32)">
            <summary>Create a ScorerDocQueue with a maximum size. </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Put(Lucene.Net.Search.Scorer)">
            <summary> Adds a Scorer to a ScorerDocQueue in log(size) time.
            If one tries to add more Scorers than maxSize
            a SystemException (ArrayIndexOutOfBound) is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Insert(Lucene.Net.Search.Scorer)">
            <summary> Adds a Scorer to the ScorerDocQueue in log(size) time if either
            the ScorerDocQueue is not full, or not lessThan(scorer, top()).
            </summary>
            <param name="">scorer
            </param>
            <returns> true if scorer is added, false otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Top">
            <summary>Returns the least Scorer of the ScorerDocQueue in constant time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.TopDoc">
            <summary>Returns document number of the least Scorer of the ScorerDocQueue
            in constant time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Pop">
            <summary>Removes and returns the least scorer of the ScorerDocQueue in log(size)
            time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.PopNoResult">
            <summary>Removes the least scorer of the ScorerDocQueue in log(size) time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.AdjustTop">
            <summary>Should be called when the scorer at top changes doc() value.
            Still log(n) worst case, but it's at least twice as fast to <pre>
            { pq.top().change(); pq.adjustTop(); }
            </pre> instead of <pre>
            { o = pq.pop(); o.change(); pq.push(o); }
            </pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Size">
            <summary>Returns the number of scorers currently stored in the ScorerDocQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Clear">
            <summary>Removes all entries from the ScorerDocQueue. </summary>
        </member>
        <member name="T:Lucene.Net.Store.LockObtainFailedException">
            <summary> This exception is thrown when the <code>write.lock</code>
            could not be acquired.  This
            happens when a writer tries to open an index
            that another writer already has open.
            </summary>
            <seealso cref="!:Lock.obtain(long).">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.BoostingTermQuery" -->
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>Matches spans containing a term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Construct a SpanTermQuery matching the named term's spans. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetTerm">
            <summary>Return the term whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanWeight">
            <summary> Expert-only.  Public for use by other weight implementations</summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanScorer">
            <summary> Public for extension only.</summary>
        </member>
        <member name="T:Lucene.Net.Search.MatchAllDocsQuery">
            <summary> A query that matches all documents.
            
            </summary>
            <author>  John Wang
            </author>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FieldScoreQuery" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ValueSourceQuery" -->
        <member name="M:Lucene.Net.Search.Function.ValueSourceQuery.#ctor(Lucene.Net.Search.Function.ValueSource)">
            <summary> Create a value source query</summary>
            <param name="valSrc">provides the values defines the function to be used for scoring
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSourceQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSourceQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Function.ValueSourceQuery.ValueSourceScorer">
            <summary> A scorer that (simply) matches all documents, and scores each document with 
            the value of the value soure in effect. As an example, if the value source 
            is a (cached) field source, then value of that field in that document will 
            be used. (assuming field is indexed for this doc, with a single token.)   
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.FieldScoreQuery.#ctor(System.String,Lucene.Net.Search.Function.FieldScoreQuery.Type)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FieldScoreQuery.Type" -->
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.BYTE">
            <summary>field values are interpreted as numeric byte values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.SHORT">
            <summary>field values are interpreted as numeric short values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.INT">
            <summary>field values are interpreted as numeric int values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.FLOAT">
            <summary>field values are interpreted as numeric float values. </summary>
        </member>
        <member name="T:Lucene.Net.Index.StaleReaderException">
            <summary> This exception is thrown when an {@link IndexReader}
            tries to make changes to the index (via {@link
            IndexReader#deleteDocument}, {@link
            IndexReader#undeleteAll} or {@link IndexReader#setNorm})
            but changes have already been committed to the index
            since this reader was instantiated.  When this happens
            you must open a new reader on the current index to make
            the changes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter">
            <summary>An <code>IndexWriter</code> creates and maintains an index.
            <p>The <code>create</code> argument to the 
            <a href="#IndexWriter(Lucene.Net.Store.Directory, Lucene.Net.Analysis.Analyzer, boolean)"><b>constructor</b></a>
            determines whether a new index is created, or whether an existing index is
            opened.  Note that you
            can open an index with <code>create=true</code> even while readers are
            using the index.  The old readers will continue to search
            the "point in time" snapshot they had opened, and won't
            see the newly created index until they re-open.  There are
            also <a href="#IndexWriter(Lucene.Net.Store.Directory, Lucene.Net.Analysis.Analyzer)"><b>constructors</b></a>
            with no <code>create</code> argument which
            will create a new index if there is not already an index at the
            provided path and otherwise open the existing index.</p>
            <p>In either case, documents are added with <a
            href="#addDocument(Lucene.Net.Documents.Document)"><b>addDocument</b></a>
            and removed with <a
            href="#deleteDocuments(Lucene.Net.Index.Term)"><b>deleteDocuments</b></a>.
            A document can be updated with <a href="#updateDocument(Lucene.Net.Index.Term, Lucene.Net.Documents.Document)"><b>updateDocument</b></a> 
            (which just deletes and then adds the entire document).
            When finished adding, deleting and updating documents, <a href="#close()"><b>close</b></a> should be called.</p>
            <p>These changes are buffered in memory and periodically
            flushed to the {@link Directory} (during the above method
            calls).  A flush is triggered when there are enough
            buffered deletes (see {@link #setMaxBufferedDeleteTerms})
            or enough added documents since the last flush, whichever
            is sooner.  For the added documents, flushing is triggered
            either by RAM usage of the documents (see {@link
            #setRAMBufferSizeMB}) or the number of added documents.
            The default is to flush when RAM usage hits 16 MB.  For
            best indexing speed you should flush by RAM usage with a
            large RAM buffer.  You can also force a flush by calling
            {@link #flush}.  When a flush occurs, both pending deletes
            and added documents are flushed to the index.  A flush may
            also trigger one or more segment merges which by default
            run with a background thread so as not to block the
            addDocument calls (see <a href="#mergePolicy">below</a>
            for changing the {@link MergeScheduler}).</p>
            <a name="autoCommit"></a>
            <p>The optional <code>autoCommit</code> argument to the
            <a href="#IndexWriter(Lucene.Net.Store.Directory, boolean, Lucene.Net.Analysis.Analyzer)"><b>constructors</b></a>
            controls visibility of the changes to {@link IndexReader} instances reading the same index.
            When this is <code>false</code>, changes are not
            visible until {@link #Close()} is called.
            Note that changes will still be flushed to the
            {@link Lucene.Net.Store.Directory} as new files,
            but are not committed (no new <code>segments_N</code> file
            is written referencing the new files) until {@link #close} is
            called.  If something goes terribly wrong (for example the
            JVM crashes) before {@link #Close()}, then
            the index will reflect none of the changes made (it will
            remain in its starting state).
            You can also call {@link #Abort()}, which closes the writer without committing any
            changes, and removes any index
            files that had been flushed but are now unreferenced.
            This mode is useful for preventing readers from refreshing
            at a bad time (for example after you've done all your
            deletes but before you've done your adds).
            It can also be used to implement simple single-writer
            transactional semantics ("all or none").</p>
            <p>When <code>autoCommit</code> is <code>true</code> then
            every flush is also a commit ({@link IndexReader}
            instances will see each flush as changes to the index).
            This is the default, to match the behavior before 2.2.
            When running in this mode, be careful not to refresh your
            readers while optimize or segment merges are taking place
            as this can tie up substantial disk space.</p>
            </summary>
            <summary><p>Regardless of <code>autoCommit</code>, an {@link
            IndexReader} or {@link Lucene.Net.Search.IndexSearcher} will only see the
            index as of the "point in time" that it was opened.  Any
            changes committed to the index after the reader was opened
            are not visible until the reader is re-opened.</p>
            <p>If an index will not have more documents added for a while and optimal search
            performance is desired, then the <a href="#optimize()"><b>optimize</b></a>
            method should be called before the index is closed.</p>
            <p>Opening an <code>IndexWriter</code> creates a lock file for the directory in use. Trying to open
            another <code>IndexWriter</code> on the same directory will lead to a
            {@link LockObtainFailedException}. The {@link LockObtainFailedException}
            is also thrown if an IndexReader on the same directory is used to delete documents
            from the index.</p>
            </summary>
            <summary><a name="deletionPolicy"></a>
            <p>Expert: <code>IndexWriter</code> allows an optional
            {@link IndexDeletionPolicy} implementation to be
            specified.  You can use this to control when prior commits
            are deleted from the index.  The default policy is {@link
            KeepOnlyLastCommitDeletionPolicy} which removes all prior
            commits as soon as a new commit is done (this matches
            behavior before 2.2).  Creating your own policy can allow
            you to explicitly keep previous "point in time" commits
            alive in the index for some time, to allow readers to
            refresh to the new commit without having the old commit
            deleted out from under them.  This is necessary on
            filesystems like NFS that do not support "delete on last
            close" semantics, which Lucene's "point in time" search
            normally relies on. </p>
            <a name="mergePolicy"></a> <p>Expert:
            <code>IndexWriter</code> allows you to separately change
            the {@link MergePolicy} and the {@link MergeScheduler}.
            The {@link MergePolicy} is invoked whenever there are
            changes to the segments in the index.  Its role is to
            select which merges to do, if any, and return a {@link
            MergePolicy.MergeSpecification} describing the merges.  It
            also selects merges to do for optimize().  (The default is
            {@link LogByteSizeMergePolicy}.  Then, the {@link
            MergeScheduler} is invoked with the requested merges and
            it decides when and how to run the merges.  The default is
            {@link ConcurrentMergeScheduler}. </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME">
            <summary> Name of the write lock in the index.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DISABLE_AUTO_FLUSH">
            <summary> Value to denote a flush trigger is disabled</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_RAM_BUFFER_SIZE_MB">
            <summary> Default value is 16 MB (which means flush when buffered
            docs consume 16 MB RAM).  Change using {@link #setRAMBufferSizeMB}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH">
            <summary> Default value is 10,000. Change using {@link #SetMaxFieldLength(int)}.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL">
            <summary> Default value is 128. Change using {@link #SetTermIndexInterval(int)}.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_TIMEOUT">
            <summary> Default value for the write lock timeout (1,000).</summary>
            <seealso cref="!:setDefaultWriteLockTimeout">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MERGE_FACTOR">
            <deprecated>
            </deprecated>
            <seealso cref="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DOCS">
            <summary> Disabled by default (because IndexWriter flushes by RAM usage
            by default). Change using {@link #SetMaxBufferedDocs(int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DELETE_TERMS">
            <summary> Disabled by default (because IndexWriter flushes by RAM usage
            by default). Change using {@link #SetMaxBufferedDeleteTerms(int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_MERGE_DOCS">
            <deprecated>
            </deprecated>
            <seealso cref="!:LogDocMergePolicy.DEFAULT_MAX_MERGE_DOCS">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH">
            <summary> Absolute hard maximum length for a term.  If a term
            arrives from the analyzer longer than this length, it
            is skipped and a message is printed to infoStream, if
            set (see {@link #setInfoStream}).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen">
            <summary> Used internally to throw an {@link
            AlreadyClosedException} if this IndexWriter has been
            closed.
            </summary>
            <throws>  AlreadyClosedException if this IndexWriter is </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Message(System.String)">
            <summary> Prints a message to the infoStream (if non-null),
            prefixed with the identifying information for this
            writer and the thread that's calling it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetLogMergePolicy">
            <summary> Casts current mergePolicy to LogMergePolicy, and throws
            an exception if the mergePolicy is not a LogMergePolicy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetUseCompoundFile">
            <summary><p>Get the current setting of whether newly flushed
            segments will use the compound file format.  Note that
            this just returns the value previously set with
            setUseCompoundFile(boolean), or the default value
            (true).  You cannot use this to query the status of
            previously flushed segments.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.getUseCompoundFile as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an IllegalArgumentException is thrown.</p>
            
            </summary>
            <seealso cref="!:SetUseCompoundFile(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetUseCompoundFile(System.Boolean)">
            <summary><p>Setting to turn on usage of a compound file. When on,
            multiple files for each segment are merged into a
            single file when a new segment is flushed.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.setUseCompoundFile as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an IllegalArgumentException is thrown.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this IndexWriter.
            
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarity.SetDefault(Lucene.Net.Search.Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.GetSimilarity" -->
        <member name="M:Lucene.Net.Index.IndexWriter.SetTermIndexInterval(System.Int32)">
            <summary>Expert: Set the interval between indexed terms.  Large values cause less
            memory to be used by IndexReader, but slow random-access to terms.  Small
            values cause more memory to be used by an IndexReader, and speed
            random-access to terms.
            
            This parameter determines the amount of computation required per query
            term, regardless of the number of documents that contain that term.  In
            particular, it is the maximum number of other terms that must be
            scanned before a term is located and its frequency and position information
            may be processed.  In a large index with user-entered query terms, query
            processing time is likely to be dominated not by term lookup but rather
            by the processing of frequency and positional data.  In a small index
            or when many uncommon query terms are generated (e.g., by wildcard
            queries) term lookup may become a dominant cost.
            
            In particular, <code>numUniqueTerms/interval</code> terms are read into
            memory by an IndexReader, and, on average, <code>interval/2</code> terms
            must be scanned for each random term access.
            
            </summary>
            <seealso cref="F:Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetTermIndexInterval">
            <summary>Expert: Return the interval between indexed terms.
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.SetTermIndexInterval(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist and <code>create</code> is
            <code>false</code> or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist and <code>create</code> is
            <code>false</code> or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>d</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist and <code>create</code> is
            <code>false</code> or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs an IndexWriter for the index in
            <code>path</code>, first creating it if it does not
            already exist.  Text will be analyzed with
            <code>a</code>.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be </throws>
            <summary>  read/written to or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs an IndexWriter for the index in
            <code>path</code>, first creating it if it does not
            already exist.  Text will be analyzed with
            <code>a</code>.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be </throws>
            <summary>  read/written to or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs an IndexWriter for the index in
            <code>d</code>, first creating it if it does not
            already exist.  Text will be analyzed with
            <code>a</code>.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be </throws>
            <summary>  read/written to or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs an IndexWriter for the index in
            <code>d</code>, first creating it if it does not
            already exist.  Text will be analyzed with
            <code>a</code>.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="autoCommit">see <a href="#autoCommit">above</a>
            </param>
            <param name="a">the analyzer to use
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be </throws>
            <summary>  read/written to or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>d</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="autoCommit">see <a href="#autoCommit">above</a>
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist and <code>create</code> is
            <code>false</code> or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary> Expert: constructs an IndexWriter with a custom {@link
            IndexDeletionPolicy}, for the index in <code>d</code>,
            first creating it if it does not already exist.  Text
            will be analyzed with <code>a</code>.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="autoCommit">see <a href="#autoCommit">above</a>
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="deletionPolicy">see <a href="#deletionPolicy">above</a>
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be </throws>
            <summary>  read/written to or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer,System.Boolean,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary> Expert: constructs an IndexWriter with a custom {@link
            IndexDeletionPolicy}, for the index in <code>d</code>.
            Text will be analyzed with <code>a</code>.  If
            <code>create</code> is true, then a new, empty index
            will be created in <code>d</code>, replacing the index
            already there, if any.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="autoCommit">see <a href="#autoCommit">above</a>
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <param name="deletionPolicy">see <a href="#deletionPolicy">above</a>
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist and <code>create</code> is
            <code>false</code> or if there is any other low-level
            IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMergePolicy(Lucene.Net.Index.MergePolicy)">
            <summary> Expert: set the merge policy used by this writer.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergePolicy">
            <summary> Expert: returns the current MergePolicy in use by this writer.</summary>
            <seealso cref="!:setMergePolicy">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMergeScheduler(Lucene.Net.Index.MergeScheduler)">
            <summary> Expert: set the merge scheduler used by this writer.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergeScheduler">
            <summary> Expert: returns the current MergePolicy in use by this
            writer.
            </summary>
            <seealso cref="!:setMergePolicy">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxMergeDocs(System.Int32)">
            <summary><p>Determines the largest segment (measured by
            document count) that may be merged with other segments.
            Small values (e.g., less than 10,000) are best for
            interactive indexing, as this limits the length of
            pauses while indexing to a few seconds.  Larger values
            are best for batched indexing and speedier
            searches.</p>
            
            <p>The default value is {@link Integer#MAX_VALUE}.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.setMaxMergeDocs as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an IllegalArgumentException is thrown.</p>
            
            <p>The default merge policy ({@link
            LogByteSizeMergePolicy}) also allows you to set this
            limit by net size (in MB) of the segment, using {@link
            LogByteSizeMergePolicy#setMaxMergeMB}.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxMergeDocs">
            <summary> <p>Returns the largest segment (measured by document
            count) that may be merged with other segments.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.getMaxMergeDocs as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an IllegalArgumentException is thrown.</p>
            
            </summary>
            <seealso cref="!:setMaxMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxFieldLength(System.Int32)">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.  This setting refers to the number of running terms,
            not to the number of different terms.<p/>
            <strong>Note:</strong> this silently truncates large documents, excluding from the
            index all terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxFieldLength">
            <summary> Returns the maximum number of terms that will be
            indexed for a single field in a document.
            </summary>
            <seealso cref="!:setMaxFieldLength">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxBufferedDocs(System.Int32)">
            <summary>Determines the minimal number of documents required
            before the buffered in-memory documents are flushed as
            a new Segment.  Large values generally gives faster
            indexing.
            
            <p>When this is set, the writer will flush every
            maxBufferedDocs added documents.  Pass in {@link
            #DISABLE_AUTO_FLUSH} to prevent triggering a flush due
            to number of buffered documents.  Note that if flushing
            by RAM usage is also enabled, then the flush will be
            triggered by whichever comes first.</p>
            
            <p>Disabled by default (writer flushes by RAM usage).</p>
            
            </summary>
            <throws>  IllegalArgumentException if maxBufferedDocs is </throws>
            <summary> enabled but smaller than 2, or it disables maxBufferedDocs
            when ramBufferSize is already disabled
            </summary>
            <seealso cref="!:setRAMBufferSizeMB">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PushMaxBufferedDocs">
            <summary> If we are flushing by doc count (not by RAM usage), and
            using LogDocMergePolicy then push maxBufferedDocs down
            as its minMergeDocs, to keep backwards compatibility.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxBufferedDocs">
            <summary> Returns the number of buffered added documents that will
            trigger a flush if enabled.
            </summary>
            <seealso cref="!:setMaxBufferedDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB(System.Double)">
            <summary>Determines the amount of RAM that may be used for
            buffering added documents before they are flushed as a
            new Segment.  Generally for faster indexing performance
            it's best to flush by RAM usage instead of document
            count and use as large a RAM buffer as you can.
            
            <p>When this is set, the writer will flush whenever
            buffered documents use this much RAM.  Pass in {@link
            #DISABLE_AUTO_FLUSH} to prevent triggering a flush due
            to RAM usage.  Note that if flushing by document count
            is also enabled, then the flush will be triggered by
            whichever comes first.</p>
            
            <p> The default value is {@link #DEFAULT_RAM_BUFFER_SIZE_MB}.</p>
            
            </summary>
            <throws>  IllegalArgumentException if ramBufferSize is </throws>
            <summary> enabled but non-positive, or it disables ramBufferSize
            when maxBufferedDocs is already disabled
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetRAMBufferSizeMB">
            <summary> Returns the value set by {@link #setRAMBufferSizeMB} if enabled.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms(System.Int32)">
            <summary> <p>Determines the minimal number of delete terms required before the buffered
            in-memory delete terms are applied and flushed. If there are documents
            buffered in memory at the time, they are merged and a new segment is
            created.</p>
            <p>Disabled by default (writer flushes by RAM usage).</p>
            
            </summary>
            <throws>  IllegalArgumentException if maxBufferedDeleteTerms </throws>
            <summary> is enabled but smaller than 1
            </summary>
            <seealso cref="!:setRAMBufferSizeMB">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxBufferedDeleteTerms">
            <summary> Returns the number of buffered deleted terms that will
            trigger a flush if enabled.
            </summary>
            <seealso cref="!:setMaxBufferedDeleteTerms">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergeFactor">
            <summary> <p>Returns the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.getMergeFactor as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an IllegalArgumentException is thrown.</p>
            
            </summary>
            <seealso cref="!:setMergeFactor">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetDefaultInfoStream(System.IO.TextWriter)">
            <summary>If non-null, this will be the default infoStream used
            by a newly instantiated IndexWriter.
            </summary>
            <seealso cref="!:setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDefaultInfoStream">
            <summary> Returns the current default infoStream for newly
            instantiated IndexWriters.
            </summary>
            <seealso cref="!:setDefaultInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetInfoStream(System.IO.TextWriter)">
            <summary>If non-null, information about merges, deletes and a
            message when maxFieldLength is reached will be printed
            to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetInfoStream">
            <summary> Returns the current infoStream in use by this writer.</summary>
            <seealso cref="!:setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetWriteLockTimeout(System.Int64)">
            <seealso cref="!:">
            </seealso>
            <seealso cref="!:setDefaultWriteLockTimeout to change the default value for all instances of IndexWriter.">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetWriteLockTimeout">
            <summary> Returns allowed timeout when acquiring the write lock.</summary>
            <seealso cref="!:setWriteLockTimeout">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetDefaultWriteLockTimeout(System.Int64)">
            <summary> Sets the default (for any instance of IndexWriter) maximum time to wait for a write lock (in
            milliseconds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDefaultWriteLockTimeout">
            <summary> Returns default write lock timeout for newly
            instantiated IndexWriters.
            </summary>
            <seealso cref="!:setDefaultWriteLockTimeout">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Close" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Close(System.Boolean)">
            <summary> Closes the index with or without waiting for currently
            running merges to finish.  This is only meaningful when
            using a MergeScheduler that runs merges in background
            threads.
            </summary>
            <param name="waitForMerges">if true, this call will block
            until all merges complete; else, it will ask all
            running merges to abort, wait until those merges have
            finished (which should be at most a few seconds), and
            then return.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.FlushDocStores" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDirectory">
            <summary>Returns the Directory used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetAnalyzer">
            <summary>Returns the analyzer used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DocCount">
            <summary>Returns the number of documents currently in this index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.maxFieldLength">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a field.
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Adds a document to this index, using the provided analyzer instead of the
            value of {@link #GetAnalyzer()}.  If the document contains more than
            {@link #SetMaxFieldLength(int)} terms for a given field, the remainder are
            discarded.
            
            <p>See {@link #AddDocument(Document)} for details on
            index and IndexWriter state after an Exception, and
            flushing/merging temporary free space requirements.</p>
            
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary> Deletes the document(s) containing <code>term</code>.</summary>
            <param name="term">the term to identify the documents to be deleted
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
            <summary> Deletes the document(s) containing any of the
            terms. All deletes are flushed at the same time.
            </summary>
            <param name="terms">array of terms to identify the documents
            to be deleted
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,Lucene.Net.Documents.Document)">
            <summary> Updates a document by first deleting the document(s)
            containing <code>term</code> and then adding the new
            document.  The delete and then add are atomic as seen
            by a reader on the same index (flush may happen only after
            the add).
            </summary>
            <param name="term">the term to identify the document(s) to be
            deleted
            </param>
            <param name="doc">the document to be added
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Updates a document by first deleting the document(s)
            containing <code>term</code> and then adding the new
            document.  The delete and then add are atomic as seen
            by a reader on the same index (flush may happen only after
            the add).
            </summary>
            <param name="term">the term to identify the document(s) to be
            deleted
            </param>
            <param name="doc">the document to be added
            </param>
            <param name="analyzer">the analyzer to use when analyzing the document
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>If non-null, information about merges will be printed to this.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Optimize" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Optimize(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Optimize(System.Boolean)">
            <summary>Just like {@link #Optimize()}, except you can specify
            whether the call should block until the optimize
            completes.  This is only meaningful with a
            {@link MergeScheduler} that is able to run merges in
            background threads. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Optimize(System.Int32,System.Boolean)">
            <summary>Just like {@link #Optimize(int)}, except you can
            specify whether the call should block until the
            optimize completes.  This is only meaningful with a
            {@link MergeScheduler} that is able to run merges in
            background threads. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.OptimizeMergesPending">
            <summary>Returns true if any merges in pendingMerges or
            runningMerges are optimization merges. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMerge">
            <summary> Expert: asks the mergePolicy whether any merges are
            necessary now and if so, runs the requested merges and
            then iterate (test again if merges are needed) until no
            more merges are returned by the mergePolicy.
            
            Explicit calls to maybeMerge() are usually not
            necessary. The most common case is when merge policy
            parameters have changed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetNextMerge">
            <summary>Expert: the {@link MergeScheduler} calls this method
            to retrieve the next merge requested by the
            MergePolicy 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Abort">
            <summary> Close the <code>IndexWriter</code> without committing
            any of the changes that have occurred since it was
            opened. This removes any temporary files that had been
            created, after which the state of the index will be the
            same as it was when this writer was first opened.  This
            can only be called when this IndexWriter was opened
            with <code>autoCommit=false</code>.
            </summary>
            <throws>  IllegalStateException if this is called when </throws>
            <summary>  the writer was opened with <code>autoCommit=true</code>.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexesNoOptimize(Lucene.Net.Store.Directory[])" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
            <summary>Merges the provided indexes into this index.
            <p>After this completes, the index is optimized. </p>
            <p>The provided IndexReaders are not closed.</p>
            
            <p><b>NOTE:</b> the index in each Directory must not be
            changed (opened by a writer) while this method is
            running.  Thiw method does not acquire a write lock in
            each input Directory, so it is up to the caller to
            enforce this.
            </p>
            
            <p><b>NOTE:</b> while this is running, any attempts to
            add or delete documents (with another thread) will be 
            paused until this method completes.</p>
            
            <p>See {@link #AddIndexes(Directory[])} for
            details on transactional semantics, temporary free
            space required in the Directory, and non-CFS segments
            on an Exception.</p>
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Flush" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean)">
            <summary> Flush all in-memory buffered udpates (adds and deletes)
            to the Directory.
            </summary>
            <param name="triggerMerge">if true, we may merge segments (if
            deletes or docs were flushed) if necessary
            </param>
            <param name="flushDocStores">if false we are allowed to keep
            doc stores open to share with the next segment
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RamSizeInBytes">
            <summary>Expert:  Return the total size of all index files currently cached in memory.
            Useful for size management with flushRamDocs()
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumRamDocs">
            <summary>Expert:  Return the number of documents whose segments are currently cached in memory.
            Useful when calling flush()
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary> Merges the indicated segments, replacing them in the stack with a
            single segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RegisterMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>Checks whether this merge involves any segments
            already participating in a merge.  If not, this merge
            is "registered", meaning we record that its segments
            are now participating in a merge, and true is
            returned.  Else (the merge conflicts) false is
            returned. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeInit(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>Does initial setup for a merge, which is fast but holds
            the synchronized lock on IndexWriter instance. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeFinish(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>Does fininishing for a merge, which is fast but holds
            the synchronized lock on IndexWriter instance. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeMiddle(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>Does the actual (time-consuming) work of the merge,
            but without holding synchronized lock on IndexWriter
            instance 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DefaultSkipListWriter">
            <summary> Implements the skip list writer for the default posting list format
            that stores positions and payloads.
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiLevelSkipListWriter">
            <summary> This abstract class writes skip lists with multiple levels.
            
            Example for skipInterval = 3:
            c            (skip level 2)
            c                 c                 c            (skip level 1) 
            x     x     x     x     x     x     x     x     x     x      (skip level 0)
            d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  (posting list)
            3     6     9     12    15    18    21    24    27    30     (df)
            
            d - document
            x - skip data
            c - skip data with child pointer
            
            Skip level i contains every skipInterval-th entry from skip level i-1.
            Therefore the number of entries on level i is: floor(df / ((skipInterval ^ (i + 1))).
            
            Each skip entry on a level i>0 contains a pointer to the corresponding skip entry in list i-1.
            This guarantess a logarithmic amount of skips to find the target document.
            
            While this class takes care of writing the different skip levels,
            subclasses must define the actual format of the skip data.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListWriter.WriteSkipData(System.Int32,Lucene.Net.Store.IndexOutput)">
            <summary> Subclasses must implement the actual skip data encoding in this method.
            
            </summary>
            <param name="level">the level skip data shall be writting for
            </param>
            <param name="skipBuffer">the skip buffer to write to
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListWriter.BufferSkip(System.Int32)">
            <summary> Writes the current skip data to the buffers. The current document frequency determines
            the max level is skip data is to be written to. 
            
            </summary>
            <param name="df">the current document frequency 
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListWriter.WriteSkip(Lucene.Net.Store.IndexOutput)">
            <summary> Writes the buffered skip lists to the given output.
            
            </summary>
            <param name="output">the IndexOutput the skip lists shall be written to 
            </param>
            <returns> the pointer the skip list starts
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListWriter.SetSkipData(System.Int32,System.Boolean,System.Int32)">
            <summary> Sets the values for the current skip data. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DefaultSkipListReader">
            <summary> Implements the skip list reader for the default posting list format
            that stores positions and payloads.
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiLevelSkipListReader">
            <summary> This abstract class reads skip lists with multiple levels.
            
            See {@link MultiLevelSkipListWriter} for the information about the encoding 
            of the multi level skip lists. 
            
            Subclasses must implement the abstract method {@link #ReadSkipData(int, IndexInput)}
            which defines the actual format of the skip data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.GetDoc">
            <summary>Returns the id of the doc to which the last call of {@link #SkipTo(int)}
            has skipped.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.SkipTo(System.Int32)">
            <summary>Skips entries to the first beyond the current whose document number is
            greater than or equal to <i>target</i>. Returns the current doc count. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.SeekChild(System.Int32)">
            <summary>Seeks the skip entry on the given level </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.Init(System.Int64,System.Int32)">
            <summary>initializes the reader </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.LoadSkipLevels">
            <summary>Loads the skip levels  </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.ReadSkipData(System.Int32,Lucene.Net.Store.IndexInput)">
            <summary> Subclasses must implement the actual skip data encoding in this method.
            
            </summary>
            <param name="level">the level skip data shall be read from
            </param>
            <param name="skipStream">the skip stream to read from
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.SetLastSkipData(System.Int32)">
            <summary>Copies the values of the last read skip entry on this level </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiLevelSkipListReader.SkipBuffer">
            <summary>used to buffer the top skip levels </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListReader.GetFreqPointer">
            <summary>Returns the freq pointer of the doc to which the last call of 
            {@link MultiLevelSkipListReader#SkipTo(int)} has skipped.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListReader.GetProxPointer">
            <summary>Returns the prox pointer of the doc to which the last call of 
            {@link MultiLevelSkipListReader#SkipTo(int)} has skipped.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListReader.GetPayloadLength">
            <summary>Returns the payload length of the payload stored just before 
            the doc to which the last call of {@link MultiLevelSkipListReader#SkipTo(int)} 
            has skipped.  
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler">
            <summary>A {@link MergeScheduler} that runs each merge using a
            separate thread, up until a maximum number of threads
            ({@link #setMaxThreadCount}) at which points merges are
            run in the foreground, serially.  This is a simple way
            to use concurrency in the indexing process without
            having to create and manage application level
            threads. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeScheduler">
            <summary>Expert: {@link IndexWriter} uses an instance
            implementing this interface to execute the merges
            selected by a {@link MergePolicy}.  The default
            MergeScheduler is {@link ConcurrentMergeScheduler}.
            <p><b>NOTE:</b> This API is new and still experimental
            (subject to change suddenly in the next release)</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Merge(Lucene.Net.Index.IndexWriter)">
            <summary>Run the merges provided by {@link IndexWriter#GetNextMerge()}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Close">
            <summary>Close this MergeScheduler. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxThreadCount(System.Int32)">
            <summary>Sets the max # simultaneous threads that may be
            running.  If a merge is necessary yet we already have
            this many threads running, the merge is returned back
            to IndexWriter so that it runs in the "foreground". 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMaxThreadCount">
            <summary>Get the max # simultaneous threads that may be</summary>
            <seealso cref="!:setMaxThreadCount.">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMergeThreadPriority">
            <summary>Return the priority that merge threads run at.  By
            default the priority is 1 plus the priority of (ie,
            slightly higher priority than) the first thread that
            calls merge. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMergeThreadPriority(System.Int32)">
            <summary>Return the priority that merge threads run at. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.AnyUnhandledExceptions">
            <summary>Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.AddMyself">
            <summary>Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetSuppressExceptions">
            <summary>Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.ClearSuppressExceptions">
            <summary>Used for testing </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.allInstances">
            <summary>Used for testing </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Fieldable">
            <summary> Synonymous with {@link Field}.
            
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Fieldable.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Fieldable.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Fieldable.Name">
            <summary>Returns the name of the field as an interned string.
            For example "date", "title", "body", ...
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader value,
            String value, or TokenStream value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.TokenStreamValue">
            <summary>The value of the field as a TokenStream, or null.  If null, the Reader value,
            String value, or binary value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsStored">
            <summary>True iff the value of the field is to be stored in the index for return
            with search hits.  It is an error for this to be true if a field is
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsIndexed">
            <summary>True iff the value of the field is to be indexed, so that it may be
            searched on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsTokenized">
            <summary>True iff the value of the field should be tokenized as text prior to
            indexing.  Un-tokenized fields are indexed as a single word and may not be
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsCompressed">
            <summary>True if the value of the field is stored and compressed within the index </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsTermVectorStored">
            <summary>True iff the term or terms used to index this field are stored as a term
            vector, available from {@link Lucene.Net.Index.IndexReader#GetTermFreqVector(int,String)}.
            These methods do not provide access to the original content of the field,
            only to terms used to index it. If the original content must be
            preserved, use the <code>stored</code> attribute instead.
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsStoreOffsetWithTermVector">
            <summary> True iff terms are stored as term vector together with their offsets 
            (start and end positon in source text).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsStorePositionWithTermVector">
            <summary> True iff terms are stored as term vector together with their token positions.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsBinary">
            <summary>True iff the value of the filed is stored as binary </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetOmitNorms">
            <summary>True if norms are omitted for this indexed field </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.SetOmitNorms(System.Boolean)">
            <summary>Expert:
            
            If set, omit normalization factors associated with this indexed field.
            This effectively disables indexing boosts and length normalization for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsLazy">
            <summary> Indicates whether a Field is Lazy or not.  The semantics of Lazy loading are such that if a Field is lazily loaded, retrieving
            it's values via {@link #StringValue()} or {@link #BinaryValue()} is only valid as long as the {@link Lucene.Net.Index.IndexReader} that
            retrieved the {@link Document} is still open.
            
            </summary>
            <returns> true if this field can be loaded lazily
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.CharArraySet">
            <summary> A simple class that stores Strings as char[]'s in a
            hash table.  Note that this is not a general purpose
            class.  For example, it cannot remove items from the
            set, nor does it resize its hash table to be smaller,
            etc.  It is designed to be quick to test if a char[]
            is in the set without the necessity of converting it
            to a String first.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.#ctor(System.Int32,System.Boolean)">
            <summary>Create set with enough capacity to hold startSize
            terms 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.#ctor(System.Collections.ICollection,System.Boolean)">
            <summary>Create set from a Collection of char[] or String </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.Contains(System.Char[],System.Int32,System.Int32)">
            <summary>true if the <code>len</code> chars of <code>text</code> starting at <code>off</code>
            are in the set 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.Add(System.String)">
            <summary>Add this String into the set </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.Add(System.Char[])">
            <summary>Add this char[] directly to the set.
            If ignoreCase is true for this Set, the text array will be directly modified.
            The user should never modify this text array after calling this method.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.CharArraySet.CharArraySetIterator" -->
        <member name="M:Lucene.Net.Analysis.CharArraySet.CharArraySetIterator.NextCharArray">
            <summary>do not modify the returned char[] </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.CharArraySet.CharArraySetIterator.Current" -->
        <member name="T:Lucene.Net.Util.PriorityQueue">
            <summary>A PriorityQueue maintains a partial ordering of its elements such that the
            least element can always be found in constant time.  Put()'s and pop()'s
            require log(size) time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.LessThan(System.Object,System.Object)">
            <summary>Determines the ordering of objects in this priority queue.  Subclasses
            must define this one method. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Initialize(System.Int32)">
            <summary>Subclass constructors must call this. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Put(System.Object)">
            <summary> Adds an Object to a PriorityQueue in log(size) time.
            If one tries to add more objects than maxSize from initialize
            a RuntimeException (ArrayIndexOutOfBound) is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Insert(System.Object)">
            <summary> Adds element to the PriorityQueue in log(size) time if either
            the PriorityQueue is not full, or not lessThan(element, top()).
            </summary>
            <param name="element">
            </param>
            <returns> true if element is added, false otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.InsertWithOverflow(System.Object)">
            <summary> insertWithOverflow() is the same as insert() except its
            return value: it returns the object (if any) that was
            dropped off the heap because it was full. This can be
            the given parameter (in case it is smaller than the
            full heap's minimum, and couldn't be added), or another
            object that was previously the smallest value in the
            heap and now has been replaced by a larger one, or null
            if the queue wasn't yet full with maxSize elements.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Top">
            <summary>Returns the least element of the PriorityQueue in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Pop">
            <summary>Removes and returns the least element of the PriorityQueue in log(size)
            time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.AdjustTop">
            <summary>Should be called when the Object at top changes values.  Still log(n)
            worst case, but it's at least twice as fast to <pre>
            { pq.top().change(); pq.adjustTop(); }
            </pre> instead of <pre>
            { o = pq.pop(); o.change(); pq.push(o); }
            </pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Size">
            <summary>Returns the number of elements currently stored in the PriorityQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Clear">
            <summary>Removes all entries from the PriorityQueue. </summary>
        </member>
        <member name="T:Lucene.Net.Store.SingleInstanceLockFactory">
            <summary> Implements {@link LockFactory} for a single in-process instance,
            meaning all locking will take place through this one instance.
            Only use this {@link LockFactory} when you are certain all
            IndexReaders and IndexWriters for a given index are running
            against a single shared in-process Directory instance.  This is
            currently the default locking for RAMDirectory.
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Store.AlreadyClosedException">
            <summary> This exception is thrown when there is an attempt to
            access something that has already been closed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortField" -->
        <member name="F:Lucene.Net.Search.SortField.SCORE">
            <summary>Sort by document score (relevancy).  Sort values are Float and higher
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.DOC">
            <summary>Sort by document number (index order).  Sort values are Integer and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.AUTO">
            <summary>Guess type of sort based on field contents.  A regular expression is used
            to look at the first term indexed for the field and determine if it
            represents an integer number, a floating point number, or just arbitrary
            string characters. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING">
            <summary>Sort using term values as Strings.  Sort values are String and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.INT">
            <summary>Sort using term values as encoded Integers.  Sort values are Integer and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FLOAT">
            <summary>Sort using term values as encoded Floats.  Sort values are Float and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.LONG">
            <summary>Sort using term values as encoded Longs.  Sort values are Long and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.DOUBLE">
            <summary>Sort using term values as encoded Doubles.  Sort values are Double and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.CUSTOM">
            <summary>Sort using a custom Comparator.  Sort values are any Comparable and
            sorting is done according to natural order. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>Represents sorting by document score (relevancy). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String)">
            <summary>Creates a sort by terms in the given field where the type of term value
            is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="field">Name of field to sort by, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given field where
            the type of term value is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="field">Name of field to sort by, cannot be <code>null</code>.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32)">
            <summary>Creates a sort by terms in the given field with the type of term
            values explicitly given.
            </summary>
            <param name="field"> Name of field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given field with the
            type of term values explicitly given.
            </summary>
            <param name="field"> Name of field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>Creates a sort by terms in the given field sorted
            according to the given locale.
            </summary>
            <param name="field"> Name of field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given field sorted
            according to the given locale.
            </summary>
            <param name="field"> Name of field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource)">
            <summary>Creates a sort with a custom comparison function.</summary>
            <param name="field">Name of field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, with a custom comparison function.</summary>
            <param name="field">Name of field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetField">
            <summary>Returns the name of the field.  Could return <code>null</code>
            if the sort is by SCORE or DOC.
            </summary>
            <returns> Name of field, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetType">
            <summary>Returns the type of contents in the field.</summary>
            <returns> One of the constants SCORE, DOC, AUTO, STRING, INT or FLOAT.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetLocale">
            <summary>Returns the Locale by which term values are interpreted.
            May return <code>null</code> if no Locale was specified.
            </summary>
            <returns> Locale, or <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetReverse">
            <summary>Returns whether the sort should be reversed.</summary>
            <returns>  True if natural order should be reversed.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoreDocComparator_Fields" -->
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.RELEVANCE">
            <summary>Special comparator for sorting hits according to computed relevance (document score). </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.INDEXORDER">
            <summary>Special comparator for sorting hits according to index order (document number). </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PhraseScorer" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseScorer.PhraseFreq" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PhraseQuery" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>Constructs an empty phrase query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseQuery.SetSlop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.GetSlop">
            <summary>Returns the slop.  See setSlop(). </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term within the phrase is specified explicitly.
            This allows e.g. phrases with more than one term at the same position
            or phrases with gaps (e.g. in connection with stopwords).
            
            </summary>
            <param name="">term
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetTerms">
            <summary>Returns the set of terms in this phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ExtractTerms(System.Collections.Hashtable)">
            <seealso cref="!:Lucene.Net.Search.Query#ExtractTerms(java.util.Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexModifier" -->
        <member name="M:Lucene.Net.Index.IndexModifier.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Open an index with write access.
            
            </summary>
            <param name="directory">the index directory
            </param>
            <param name="analyzer">the analyzer to use for adding new documents
            </param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one;
            <code>false</code> to append to the existing index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Open an index with write access.
            
            </summary>
            <param name="dirName">the index directory
            </param>
            <param name="analyzer">the analyzer to use for adding new documents
            </param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one;
            <code>false</code> to append to the existing index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Open an index with write access.
            
            </summary>
            <param name="file">the index directory
            </param>
            <param name="analyzer">the analyzer to use for adding new documents
            </param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one;
            <code>false</code> to append to the existing index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Init(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Initialize an IndexWriter.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.AssureOpen">
            <summary> Throw an IllegalStateException if the index is closed.</summary>
            <throws>  IllegalStateException </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.CreateIndexWriter">
            <summary> Close the IndexReader and open an IndexWriter.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.CreateIndexReader">
            <summary> Close the IndexWriter and open an IndexReader.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Flush">
            <summary> Make sure all changes are written to disk.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Adds a document to this index, using the provided analyzer instead of the
            one specific in the constructor.  If the document contains more than
            {@link #SetMaxFieldLength(int)} terms for a given field, the remainder are
            discarded.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.AddDocument(Lucene.Net.Documents.Document)">
            <summary> Adds a document to this index.  If the document contains more than
            {@link #SetMaxFieldLength(int)} terms for a given field, the remainder are
            discarded.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary> Deletes all documents containing <code>term</code>.
            This is useful if one uses a document field to hold a unique ID string for
            the document.  Then to delete such a document, one merely constructs a
            term with the appropriate field and the unique ID string as its text and
            passes it to this method.  Returns the number of documents deleted.
            </summary>
            <returns> the number of documents deleted
            </returns>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DeleteDocuments(Lucene.Net.Index.Term)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.DeleteDocument(System.Int32)">
            <summary> Deletes the document numbered <code>docNum</code>.</summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DeleteDocument(System.Int32)">
            </seealso>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.DocCount">
            <summary>
            Returns the number of documents currently in this index.  If the writer is currently open,
            this returns IndexWriter.DocCount(), else IndexReader.NumDocs().  But, note that
            IndexWriter.DocCount() does not take deltions into account, unlike IndexReader.NumDocs().
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.DocCount">
            </seealso>
            <seealso cref="M:Lucene.Net.Index.IndexReader.NumDocs">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Optimize">
            <summary> Merges all segments together into a single segment, optimizing an index
            for search.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.Optimize">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexModifier.SetInfoStream(System.IO.StreamWriter)" -->
        <member name="M:Lucene.Net.Index.IndexModifier.GetInfoStream">
            <seealso cref="!:IndexModifier.SetInfoStream(PrintStream)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.SetUseCompoundFile(System.Boolean)">
            <summary> Setting to turn on usage of a compound file. When on, multiple files
            for each segment are merged into a single file once the segment creation
            is finished. This is done regardless of what directory is in use.
            </summary>
            <seealso cref="!:IndexWriter.SetUseCompoundFile(boolean)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.GetUseCompoundFile">
            <seealso cref="!:IndexModifier.SetUseCompoundFile(boolean)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.SetMaxFieldLength(System.Int32)">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a field.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.SetMaxFieldLength(System.Int32)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.GetMaxFieldLength">
            <seealso cref="M:Lucene.Net.Index.IndexModifier.SetMaxFieldLength(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexModifier.SetMaxBufferedDocs(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexModifier.GetMaxBufferedDocs">
            <seealso cref="M:Lucene.Net.Index.IndexModifier.SetMaxBufferedDocs(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexModifier.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexModifier.GetMergeFactor">
            <seealso cref="M:Lucene.Net.Index.IndexModifier.SetMergeFactor(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Close">
            <summary> Close this index, writing all pending changes to disk.
            
            </summary>
            <throws>  IllegalStateException if the index has been closed before already </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="T:Lucene.Net.Index.CorruptIndexException">
            <summary> This exception is thrown when Lucene detects
            an inconsistency in the index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.SetBasedFieldSelector">
            <summary> Declare what fields to load normally and what fields to load lazily
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SetBasedFieldSelector.#ctor(System.Collections.Hashtable,System.Collections.Hashtable)">
            <summary> Pass in the Set of {@link Field} names to load and the Set of {@link Field} names to load lazily.  If both are null, the
            Document will not have any {@link Field} on it.  
            </summary>
            <param name="fieldsToLoad">A Set of {@link String} field names to load.  May be empty, but not null
            </param>
            <param name="lazyFieldsToLoad">A Set of {@link String} field names to load lazily.  May be empty, but not null  
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.SetBasedFieldSelector.Accept(System.String)">
            <summary> Indicate whether to load the field with the given name or not. If the {@link Field#Name()} is not in either of the 
            initializing Sets, then {@link Lucene.Net.Documents.FieldSelectorResult#NO_LOAD} is returned.  If a Field name
            is in both <code>fieldsToLoad</code> and <code>lazyFieldsToLoad</code>, lazy has precedence.
            
            </summary>
            <param name="fieldName">The {@link Field} name to check
            </param>
            <returns> The {@link FieldSelectorResult}
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.KeywordTokenizer">
            <summary> Emits the entire input as a single token.</summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
            <summary> A memory-resident {@link IndexOutput} implementation.
            
            </summary>
            <version>  $Id: RAMOutputStream.java 598693 2007-11-27 17:01:21Z mikemccand $
            </version>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.IndexOutput)">
            <summary>Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Reset">
            <summary>Resets this to an empty buffer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(System.String)">
            <summary>Creates a searcher searching the index in the named directory.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Store.Directory)">
            <summary>Creates a searcher searching the index in the provided directory.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.GetIndexReader">
            <summary>Return the {@link IndexReader} this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Close">
            <summary> Note that the underlying IndexReader is not closed, if
            IndexSearcher was constructed with IndexSearcher(IndexReader r).
            If the IndexReader was supplied implicitly by specifying a directory, then
            the IndexReader gets closed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery">
            <summary> A query that wraps a filter and simply returns a constant score equal to the
            query boost for every document in the filter.
            
            
            </summary>
            <version>  $Id: ConstantScoreQuery.java 564236 2007-08-09 15:21:19Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.GetFilter">
            <summary>Returns the encapsulated filter </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>A clause in a BooleanQuery. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>The query whose matching documents are combined by the boolean query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>Constructs a BooleanClause.</summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause.Occur">
            <summary>Specifies how clauses are to occur in matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST">
            <summary>Use this operator for clauses that <i>must</i> appear in the matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.SHOULD">
            <summary>Use this operator for clauses that <i>should</i> appear in the 
            matching documents. For a BooleanQuery with no <code>MUST</code> 
            clauses one or more <code>SHOULD</code> clauses must match a document 
            for the BooleanQuery to match.
            </summary>
            <seealso cref="!:BooleanQuery.setMinimumNumberShouldMatch">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST_NOT">
            <summary>Use this operator for clauses that <i>must not</i> appear in the matching documents.
            Note that it is not possible to search for queries that only consist
            of a <code>MUST_NOT</code> clause. 
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.ParseException.#ctor(Lucene.Net.QueryParsers.Token,System.Int32[][],System.String[])" -->
        <member name="M:Lucene.Net.QueryParsers.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardAnalyzer">
            <summary> Filters {@link StandardTokenizer} with {@link StandardFilter}, {@link
            LowerCaseFilter} and {@link StopFilter}, using a list of English stop words.
            
            </summary>
            <version>  $Id: StandardAnalyzer.java 613280 2008-01-18 21:27:10Z gsingers $
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.DEFAULT_MAX_TOKEN_LENGTH">
            <summary>Default maximum allowed token length </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.replaceInvalidAcronym">
            <summary> Specifies whether deprecated acronyms should be replaced with HOST type.
            This is false by default to support backward compatibility.
            
            </summary>
            <deprecated> this should be removed in the next release (3.0).
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.STOP_WORDS">
            <summary>An array containing some common English words that are usually not
            useful for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor">
            <summary>Builds an analyzer with the default stop words ({@link #STOP_WORDS}). </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.Collections.Hashtable)">
            <summary>Builds an analyzer with the given stop words. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer with the given stop words. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.FileInfo)">
            <summary>Builds an analyzer with the stop words from the given file.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(File)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.TextReader)">
            <summary>Builds an analyzer with the stop words from the given reader.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(Reader)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.Boolean)">
            <summary> </summary>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.TextReader,System.Boolean)">
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.FileInfo,System.Boolean)">
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.String[],System.Boolean)">
            <summary> </summary>
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.Collections.Hashtable,System.Boolean)">
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Constructs a {@link StandardTokenizer} filtered by a {@link
            StandardFilter}, a {@link LowerCaseFilter} and a {@link StopFilter}. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.SetMaxTokenLength(System.Int32)">
            <summary> Set maximum allowed token length.  If a token is seen
            that exceeds this length then it is discarded.  This
            setting only takes effect the next time tokenStream or
            reusableTokenStream is called.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.GetMaxTokenLength">
            <seealso cref="!:setMaxTokenLength">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.IsReplaceInvalidAcronym">
            <summary> </summary>
            <returns> true if this Analyzer is replacing mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.SetReplaceInvalidAcronym(System.Boolean)">
            <summary> </summary>
            <param name="replaceInvalidAcronym">Set to true if this Analyzer is replacing mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </param>
        </member>
        <member name="T:Lucene.Net.Analysis.PorterStemmer">
            <summary> 
            Stemmer, implementing the Porter Stemming Algorithm
            
            The Stemmer class transforms a word into its root form.  The input
            word can be provided a character at time (by calling add()), or at once
            by calling one of the various stem(something) methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Reset">
            <summary> reset() resets the stemmer so it can stem another word.  If you invoke
            the stemmer by calling add(char) and then Stem(), you must call reset()
            before starting another word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Add(System.Char)">
            <summary> Add a character to the word being stemmed.  When you are finished
            adding characters, you can call Stem(void) to process the word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.ToString">
            <summary> After a word has been stemmed, it can be retrieved by toString(),
            or a reference to the internal buffer can be retrieved by getResultBuffer
            and getResultLength (which is generally more efficient.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultLength">
            <summary> Returns the length of the word resulting from the stemming process.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultBuffer">
            <summary> Returns a reference to a character buffer containing the results of
            the stemming process.  You also need to consult getResultLength()
            to determine the length of the result.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.String)">
            <summary> Stem a word provided as a String.  Returns the result as a String.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[])">
            <summary>Stem a word contained in a char[].  Returns true if the stemming process
            resulted in a word different from the input.  You can retrieve the
            result with getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32,System.Int32)">
            <summary>Stem a word contained in a portion of a char[] array.  Returns
            true if the stemming process resulted in a word different from
            the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32)">
            <summary>Stem a word contained in a leading portion of a char[] array.
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem">
            <summary>Stem the word placed into the Stemmer buffer through calls to add().
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Main(System.String[])">
            <summary>Test program for demonstrating the Stemmer.  It reads a file and
            stems each word, writing the result to standard out.
            Usage: Stemmer file-name
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CachingTokenFilter">
            <summary> This class can be used if the Tokens of a TokenStream
            are intended to be consumed more than once. It caches
            all Tokens locally in a List.
            
            CachingTokenFilter implements the optional method
            {@link TokenStream#Reset()}, which repositions the
            stream to the first Token. 
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
            <summary> Methods for manipulating strings.
            
            $Id: StringHelper.java 472959 2006-11-09 16:21:50Z yonik $
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StringDifference(System.String,System.String)">
            <summary> Compares two strings, character by character, and returns the
            first position where the two strings differ from one another.
            
            </summary>
            <param name="s1">The first string to compare
            </param>
            <param name="s2">The second string to compare
            </param>
            <returns> The first position where the two strings differ.
            </returns>
        </member>
        <member name="T:Lucene.Net.Util.BitVector">
            <summary>Optimized implementation of a vector of bits.  This is more-or-less like
            java.util.BitSet, but also includes the following:
            <ul>
            <li>a count() method, which efficiently computes the number of one bits;</li>
            <li>optimized read from and write to disk;</li>
            <li>inlinable get() method;</li>
            <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
            </ul>
            </summary>
            <version>  $Id: BitVector.java 564236 2007-08-09 15:21:19Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(System.Int32)">
            <summary>Constructs a vector capable of holding <code>n</code> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Set(System.Int32)">
            <summary>Sets the value of <code>bit</code> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Clear(System.Int32)">
            <summary>Sets the value of <code>bit</code> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Get(System.Int32)">
            <summary>Returns <code>true</code> if <code>bit</code> is one and
            <code>false</code> if it is zero. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Size">
            <summary>Returns the number of bits in this vector.  This is also one greater than
            the number of the largest valid bit number. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Count">
            <summary>Returns the total number of one bits in this vector.  This is efficiently
            computed and cached, so that, if the vector is not changed, no
            recomputation is done for repeated calls. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Write(Lucene.Net.Store.Directory,System.String)">
            <summary>Writes this vector to the file <code>name</code> in Directory
            <code>d</code>, in a format that can be read by the constructor {@link
            #BitVector(Directory, String)}.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.WriteBits(Lucene.Net.Store.IndexOutput)">
            <summary>Write as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.WriteDgaps(Lucene.Net.Store.IndexOutput)">
            <summary>Write as a d-gaps list </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.IsSparse">
            <summary>Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Constructs a bit vector from the file <code>name</code> in Directory
            <code>d</code>, as written by the {@link #write} method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.ReadBits(Lucene.Net.Store.IndexInput)">
            <summary>Read as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.ReadDgaps(Lucene.Net.Store.IndexInput)">
            <summary>read as a d-gaps list </summary>
        </member>
        <member name="T:Lucene.Net.Search.RemoteSearchable">
            <summary> A remote searchable implementation.
            
            </summary>
            <version>  $Id: RemoteSearchable.java 472959 2006-11-09 16:21:50Z yonik $
            </version>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.#ctor(Lucene.Net.Search.Searchable)">
            <summary>Constructs and exports a remote searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.Main(System.String[])">
            <summary>Exports a searcher for the index in args[0] named
            "//localhost/Searchable". 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.RangeQuery">
            <summary> A Query that matches documents within an exclusive range. A RangeQuery
            is built by QueryParser for input like <code>[010 TO 120]</code> but only if the QueryParser has 
            the useOldRangeQuery property set to true. The QueryParser default behaviour is to use
            the newer ConstantScoreRangeQuery class. This is generally preferable because:
            <ul>
            <li>It is faster than RangeQuery</li>
            <li>Unlike RangeQuery, it does not cause a BooleanQuery.TooManyClauses exception if the range of values is large</li>
            <li>Unlike RangeQuery it does not influence scoring based on the scarcity of individual terms that may match</li>
            </ul>
            
            
            </summary>
            <seealso cref="T:Lucene.Net.Search.ConstantScoreRangeQuery">
            
            
            </seealso>
            <version>  $Id: RangeQuery.java 520891 2007-03-21 13:58:47Z yonik $
            </version>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.Term,System.Boolean)">
            <summary>Constructs a query selecting all terms greater than
            <code>lowerTerm</code> but less than <code>upperTerm</code>.
            There must be at least one term and either term may be null,
            in which case there is no bound on that side, but if there are
            two terms, both terms <b>must</b> be for the same field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetField">
            <summary>Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetLowerTerm">
            <summary>Returns the lower term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetUpperTerm">
            <summary>Returns the upper term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.IsInclusive">
            <summary>Returns <code>true</code> if the range query is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryTermVector">
            <summary> 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryTermVector.#ctor(System.String[])">
            <summary> </summary>
            <param name="queryTerms">The original list of terms from the query, can contain duplicates
            </param>
        </member>
        <member name="T:Lucene.Net.Search.HitIterator">
            <summary> An iterator over {@link Hits} that provides lazy fetching of each document.
            {@link Hits#Iterator()} returns an instance of this class.  Calls to {@link #Next()}
            return a {@link Hit} instance.
            
            </summary>
            <author>  Jeremy Rayner
            </author>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.#ctor(Lucene.Net.Search.Hits)">
            <summary> Constructed from {@link Hits#Iterator()}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.MoveNext">
            <returns> true if current hit is less than the total number of {@link Hits}.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.Remove">
            <summary> Unsupported operation.
            
            </summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.Length">
            <summary> Returns the total number of hits.</summary>
        </member>
        <member name="P:Lucene.Net.Search.HitIterator.Current">
            <summary> Returns a {@link Hit} instance representing the next hit in {@link Hits}.
            
            </summary>
            <returns> Next {@link Hit}.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.FilterManager">
            <summary> Filter caching singleton.  It can be used by {@link Lucene.Net.Search.RemoteCachingWrapperFilter}
            or just to save filters locally for reuse.
            This class makes it possble to cache Filters even when using RMI, as it
            keeps the cache on the seaercher side of the RMI connection.
            
            Also could be used as a persistent storage for any filter as long as the
            filter provides a proper hashCode(), as that is used as the key in the cache.
            
            The cache is periodically cleaned up from a separate thread to ensure the
            cache doesn't exceed the maximum size.
            </summary>
            <author>  Matt Ericson
            </author>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.DEFAULT_CACHE_CLEAN_SIZE">
            <summary>The default maximum number of Filters in the cache </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.DEFAULT_CACHE_SLEEP_TIME">
            <summary>The default frequency of cache clenup </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.cache">
            <summary>The cache itself </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.cacheCleanSize">
            <summary>Maximum allowed cache size </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.cleanSleepTime">
            <summary>Cache cleaning frequency </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.filterCleaner">
            <summary>Cache cleaner that runs in a separate thread </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.#ctor">
            <summary> Sets up the FilterManager singleton.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.SetCacheSize(System.Int32)">
            <summary> Sets the max size that cache should reach before it is cleaned up</summary>
            <param name="cacheCleanSize">maximum allowed cache size
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.SetCleanThreadSleepTime(System.Int64)">
            <summary> Sets the cache cleaning frequency in milliseconds.</summary>
            <param name="cleanSleepTime">cleaning frequency in millioseconds
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.GetFilter(Lucene.Net.Search.Filter)">
            <summary> Returns the cached version of the filter.  Allows the caller to pass up
            a small filter but this will keep a persistent version around and allow
            the caching filter to do its job.
            
            </summary>
            <param name="filter">The input filter
            </param>
            <returns> The cached version of the filter
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.FilterManager.FilterItem">
            <summary> Holds the filter and the last time the filter was used, to make LRU-based
            cache cleaning possible.
            TODO: Clean this up when we switch to Java 1.5
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilterManager.FilterCleaner">
            <summary> Keeps the cache from getting too big.
            If we were using Java 1.5, we could use LinkedHashMap and we would not need this thread
            to clean out the cache.
            
            The SortedSet sortedFilterItems is used only to sort the items from the cache,
            so when it's time to clean up we have the TreeSet sort the FilterItems by
            timestamp.
            
            Removes 1.5 * the numbers of items to make the cache smaller.
            For example:
            If cache clean size is 10, and the cache is at 15, we would remove (15 - 10) * 1.5 = 7.5 round up to 8.
            This way we clean the cache a bit more, and avoid having the cache cleaner having to do it frequently.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ExtendedFieldCache_Fields">
            <summary> 
            
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>Expert: Describes the score computation for document and query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.IsMatch">
            <summary> Indicates whether or not this Explanation models a good match.
            
            <p>
            By default, an Explanation represents a "match" if the value is positive.
            </p>
            </summary>
            <seealso cref="M:Lucene.Net.Search.Explanation.GetValue">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetValue">
            <summary>The value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetValue(System.Single)">
            <summary>Sets the value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDescription">
            <summary>A description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetDescription(System.String)">
            <summary>Sets the description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetSummary">
            <summary> A short one line summary which should contain all high level
            information about this Explanation, without the "Details"
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDetails">
            <summary>The sub-nodes of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>Render an explanation as HTML. </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositions.SkipProx(System.Int64,System.Int32)">
            <summary>Called by super.skipTo(). </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiSegmentReader">
            <summary> An IndexReader which reads indexes with multiple segments.</summary>
        </member>
        <member name="T:Lucene.Net.Index.DirectoryIndexReader">
            <summary> IndexReader implementation that has access to a Directory. 
            Instances that have a SegmentInfos object (i. e. segmentInfos != null)
            "own" the directory, which means that they try to acquire a write lock
            whenever index modifications are performed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DirectoryIndexReader.rollbackHasChanges">
            <summary>Used by commit() to record pre-commit state in case
            rollback is necessary 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.DoReopen(Lucene.Net.Index.SegmentInfos)">
            <summary> Re-opens the index using the passed-in SegmentInfos </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.Directory">
            <summary>Returns the directory this index resides in.</summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.GetVersion">
            <summary> Version number when this IndexReader was opened.</summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.IsCurrent">
            <summary> Check whether this IndexReader is still using the
            current (i.e., most recently committed) version of the
            index.  If a writer has committed any changes to the
            index since this reader was opened, this will return
            <code>false</code>, in which case you must open a new
            IndexReader in order to see the changes.  See the
            description of the <a href="IndexWriter.html#autoCommit"><code>autoCommit</code></a>
            flag which controls when the {@link IndexWriter}
            actually commits changes to the index.
            
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.IsOptimized">
            <summary> Checks is the index is optimized (if it has a single segment and no deletions)</summary>
            <returns> <code>true</code> if the index is optimized; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.DoCommit">
            <summary> Commit changes resulting from delete, undeleteAll, or
            setNorm operations
            
            If an exception is hit, then either no changes or all
            changes will have been committed to the index
            (transactional semantics).
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.AcquireWriteLock">
            <summary> Tries to acquire the WriteLock on this directory.
            this method is only valid if this IndexReader is directory owner.
            
            </summary>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary> since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.StartCommit">
            <summary> Should internally checkpoint state that will change
            during commit so that we can rollback if necessary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.RollbackCommit">
            <summary> Rolls back state to just before the commit (this is
            called by commit() if there is some exception while
            committing).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiSegmentReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary>Construct reading the named set of readers. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiSegmentReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean,Lucene.Net.Index.SegmentReader[],System.Int32[],System.Collections.IDictionary)">
            <summary>This contructor is only used for {@link #Reopen()} </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermEnum" -->
        <member name="M:Lucene.Net.Index.TermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Term">
            <summary>Returns the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.DocFreq">
            <summary>Returns the docFreq of the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermEnum.SkipTo(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.MultiSegmentReader.MultiTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultipleTermPositions">
            <summary> Describe class <code>MultipleTermPositions</code> here.
            
            </summary>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term[])">
            <summary> Creates a new <code>MultipleTermPositions</code> instance.
            
            </summary>
            <exception cref="!:"> IOException
            </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.Term)">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.TermEnum)">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Read(System.Int32[],System.Int32[])">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.GetPayloadLength">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.GetPayload(System.Byte[],System.Int32)">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.IsPayloadAvailable">
            <summary> </summary>
            <returns> false
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.KeywordAnalyzer">
            <summary> "Tokenizes" the entire stream as a single token. This is useful
            for data like zip codes, ids, and some product names.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Constants">
            <summary> Some useful constants.
            
            
            </summary>
            <version>  $Id: Constants.java 564236 2007-08-09 15:21:19Z gsingers $
            
            </version>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION">
            <summary>Lucene.Net Runtime version</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_1_0">
            <summary>True iff Lucene.Net Runtime version is 1.0</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_1_1">
            <summary>True iff Lucene.Net Runtime version is 1.1</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_2_0">
            <summary>True iff Lucene.Net Runtime version is 2.0</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_3_0">
            <summary>True iff Lucene.Net Runtime version is 3.0</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.OS_NAME" -->
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>True iff running on SunOS. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermScorer">
            <summary>Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Index.TermDocs,Lucene.Net.Search.Similarity,System.Byte[])" -->
        <member name="M:Lucene.Net.Search.TermScorer.Doc">
            <summary>Returns the current document number matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Explain(System.Int32)" -->
        <member name="M:Lucene.Net.Search.TermScorer.ToString">
            <summary>Returns a string representation of this <code>TermScorer</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>Removes matches which overlap with another SpanQuery. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetInclude">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetExclude">
            <summary>Return the SpanQuery whose matches must not overlap those returned. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.SpanQueryFilter">
            <summary> Constrains search results to only match those which also match a provided
            query. Also provides position information about where each document matches
            at the cost of extra space compared with the QueryWrapperFilter.
            There is an added cost to this above what is stored in a {@link QueryWrapperFilter}.  Namely,
            the position information for each matching document is stored.
            <p/>
            This filter does not cache.  See the {@link Lucene.Net.Search.CachingSpanFilter} for a wrapper that
            caches.
            
            
            </summary>
            <version>  $Id:$
            </version>
        </member>
        <member name="M:Lucene.Net.Search.SpanQueryFilter.#ctor(Lucene.Net.Search.Spans.SpanQuery)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
            <param name="query">The {@link Lucene.Net.Search.Spans.SpanQuery} to use as the basis for the Filter.
            </param>
        </member>
        <member name="T:Lucene.Net.Search.NonMatchingScorer">
            <summary>A scorer that matches no document at all. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ByteFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.ByteFieldSource.#ctor(System.String)">
            <summary> Create a cached byte field source with default string-to-byte parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ByteFieldSource.#ctor(System.String,Lucene.Net.Search.ByteParser)">
            <summary> Create a cached byte field source with a specific string-to-byte parser. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldSortedHitQueue" -->
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fields">Fieldable names, in priority order (highest priority first).  Cannot be <code>null</code> or empty.
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.comparators">
            <summary>Stores a comparator corresponding to each field being sorted by </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.fields">
            <summary>Stores the sort criteria being used. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.maxscore">
            <summary>Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.GetMaxScore">
            <summary>returns the maximum score encountered by elements inserted via insert()</summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.FillFields(Lucene.Net.Search.FieldDoc)">
            <summary> Given a FieldDoc object, stores the values used
            to sort the given document.  These values are not the raw
            values out of the index, but the internal representation
            of them.  This is so the given search hit can be collated
            by a MultiSearcher with other search hits.
            </summary>
            <param name="doc"> The FieldDoc to store sort values into.
            </param>
            <returns>  The same FieldDoc passed in.
            </returns>
            <seealso cref="M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.GetFields">
            <summary>Returns the SortFields being used by this hit queue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.Comparators">
            <summary>Internal cache of comparators. Similar to FieldCache, only
            caches comparators instead of term values. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorInt(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing integers.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg integer values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorLong(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing integers.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg integer values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorFloat(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing floats.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg float values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorDouble(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing doubles.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg float values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorString(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorStringLocale(Lucene.Net.Index.IndexReader,System.String,System.Globalization.CultureInfo)">
            <summary> Returns a comparator for sorting hits according to a field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to values in the given field.
            The terms in the field are looked at to determine whether they contain integers,
            floats or strings.  Once the type is determined, one of the other static methods
            in this class is called to get the comparator.
            </summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDoc" -->
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="T:Lucene.Net.Search.TopDocs">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.score">
            <summary>Expert: The score of this document for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.doc">
            <summary>Expert: A hit document's number.</summary>
            <seealso cref="!:Searcher#Doc(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Constructs a ScoreDoc. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldDoc.fields">
            <summary>Expert: The values which are used to sort the referenced document.
            The order of these will match the original sort criteria given by a
            Sort object.  Each Object will be either an Integer, Float or String,
            depending on the type of values in the terms of the original field.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Sort">
            </seealso>
            <seealso cref="!:Searcher#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.IComparable[])">
            <summary>Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorEntry">
            <summary> Convenience class for holding TermVector information.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Reset(Lucene.Net.Index.SegmentInfo)">
            <summary> Copy everything from src SegmentInfo into our instance.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.Int32,Lucene.Net.Store.IndexInput)">
            <summary> Construct a new SegmentInfo instance by reading a
            previously saved SegmentInfo from input.
            
            </summary>
            <param name="dir">directory to load from
            </param>
            <param name="format">format of the segments info file
            </param>
            <param name="input">input handle to read segment info from
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SizeInBytes">
            <summary>Returns total size in bytes of all of files used by
            this segment. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfo.HasSeparateNorms(System.Int32)" -->
        <member name="M:Lucene.Net.Index.SegmentInfo.HasSeparateNorms">
            <summary> Returns true if any fields in this segment have separate norms.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AdvanceNormGen(System.Int32)">
            <summary> Increment the generation count for the norms file for
            this field.
            
            </summary>
            <param name="fieldIndex">field whose norm file will be rewritten
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetNormFileName(System.Int32)">
            <summary> Get the file name for the norms file for this field.
            
            </summary>
            <param name="number">field index
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SetUseCompoundFile(System.Boolean)">
            <summary> Mark whether this segment is stored as a compound file.
            
            </summary>
            <param name="isCompoundFile">true if this is a compound file;
            else, false
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetUseCompoundFile">
            <summary> Returns true if this segment is stored as a compound
            file; else, false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Write(Lucene.Net.Store.IndexOutput)">
            <summary> Save this segment's info.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SegString(Lucene.Net.Store.Directory)">
            <summary>Used for debugging </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Equals(System.Object)">
            <summary>We consider another SegmentInfo instance equal if it
            has the same dir and same name. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.LoadFirstFieldSelector">
            <summary> Load the First field and break.
            <p/>
            See {@link FieldSelectorResult#LOAD_AND_BREAK}
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.SimpleAnalyzer">
            <summary>An Analyzer that filters LetterTokenizer with LowerCaseFilter. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.PerFieldAnalyzerWrapper" -->
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs with default analyzer.
            
            </summary>
            <param name="defaultAnalyzer">Any fields not specifically
            defined to use a different analyzer will use the one provided here.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.AddAnalyzer(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary> Defines an analyzer to use for the specified field.
            
            </summary>
            <param name="fieldName">field name requiring a non-default analyzer
            </param>
            <param name="analyzer">non-default analyzer to use for field
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.GetPositionIncrementGap(System.String)">
            <summary>Return the positionIncrementGap from the analyzer assigned to fieldName </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.LowerCaseFilter">
            <summary> Normalizes token text to lower case.
            
            </summary>
            <version>  $Id: LowerCaseFilter.java 564715 2007-08-10 18:34:33Z mikemccand $
            </version>
        </member>
        <member name="T:Lucene.Net.Analysis.LengthFilter">
            <summary> Removes words that are too long and too short from the stream.
            
            
            </summary>
            <version>  $Id: LengthFilter.java 564715 2007-08-10 18:34:33Z mikemccand $
            </version>
        </member>
        <member name="M:Lucene.Net.Analysis.LengthFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Int32,System.Int32)">
            <summary> Build a filter that removes words that are too long or too
            short from the text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LengthFilter.Next(Lucene.Net.Analysis.Token)">
            <summary> Returns the next input Token whose termText() is the right len</summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Boost(System.Single)">
            <summary>for printing boost only if not 1.0 </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMDirectory">
            <summary> A memory-resident {@link Directory} implementation.  Locking
            implementation is by default the {@link SingleInstanceLockFactory}
            but can be changed with {@link #setLockFactory}.
            
            </summary>
            <version>  $Id: RAMDirectory.java 581625 2007-10-03 15:24:12Z mikemccand $
            </version>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>Constructs an empty {@link Directory}. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.IO.FileInfo)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>File</code> specifying the index directory
            
            </param>
            <seealso cref="M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.String)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>String</code> specifying the full index directory path
            
            </param>
            <seealso cref="M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.SizeInBytes">
            <summary>Return total size in bytes of all files in this
            directory.  This is currently quantized to
            RAMOutputStream.BUFFER_SIZE. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.</summary>
            <throws>  FileNotFoundException if from does not exist </throws>
            <deprecated>
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name. Returns a stream writing this file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Close">
            <summary>Closes the store to future operations, releasing associated memory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.EnsureOpen">
            <throws>  AlreadyClosedException if this IndexReader is closed </throws>
        </member>
        <member name="T:Lucene.Net.Search.Spans.TermSpans">
            <summary> Expert:
            Public for extension only
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>Matches the union of its clauses.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>Construct a SpanOrQuery merging the provided clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.SpanFilterResult">
            <summary>  The results of a SpanQueryFilter.  Wraps the BitSet and the position infomration from the SpanQuery
            
            <p/>
            NOTE: This API is still experimental and subject to change. 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.#ctor(System.Collections.BitArray,System.Collections.IList)">
            <summary> </summary>
            <param name="bits">The bits for the Filter
            </param>
            <param name="positions">A List of {@link Lucene.Net.Search.SpanFilterResult.PositionInfo} objects
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.GetPositions">
            <summary> The first entry in the array corresponds to the first "on" bit.
            Entries are increasing by document order
            </summary>
            <returns> A List of PositionInfo objects
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.PositionInfo.GetPositions">
            <summary> </summary>
            <returns> A List of {@link Lucene.Net.Search.SpanFilterResult.StartEnd} objects
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.StartEnd.GetEnd">
            <summary> </summary>
            <returns> The end position of this match
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.StartEnd.GetStart">
            <summary> The Start position</summary>
            <returns> The start position of this match
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarity" -->
        <member name="F:Lucene.Net.Search.Similarity.defaultImpl">
            <summary>The Similarity implementation used by default. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.SetDefault(Lucene.Net.Search.Similarity)">
            <summary>Set the default Similarity implementation used by indexing and search
            code.
            
            </summary>
            <seealso cref="!:Searcher#SetSimilarity(Similarity)">
            </seealso>
            <seealso cref="!:IndexWriter#SetSimilarity(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.GetDefault" -->
        <member name="F:Lucene.Net.Search.Similarity.NORM_TABLE">
            <summary>Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            <summary>Decodes a normalization factor stored in an index.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.GetNormDecoder">
            <summary>Returns a table for decoding normalization bytes.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.LengthNorm(System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.EncodeNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.SloppyFreq(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(Lucene.Net.Index.Term,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Collections.ICollection,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Coord(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.ScorePayload(System.String,System.Byte[],System.Int32,System.Int32)" -->
        <member name="T:Lucene.Net.Index.FilterIndexReader">
            <summary>A <code>FilterIndexReader</code> contains another IndexReader, which it
            uses as its basic source of data, possibly transforming the data along the
            way or providing additional functionality. The class
            <code>FilterIndexReader</code> itself simply implements all abstract methods
            of <code>IndexReader</code> with versions that pass all requests to the
            contained index reader. Subclasses of <code>FilterIndexReader</code> may
            further override some of these methods and may also provide additional
            methods and fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterIndexReader.#ctor(Lucene.Net.Index.IndexReader)">
            <summary> <p>Construct a FilterIndexReader based on the specified base reader.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the base reader.</p>
            <p>Note that base reader is closed if this FilterIndexReader is closed.</p>
            </summary>
            <param name="in">specified base reader.
            </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermDocs">
            <summary>Base class for filtering {@link TermDocs} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermPositions">
            <summary>Base class for filtering {@link TermPositions} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermEnum">
            <summary>Base class for filtering {@link TermEnum} implementations. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsWriter.AddRawDocuments(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32)">
            <summary>Bulk write a contiguous series of documents.  The
            lengths array is the length (in bytes) of each raw
            document.  The stream IndexInput is the
            fieldsStream from which we should bulk-copy all
            bytes. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldsReader">
            <summary> Class responsible for access to stored document fields.
            <p/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            
            </summary>
            <version>  $Id: FieldsReader.java 620759 2008-02-12 11:10:21Z mikemccand $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.EnsureOpen">
            <throws>  AlreadyClosedException if this FieldsReader is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.Close">
            <summary> Closes the underlying {@link Lucene.Net.Store.IndexInput} streams, including any ones associated with a
            lazy implementation of a Field.  This means that the Fields values will not be accessible.
            
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.RawDocs(System.Int32[],System.Int32,System.Int32)">
            <summary>Returns the length in bytes of each raw document in a
            contiguous range of length numDocs starting with
            startDocID.  Returns the IndexInput (the fieldStream),
            already seeked to the starting point for startDocID.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.SkipField(System.Boolean,System.Boolean)">
            <summary> Skip the field.  We still have to read some of the information about the field, but can skip past the actual content.
            This will have the most payoff on large fields.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldsReader.LazyField">
            <summary> A Lazy implementation of Fieldable that differs loading of fields until asked for, instead of when the Document is
            loaded.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.AbstractField">
            <summary> 
            
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.AbstractField.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.AbstractField.GetBoost" -->
        <member name="M:Lucene.Net.Documents.AbstractField.Name">
            <summary>Returns the name of the field as an interned string.
            For example "date", "title", "body", ...
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsStored">
            <summary>True iff the value of the field is to be stored in the index for return
            with search hits.  It is an error for this to be true if a field is
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsIndexed">
            <summary>True iff the value of the field is to be indexed, so that it may be
            searched on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsTokenized">
            <summary>True iff the value of the field should be tokenized as text prior to
            indexing.  Un-tokenized fields are indexed as a single word and may not be
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsCompressed">
            <summary>True if the value of the field is stored and compressed within the index </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsTermVectorStored">
            <summary>True iff the term or terms used to index this field are stored as a term
            vector, available from {@link Lucene.Net.Index.IndexReader#GetTermFreqVector(int,String)}.
            These methods do not provide access to the original content of the field,
            only to terms used to index it. If the original content must be
            preserved, use the <code>stored</code> attribute instead.
            
            </summary>
            <seealso cref="!:String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsStoreOffsetWithTermVector">
            <summary> True iff terms are stored as term vector together with their offsets 
            (start and end positon in source text).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsStorePositionWithTermVector">
            <summary> True iff terms are stored as term vector together with their token positions.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsBinary">
            <summary>True iff the value of the filed is stored as binary </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.GetOmitNorms">
            <summary>True if norms are omitted for this indexed field </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.SetOmitNorms(System.Boolean)">
            <summary>Expert:
            
            If set, omit normalization factors associated with this indexed field.
            This effectively disables indexing boosts and length normalization for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.ToString">
            <summary>Prints a Field for human consumption. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader value,
            String value, or TokenStream value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.TokenStreamValue">
            <summary>The value of the field as a TokesStream, or null.  If null, the Reader value,
            String value, or binary value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.NumberTools" -->
        <member name="F:Lucene.Net.Documents.NumberTools.MIN_STRING_VALUE">
            <summary> Equivalent to longToString(Long.MIN_VALUE)</summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumberTools.MAX_STRING_VALUE">
            <summary> Equivalent to longToString(Long.MAX_VALUE)</summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumberTools.STR_SIZE">
            <summary> The length of (all) strings returned by {@link #longToString}</summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumberTools.LongToString(System.Int64)">
            <summary> Converts a long to a String suitable for indexing.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumberTools.StringToLong(System.String)">
            <summary> Converts a String that was returned by {@link #longToString} back to a
            long.
            
            </summary>
            <throws>  IllegalArgumentException </throws>
            <summary>             if the input is null
            </summary>
            <throws>  NumberFormatException </throws>
            <summary>             if the input does not parse (it was not a String returned by
            longToString()).
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSLockFactory">
            <summary> <p>Implements {@link LockFactory} using {@link
            File#createNewFile()}.  This is the default LockFactory
            for {@link FSDirectory}.</p>
            
            <p><b>NOTE:</b> the <a target="_top" href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile()">javadocs
            for <code>File.createNewFile</code></a> contain a vague
            yet spooky warning about not using the API for file
            locking.  This warning was added due to <a target="_top" href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4676183">this
            bug</a>, and in fact the only known problem with using
            this API for locking is that the Lucene write lock may
            not be released when the JVM exits abnormally.</p>
            <p>When this happens, a {@link LockObtainFailedException}
            is hit when trying to create a writer, in which case you
            need to explicitly clear the lock file first.  You can
            either manually remove the file, or use the {@link
            Lucene.Net.Index.IndexReader#Unlock(Directory)}
            API.  But, first be certain that no writer is in fact
            writing to the index otherwise you can easily corrupt
            your index.</p>
            
            <p>If you suspect that this or any other LockFactory is
            not working properly in your environment, you can easily
            test it by using {@link VerifyingLockFactory}, {@link
            LockVerifyServer} and {@link LockStressTest}.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSLockFactory.lockDir">
            <summary> Directory specified by <code>Lucene.Net.lockDir</code>
            system property.  If that is not set, then <code>java.io.tmpdir</code>
            system property is used.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor">
            <summary> Create a SimpleFSLockFactory instance, with null (unset)
            lock directory.  This is package-private and is only
            used by FSDirectory when creating this LockFactory via
            the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.IO.FileInfo)">
            <summary> Instantiate using the provided directory (as a File instance).</summary>
            <param name="lockDir">where lock files should be created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.String)">
            <summary> Instantiate using the provided directory name (String).</summary>
            <param name="lockDirName">where lock files should be created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.SetLockDir(System.IO.FileInfo)">
            <summary> Set the lock directory.  This is package-private and is
            only used externally by FSDirectory when creating this
            LockFactory via the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.LockReleaseFailedException">
            <summary> This exception is thrown when the <code>write.lock</code>
            could not be released.
            </summary>
            <seealso cref="!:Lock.release().">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.QueryFilter">
            <summary>Constrains search results to only match those which also match a provided
            query.  Results are cached, so that searches after the first on the same
            index using this filter are much faster.
            
            </summary>
            <version>  $Id: QueryFilter.java 528298 2007-04-13 00:59:28Z hossman $
            </version>
            <deprecated> use a CachingWrapperFilter with QueryWrapperFilter
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.QueryFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixQuery">
            <summary>A Query that matches documents containing terms with a specified prefix. A PrefixQuery
            is built by QueryParser for input like <code>app*</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms starting with <code>prefix</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.GetPrefix">
            <summary>Returns the prefix of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredTermEnum" -->
        <member name="M:Lucene.Net.Search.FilteredTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary>Equality compare on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Difference">
            <summary>Equality measure on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.EndEnum">
            <summary>Indicates the end of the enumeration has been reached </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.DocFreq">
            <summary> Returns the docFreq of the current Term in the enumeration.
            Returns -1 if no Term matches or all terms have been enumerated.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Returns null if no Term matches or all terms have been enumerated. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources.  </summary>
        </member>
        <member name="T:Lucene.Net.Search.ComplexExplanation">
            <summary>Expert: Describes the score computation for document and query, andcan distinguish a match independent of a positive value. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ComplexExplanation.GetMatch">
            <summary> The match status of this explanation node.</summary>
            <returns> May be null if match status is unknown
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ComplexExplanation.SetMatch(System.Boolean)">
            <summary> Sets the match status assigned to this explanation node.</summary>
            <param name="match">May be null if match status is unknown
            </param>
        </member>
        <member name="M:Lucene.Net.Search.ComplexExplanation.IsMatch">
            <summary> Indicates wether or not this Explanation models a good match.
            
            <p>
            If the match statis is explicitly set (ie: not null) this method
            uses it; otherwise it defers to the superclass.
            </p>
            </summary>
            <seealso cref="M:Lucene.Net.Search.ComplexExplanation.GetMatch">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>A Query that matches documents matching boolean combinations of other
            queries, e.g. {@link TermQuery}s, {@link PhraseQuery}s or other
            BooleanQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetMaxClauseCount">
            <summary>Return the maximum number of clauses permitted, 1024 by default.
            Attempts to add more than the permitted number of clauses cause {@link
            TooManyClauses} to be thrown.
            </summary>
            <seealso cref="!:#SetMaxClauseCount(int)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.SetMaxClauseCount(System.Int32)" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>Constructs an empty boolean query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)">
            <summary>Constructs an empty boolean query.
            
            {@link Similarity#Coord(int,int)} may be disabled in scoring, as
            appropriate. For example, this score factor does not make sense for most
            automatically generated queries, like {@link WildcardQuery} and {@link
            FuzzyQuery}.
            
            </summary>
            <param name="disableCoord">disables {@link Similarity#Coord(int,int)} in scoring.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.IsCoordDisabled">
            <summary>Returns true iff {@link Similarity#Coord(int,int)} is disabled in
            scoring for this query instance.
            </summary>
            <seealso cref="!:#BooleanQuery(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetMinimumNumberShouldMatch(System.Int32)">
            <summary> Specifies a minimum number of the optional BooleanClauses
            which must be satisfied.
            
            <p>
            By default no optional clauses are necessary for a match
            (unless there are no required clauses).  If this method is used,
            then the specified number of clauses is required.
            </p>
            <p>
            Use of this method is totally independent of specifying that
            any specific clauses are required (or prohibited).  This number will
            only be compared against the number of matching optional clauses.
            </p>
            <p>
            EXPERT NOTE: Using this method may force collecting docs in order,
            regardless of whether setAllowDocsOutOfOrder(true) has been called.
            </p>
            
            </summary>
            <param name="min">the number of optional clauses that must match
            </param>
            <seealso cref="!:setAllowDocsOutOfOrder">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetMinimumNumberShouldMatch">
            <summary> Gets the minimum number of the optional BooleanClauses
            which must be satisifed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>Adds a clause to a boolean query.
            
            </summary>
            <throws>  TooManyClauses if the new number of clauses exceeds the maximum clause number </throws>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)">
            <summary>Adds a clause to a boolean query.</summary>
            <throws>  TooManyClauses if the new number of clauses exceeds the maximum clause number </throws>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>Returns the set of clauses in this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Clauses">
            <summary>Returns the list of clauses in this query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.allowDocsOutOfOrder">
            <summary>Whether hit docs may be collected out of docid order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetAllowDocsOutOfOrder(System.Boolean)">
            <summary> Expert: Indicates whether hit docs may be collected out of docid
            order.
            
            <p>
            Background: although the contract of the Scorer class requires that
            documents be iterated in order of doc id, this was not true in early
            versions of Lucene.  Many pieces of functionality in the current
            Lucene code base have undefined behavior if this contract is not
            upheld, but in some specific simple cases may be faster.  (For
            example: disjunction queries with less than 32 prohibited clauses;
            This setting has no effect for other queries.)
            </p>
            
            <p>
            Specifics: By setting this option to true, calls to 
            {@link HitCollector#Collect(int,float)} might be
            invoked first for docid N and only later for docid N-1.
            Being static, this setting is system wide.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetAllowDocsOutOfOrder">
            <summary> Whether hit docs may be collected out of docid order.</summary>
            <seealso cref="!:SetAllowDocsOutOfOrder(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetUseScorer14(System.Boolean)">
            <deprecated> Use {@link #SetAllowDocsOutOfOrder(boolean)} instead. 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetUseScorer14">
            <deprecated> Use {@link #GetAllowDocsOutOfOrder()} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.SimilarityDelegator">
            <summary>Expert: Delegating scoring implementation.  Useful in {@link
            Query#GetSimilarity(Searcher)} implementations, to override only certain
            methods of a Searcher's Similiarty implementation.. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SimilarityDelegator.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Construct a {@link Similarity} that delegates all methods to another.
            
            </summary>
            <param name="delegee">the Similarity implementation to delegate to
            </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClauses">
            <summary>Thrown when an attempt is made to add more than {@link
            #GetMaxClauseCount()} clauses. This typically happens if
            a PrefixQuery, FuzzyQuery, WildcardQuery, or RangeQuery 
            is expanded to many terms during search. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.BooleanWeight.Scorer(Lucene.Net.Index.IndexReader)">
            <returns> Returns BooleanScorer2 that uses and provides skipTo(),
            and scores documents in document number order.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.TermPositionVector">
            <summary>Extends <code>TermFreqVector</code> to provide additional information about
            positions in which each of the terms is found. A TermPositionVector not necessarily
            contains both positions and offsets, but at least one of these arrays exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetTermPositions(System.Int32)">
            <summary>Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term String array obtained from the <code>indexOf</code> method.
            May return null if positions have not been stored.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetOffsets(System.Int32)">
            <summary> Returns an array of TermVectorOffsetInfo in which the term is found.
            May return null if offsets have not been stored.
            
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.Token">
            
            </seealso>
            <param name="index">The position in the array to get the offsets from
            </param>
            <returns> An array of TermVectorOffsetInfo objects or the empty list
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosWriter" -->
        <member name="F:Lucene.Net.Index.TermInfosWriter.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.indexInterval">
            <summary>Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.skipInterval">
            <summary>Expert: The fraction of {@link TermDocs} entries stored in skip tables,
            used to accellerate {@link TermDocs#SkipTo(int)}.  Larger values result in
            smaller indexes, greater acceleration, but fewer accelerable cases, while
            smaller values result in bigger indexes, less acceleration and more
            accelerable cases. More detailed experiments would be useful here. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.maxSkipLevels">
            <summary>Expert: The maximum number of skip levels. Smaller values result in 
            slightly smaller indexes, but slower skipping in big posting lists.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermInfosWriter.Add(System.Int32,System.Char[],System.Int32,System.Int32,Lucene.Net.Index.TermInfo)" -->
        <member name="M:Lucene.Net.Index.TermInfosWriter.Close">
            <summary>Called to complete TermInfos creation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosReader" -->
        <member name="M:Lucene.Net.Index.TermInfosReader.SetIndexDivisor(System.Int32)">
            <summary> <p>Sets the indexDivisor, which subsamples the number
            of indexed terms loaded into memory.  This has a
            similar effect as {@link
            IndexWriter#setTermIndexInterval} except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value > 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.</p>
            
            <b>NOTE:</b> you must call this before the term
            index is loaded.  If the index is already loaded,
            an IllegalStateException is thrown.
            
            + @throws IllegalStateException if the term index has
            already been loaded into memory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetIndexDivisor">
            <summary>Returns the indexDivisor.</summary>
            <seealso cref="!:setIndexDivisor">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Size">
            <summary>Returns the number of term/value pairs in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>Returns the offset of the greatest index entry which is less than or equal to term.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.ScanEnum(Lucene.Net.Index.Term)">
            <summary>Scans within block for matching term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(System.Int32)">
            <summary>Returns the nth term in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>Returns the position of a Term in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms">
            <summary>Returns an enumeration of all the Terms and TermInfos in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SnapshotDeletionPolicy">
            <summary>A {@link IndexDeletionPolicy} that wraps around any other
            {@link IndexDeletionPolicy} and adds the ability to hold and
            later release a single "snapshot" of an index.  While
            the snapshot is held, the {@link IndexWriter} will not
            remove any files associated with it even if the index is
            otherwise being actively, arbitrarily changed.  Because
            we wrap another arbitrary {@link IndexDeletionPolicy}, this
            gives you the freedom to continue using whatever {@link
            IndexDeletionPolicy} you would normally want to use with your
            index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot">
            <summary>Take a snapshot of the most recent commit to the
            index.  You must call release() to free this snapshot.
            Note that while the snapshot is held, the files it
            references will not be deleted, which will consume
            additional disk space in your index. If you take a
            snapshot at a particularly bad time (say just before
            you call optimize()) then in the worst case this could
            consume an extra 1X of your total index size, until
            you release the snapshot. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release">
            <summary>Release the currently held snapshot. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommitPoint.GetSegmentsFileName">
            <summary> Get the segments file (<code>segments_N</code>) associated 
            with this commit point.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommitPoint.GetFileNames">
            <summary> Returns all index files referenced by this commit point.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexCommitPoint.Delete" -->
        <member name="T:Lucene.Net.Index.SerialMergeScheduler">
            <summary>A {@link MergeScheduler} that simply does each merge
            sequentially, using the current thread. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.Merge(Lucene.Net.Index.IndexWriter)">
            <summary>Just do the merges in sequence. We do this
            "synchronized" so that even if the application is using
            multiple threads, only one merge may run at a time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.ScanTo(Lucene.Net.Index.Term)">
            <summary>Optimized scan, without allocating new terms. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Prev">
            <summary>Returns the previous Term enumerated. Initially null.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo">
            <summary>Returns the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo(Lucene.Net.Index.TermInfo)">
            <summary>Sets the argument to the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.DocFreq">
            <summary>Returns the docFreq from the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader">
            <version>  $Id: SegmentReader.java 603061 2007-12-10 21:49:41Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.IncRef">
            <summary> Increments the RC of this reader, as well as
            of all norms this reader is using
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.IncRefReaderNotNorms">
            <summary> only increments the RC of this reader, not tof 
            he norms. This is important whenever a reopen()
            creates a new SegmentReader that doesn't share
            the norms with this one 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReader.IMPL">
            <summary>The class which implements SegmentReader. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo,System.Int32)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo,System.Int32,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentInfo,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.SegmentInfos,System.Boolean,System.Boolean,System.Int32)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.SegmentInfos,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Document(System.Int32,Lucene.Net.Documents.FieldSelector)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <seealso cref="!:IndexReader.GetFieldNames(IndexReader.FieldOption fldOption)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Read norms into a pre-allocated array. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermVectorsReader">
            <summary> Create a clone from the initial TermVectorsReader and store it in the ThreadLocal.</summary>
            <returns> TermVectorsReader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>Return a term frequency vector for the specified document and field. The
            vector returned contains term numbers and frequencies for all terms in
            the specified field of this document, if the field had storeTermVector
            flag set.  If the flag was not set, the method returns null.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized field in the document.
            Each vector vector contains term numbers and frequencies for all terms
            in a given vectorized field.
            If no such fields existed, the method returns null.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.FieldInfos">
            <summary>Returns the field infos of this segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetSegmentName">
            <summary> Return the name of the segment this reader is reading.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetSegmentInfo">
            <summary> Return the SegmentInfo of the segment this reader is reading.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norm.Close">
            <summary>Closes the underlying IndexInput for this norm.
            It is still valid to access all other norm properties after close is called.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Index.PositionBasedTermVectorMapper">
            <summary> For each Field, store position by position information.  It ignores frequency information
            <p/>
            This is not thread-safe.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.PositionBasedTermVectorMapper.currentPositions">
            <summary> A Map of Integer and TVPositionInfo</summary>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.#ctor">
            <summary> 
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.IsIgnoringPositions">
            <summary> Never ignores positions.  This mapper doesn't make much sense unless there are positions</summary>
            <returns> false
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.Map(System.String,System.Int32,Lucene.Net.Index.TermVectorOffsetInfo[],System.Int32[])">
            <summary> Callback for the TermVectorReader. </summary>
            <param name="term">
            </param>
            <param name="frequency">
            </param>
            <param name="offsets">
            </param>
            <param name="positions">
            </param>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.SetExpectations(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary> Callback mechanism used by the TermVectorReader</summary>
            <param name="field"> The field being read
            </param>
            <param name="numTerms">The number of terms in the vector
            </param>
            <param name="storeOffsets">Whether offsets are available
            </param>
            <param name="storePositions">Whether positions are available
            </param>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.GetFieldToTerms">
            <summary> Get the mapping between fields and terms, sorted by the comparator
            
            </summary>
            <returns> A map between field names and a Map.  The sub-Map key is the position as the integer, the value is {@link Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo}.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo">
            <summary> Container for a term at a position</summary>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.GetPosition">
            <summary> </summary>
            <returns> The position of the term
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.GetTerms">
            <summary> Note, there may be multiple terms at the same position</summary>
            <returns> A List of Strings
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.GetOffsets">
            <summary> Parallel list (to {@link #GetTerms()}) of TermVectorOffsetInfo objects.  There may be multiple entries since there may be multiple terms at a position</summary>
            <returns> A List of TermVectorOffsetInfo objects, if offsets are store.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.Document" -->
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>Constructs a new document with no fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFieldsCount">
            <summary>Returns the number of fields in this document</summary>
            Added as a helper for Lucene.Net
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Documents.Fieldable)">
            <summary> <p>Adds a field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</p>
            <p> Note that add like the removeField(s) methods only makes sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary> <p>Removes field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first field that has been added.
            If there is no field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary> <p>Removes all fields with the given name from the document.
            If there is no field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>Returns a field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            Do not use this method with lazy loaded fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFieldable(System.String)">
            <summary>Returns a field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>Returns the string value of the field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Fields">
            <summary>Returns an Enumeration of all the fields in a document.</summary>
            <deprecated> use {@link #GetFields()} instead
            </deprecated>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.GetFields" -->
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary> Returns an array of {@link Field}s with the given name.
            This method can return <code>null</code>.
            Do not use with lazy loaded fields.
            
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a <code>Field[]</code> array
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFieldables(System.String)">
            <summary> Returns an array of {@link Fieldable}s with the given name.
            This method can return <code>null</code>.
            
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a <code>Fieldable[]</code> array or <code>null</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary> Returns an array of values of the field specified as the method parameter.
            This method can return <code>null</code>.
            
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a <code>String[]</code> of field values or <code>null</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValues(System.String)">
            <summary> Returns an array of byte arrays for of the fields that have the name specified
            as the method parameter. This method will return <code>null</code> if no
            binary fields with the specified name are available.
            
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a  <code>byte[][]</code> of binary field values or <code>null</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValue(System.String)">
            <summary> Returns an array of bytes for the first (or only) field that has the name
            specified as the method parameter. This method will return <code>null</code>
            if no binary fields with the specified name are available.
            There may be non-binary fields with the same name.
            
            </summary>
            <param name="name">the name of the field.
            </param>
            <returns> a <code>byte[]</code> containing the binary field value or <code>null</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TeeTokenFilter">
            <summary> Works in conjunction with the SinkTokenizer to provide the ability to set aside tokens
            that have already been analyzed.  This is useful in situations where multiple fields share
            many common analysis steps and then go their separate ways.
            <p/>
            It is also useful for doing things like entity extraction or proper noun analysis as
            part of the analysis workflow and saving off those tokens for use in another field.
            
            <pre>
            SinkTokenizer sink1 = new SinkTokenizer(null);
            SinkTokenizer sink2 = new SinkTokenizer(null);
            TokenStream source1 = new TeeTokenFilter(new TeeTokenFilter(new WhitespaceTokenizer(reader1), sink1), sink2);
            TokenStream source2 = new TeeTokenFilter(new TeeTokenFilter(new WhitespaceTokenizer(reader2), sink1), sink2);
            TokenStream final1 = new LowerCaseFilter(source1);
            TokenStream final2 = source2;
            TokenStream final3 = new EntityDetect(sink1);
            TokenStream final4 = new URLDetect(sink2);
            d.add(new Field("f1", final1));
            d.add(new Field("f2", final2));
            d.add(new Field("f3", final3));
            d.add(new Field("f4", final4));
            </pre>
            In this example, sink1 and sink2 will both get tokens from both reader1 and reader2 after whitespace tokenizer
            and now we can further wrap any of these in extra analysis, and more "sources" can be inserted if desired.
            Note, the EntityDetect and URLDetect TokenStreams are for the example and do not currently exist in Lucene
            <p/>
            
            See http://issues.apache.org/jira/browse/LUCENE-1058
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.SinkTokenizer">
            
            
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered.SpansCell">
            <summary>Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqOptSumScorer" -->
        <member name="F:Lucene.Net.Search.ReqOptSumScorer.reqScorer">
            <summary>The scorers passed from the constructor.
            These are set to null as soon as their next() or skipTo() returns false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Construct a <code>ReqOptScorer</code>.</summary>
            <param name="reqScorer">The required scorer. This must match.
            </param>
            <param name="optScorer">The optional scorer. This is used for scoring only.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
            <returns> The score of the required scorer, eventually increased by the score
            of the optional scorer when it also matches the current document.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Explain(System.Int32)">
            <summary>Explain the score of a document.</summary>
            <todo>  Also show the total score. </todo>
            <summary> See BooleanScorer.explain() on how to do this.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyQuery">
            <summary>Implements the fuzzy search query. The similiarity measurement
            is based on the Levenshtein (edit distance) algorithm.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single,System.Int32)">
            <summary> Create a new FuzzyQuery that will match terms with a similarity 
            of at least <code>minimumSimilarity</code> to <code>term</code>.
            If a <code>prefixLength</code> &gt; 0 is specified, a common prefix
            of that length is also required.
            
            </summary>
            <param name="term">the term to search for
            </param>
            <param name="minimumSimilarity">a value between 0 and 1 to set the required similarity
            between the query term and the matching terms. For example, for a
            <code>minimumSimilarity</code> of <code>0.5</code> a term of the same length
            as the query term is considered similar to the query term if the edit distance
            between both terms is less than <code>length(term)*0.5</code>
            </param>
            <param name="prefixLength">length of common (non-fuzzy) prefix
            </param>
            <throws>  IllegalArgumentException if minimumSimilarity is &gt;= 1 or &lt; 0 </throws>
            <summary> or if prefixLength &lt; 0
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, minimumSimilarity, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, 0.5f, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetMinSimilarity">
            <summary> Returns the minimum similarity that is required for this query to match.</summary>
            <returns> float value between 0.0 and 1.0
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetPrefixLength">
            <summary> Returns the non-fuzzy prefix length. This is the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.CustomScoreQuery" -->
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.#ctor(Lucene.Net.Search.Query)">
            <summary> Create a CustomScoreQuery over input subQuery.</summary>
            <param name="subQuery">the sub query whose scored is being customed. Must not be null. 
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Function.ValueSourceQuery)">
            <summary> Create a CustomScoreQuery over input subQuery and a {@link ValueSourceQuery}.</summary>
            <param name="subQuery">the sub query whose score is being customed. Must not be null.
            </param>
            <param name="valSrcQuery">a value source query whose scores are used in the custom score
            computation. For most simple/convineient use case this would be a 
            {@link Lucene.Net.Search.Function.FieldScoreQuery FieldScoreQuery}.
            This parameter is optional - it can be null.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Function.ValueSourceQuery[])">
            <summary> Create a CustomScoreQuery over input subQuery and a {@link ValueSourceQuery}.</summary>
            <param name="subQuery">the sub query whose score is being customed. Must not be null.
            </param>
            <param name="valSrcQueries">value source queries whose scores are used in the custom score
            computation. For most simple/convineient use case these would be 
            {@link Lucene.Net.Search.Function.FieldScoreQuery FieldScoreQueries}.
            This parameter is optional - it can be null or even an empty array.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.CustomScoreQuery.CustomScore(System.Int32,System.Single,System.Single[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.CustomScoreQuery.CustomScore(System.Int32,System.Single,System.Single)" -->
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.CustomExplain(System.Int32,Lucene.Net.Search.Explanation,Lucene.Net.Search.Explanation[])">
            <summary> Explain the custom score.
            Whenever overriding {@link #CustomScore(int, float, float[])}, 
            this method should also be overridden to provide the correct explanation
            for the part of the custom scoring.
            
            </summary>
            <param name="doc">doc being explained.
            </param>
            <param name="subQueryExpl">explanation for the sub-query part.
            </param>
            <param name="valSrcExpls">explanation for the value source part.
            </param>
            <returns> an explanation for the custom score
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.CustomExplain(System.Int32,Lucene.Net.Search.Explanation,Lucene.Net.Search.Explanation)">
            <summary> Explain the custom score.
            Whenever overriding {@link #CustomScore(int, float, float)}, 
            this method should also be overridden to provide the correct explanation
            for the part of the custom scoring.
            
            </summary>
            <param name="doc">doc being explained.
            </param>
            <param name="subQueryExpl">explanation for the sub-query part.
            </param>
            <param name="valSrcExpl">explanation for the value source part.
            </param>
            <returns> an explanation for the custom score
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.CustomScoreQuery.IsStrict" -->
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.SetStrict(System.Boolean)">
            <summary> Set the strict mode of this query. </summary>
            <param name="strict">The strict mode to set.
            </param>
            <seealso cref="M:Lucene.Net.Search.Function.CustomScoreQuery.IsStrict">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.Name">
            <summary> A short name of this query, used in {@link #ToString(String)}.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Function.CustomScoreQuery.CustomScorer">
            <summary> A scorer that applies a (callback) function on scores of the subQuery.</summary>
        </member>
        <member name="T:Lucene.Net.LucenePackage">
            <summary>Lucene's package information, including version. *</summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorOffsetInfo">
            <summary> The TermVectorOffsetInfo class holds information pertaining to a Term in a {@link Lucene.Net.Index.TermPositionVector}'s
            offset information.  This offset information is the character offset as set during the Analysis phase (and thus may not be the actual offset in the
            original content).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermVectorOffsetInfo.EMPTY_OFFSET_INFO">
            <summary> Convenience declaration when creating a {@link Lucene.Net.Index.TermPositionVector} that stores only position information.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorOffsetInfo.GetEndOffset">
            <summary> The accessor for the ending offset for the term</summary>
            <returns> The offset
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorOffsetInfo.GetStartOffset">
            <summary> The accessor for the starting offset of the term.
            
            </summary>
            <returns> The offset
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorOffsetInfo.Equals(System.Object)">
            <summary> Two TermVectorOffsetInfos are equals if both the start and end offsets are the same</summary>
            <param name="o">The comparison Object
            </param>
            <returns> true if both {@link #GetStartOffset()} and {@link #GetEndOffset()} are the same for both objects.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.Term">
            <summary>A Term represents a word from text.  This is the unit of search.  It is
            composed of two elements, the text of the word, as a string, and the name of
            the field that the text occured in, an interned string.
            Note that terms may represent more than words from text fields, but also
            things like dates, email addresses, urls, etc.  
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.#ctor(System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.Term.Field">
            <summary>Returns the field of this term, an interned string.   The field indicates
            the part of a document which this term came from. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>Returns the text of this term.  In the case of words, this is simply the
            text of the word.  In the case of dates and other types, this is an
            encoding of the object as a string.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CreateTerm(System.String)">
            <summary> Optimized construction of new Terms by reusing same field as this Term
            - avoids field.intern() overhead 
            </summary>
            <param name="text">The text of the new term (field is implicitly same as this Term instance)
            </param>
            <returns> A new Term
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.Term.Equals(System.Object)">
            <summary>Compares two terms, returning true iff they have the same
            field and text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.GetHashCode">
            <summary>Combines the hashCode() of the field and the text. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
            <summary>Compares two terms, returning a negative integer if this
            term belongs before the argument, zero if this term is equal to the
            argument, and a positive integer if this term belongs after the argument.
            The ordering of terms is first by field, then by text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Set(System.String,System.String)">
            <summary>Resets the field and text of a Term. </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileNames">
            <summary> Useful constants representing filenames and extensions used by lucene
            
            </summary>
            <author>  Bernhard Messer
            </author>
            <version>  $rcs = ' $Id: Exp $ ' ;
            </version>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS">
            <summary>Name of the index segment file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS_GEN">
            <summary>Name of the generation reference file name </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.DELETABLE">
            <summary>Name of the index deletable file (only used in
            pre-lockless indices) 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.NORMS_EXTENSION">
            <summary>Extension of norms file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FREQ_EXTENSION">
            <summary>Extension of freq postings file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.PROX_EXTENSION">
            <summary>Extension of prox postings file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.TERMS_EXTENSION">
            <summary>Extension of terms file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.TERMS_INDEX_EXTENSION">
            <summary>Extension of terms index file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FIELDS_INDEX_EXTENSION">
            <summary>Extension of stored fields index file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FIELDS_EXTENSION">
            <summary>Extension of stored fields file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTORS_FIELDS_EXTENSION">
            <summary>Extension of vectors fields file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTORS_DOCUMENTS_EXTENSION">
            <summary>Extension of vectors documents file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTORS_INDEX_EXTENSION">
            <summary>Extension of vectors index file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_EXTENSION">
            <summary>Extension of compound file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_STORE_EXTENSION">
            <summary>Extension of compound file for doc store files</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.DELETES_EXTENSION">
            <summary>Extension of deletes </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FIELD_INFOS_EXTENSION">
            <summary>Extension of field infos </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.PLAIN_NORMS_EXTENSION">
            <summary>Extension of plain norms </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEPARATE_NORMS_EXTENSION">
            <summary>Extension of separate norms </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.GEN_EXTENSION">
            <summary>Extension of gen file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS">
            <summary> This array contains all filename extensions used by
            Lucene's index files, with two exceptions, namely the
            extension made up from <code>.f</code> + a number and
            from <code>.s</code> + a number.  Also note that
            Lucene's <code>segments_N</code> files do not have any
            filename extension.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE">
            <summary>File extensions that are added to a compound file
            (same as above, minus "del", "gen", "cfs"). 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_EXTENSIONS">
            <summary>File extensions of old-style index files </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTOR_EXTENSIONS">
            <summary>File extensions for term vector support </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)" -->
        <member name="M:Lucene.Net.Index.IndexFileNames.IsDocStoreFile(System.String)">
            <summary> Returns true if the provided filename is one of the doc
            store files (ends with an extension in
            STORE_INDEX_EXTENSIONS).
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field">
            <summary>A field is a section of a Document.  Each field has two parts, a name and a
            value.  Values may be free text, provided as a String or as a Reader, or they
            may be atomic keywords, which are not further processed.  Such keywords may
            be used to represent dates, urls, etc.  Fields are optionally stored in the
            index, so that they may be returned with hits on the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader value,
            String value, or TokenStream value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.TokenStreamValue">
            <summary>The value of the field as a TokesStream, or null.  If null, the Reader value,
            String value, or binary value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.String)">
            <summary><p>Expert: change the value of this field.  This can
            be used during indexing to re-use a single Field
            instance to improve indexing speed by avoiding GC cost
            of new'ing and reclaiming Field instances.  Typically
            a single {@link Document} instance is re-used as
            well.  This helps most on small documents.</p>
            
            <p>Note that you should only use this method after the
            Field has been consumed (ie, the {@link Document}
            containing this Field has been added to the index).
            Also, each Field instance should only be used once
            within a single {@link Document} instance.  See <a
            href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed">ImproveIndexingSpeed</a>
            for details.</p> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.IO.TextReader)">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.Byte[])">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(Lucene.Net.Analysis.TokenStream)">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index)">
            <summary> Create a field by specifying its name, value and how it will
            be saved in the index. Term vectors will not be stored in the index.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The string to process
            </param>
            <param name="store">Whether <code>value</code> should be stored in the index
            </param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing 
            </param>
            <throws>  NullPointerException if name or value is <code>null</code> </throws>
            <throws>  IllegalArgumentException if the field is neither stored nor indexed  </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a field by specifying its name, value and how it will
            be saved in the index.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The string to process
            </param>
            <param name="store">Whether <code>value</code> should be stored in the index
            </param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing 
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or value is <code>null</code> </throws>
            <throws>  IllegalArgumentException in any of the following situations: </throws>
            <summary> <ul> 
            <li>the field is neither stored nor indexed</li> 
            <li>the field is not indexed but termVector is <code>TermVector.YES</code></li>
            </ul> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader)">
            <summary> Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored.  The Reader is read only when the Document is added to the index,
            i.e. you may not close the Reader until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="reader">The reader with the content
            </param>
            <throws>  NullPointerException if name or reader is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  The Reader is read only when the Document is added to the index,
            i.e. you may not close the Reader until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="reader">The reader with the content
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or reader is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary> Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored. This is useful for pre-analyzed fields.
            The TokenStream is read only when the Document is added to the index,
            i.e. you may not close the TokenStream until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="tokenStream">The TokenStream with the content
            </param>
            <throws>  NullPointerException if name or tokenStream is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  This is useful for pre-analyzed fields.
            The TokenStream is read only when the Document is added to the index,
            i.e. you may not close the TokenStream until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="tokenStream">The TokenStream with the content
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or tokenStream is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],Lucene.Net.Documents.Field.Store)">
            <summary> Create a stored field with binary value. Optionally the value may be compressed.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The binary value
            </param>
            <param name="store">How <code>value</code> should be stored (compressed or not)
            </param>
            <throws>  IllegalArgumentException if store is <code>Store.NO</code>  </throws>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Store">
            <summary>Specifies whether and how a field should be stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.COMPRESS">
            <summary>Store the original field value in the index in a compressed form. This is
            useful for long documents and for binary valued fields.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.YES">
            <summary>Store the original field value in the index. This is useful for short texts
            like a document's title which should be displayed with the results. The
            value is stored in its original form, i.e. no analyzer is used before it is
            stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.NO">
            <summary>Do not store the field value in the index. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Index">
            <summary>Specifies whether and how a field should be indexed. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO">
            <summary>Do not index the field value. This field can thus not be searched,
            but one can still access its contents provided it is
            {@link Field.Store stored}. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.TOKENIZED">
            <summary>Index the field's value so it can be searched. An Analyzer will be used
            to tokenize and possibly further normalize the text before its
            terms will be stored in the index. This is useful for common text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.UN_TOKENIZED">
            <summary>Index the field's value without using an Analyzer, so it can be searched.
            As no analyzer is used the value will be stored as a single term. This is
            useful for unique Ids like product numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO_NORMS">
            <summary>Index the field's value without an Analyzer, and disable
            the storing of norms.  No norms means that index-time boosting
            and field length normalization will be disabled.  The benefit is
            less memory usage as norms take up one byte per indexed field
            for every document in the index.
            Note that once you index a given field <i>with</i> norms enabled,
            disabling norms will have no effect.  In other words, for NO_NORMS
            to have the above described effect on a field, all instances of that
            field must be indexed with NO_NORMS from the beginning.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.TermVector">
            <summary>Specifies whether and how a field should have term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.NO">
            <summary>Do not store term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.YES">
            <summary>Store the term vectors of each document. A term vector is a list
            of the document's terms and their number of occurences in that document. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
            <summary> Store the term vector + token position information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
            <summary> Store the term vector + Token offset information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS">
            <summary> Store the term vector + Token position and offset information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
            <seealso cref="!:#WITH_POSITIONS">
            </seealso>
            <seealso cref="!:#WITH_OFFSETS">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.NearSpansOrdered" -->
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.subSpans">
            <summary>The spans in the same order as the SpanNearQuery </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.inSameDoc">
            <summary>Indicates that all subSpans have same doc() </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.AdvanceAfterOrdered">
            <summary>Advances the subSpans to just after an ordered match with a minimum slop
            that is smaller than the slop allowed by the SpanNearQuery.
            </summary>
            <returns> true iff there is such a match.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ToSameDoc">
            <summary>Advance the subSpans to the same document </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(Lucene.Net.Search.Spans.Spans,Lucene.Net.Search.Spans.Spans)">
            <summary>Check whether two Spans in the same document are ordered.</summary>
            <param name="spans1">
            </param>
            <param name="spans2">
            </param>
            <returns> true iff spans1 starts before spans2
            or the spans start at the same position,
            and spans1 ends before spans2.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Like {@link #DocSpansOrdered(Spans,Spans)}, but use the spans
            starts and ends as parameters.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.StretchToOrder">
            <summary>Order the subSpans within the same document by advancing all later spans
            after the previous one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ShrinkToAfterShortestMatch">
            <summary>The subSpans are ordered in the same doc, so there is a possible match.
            Compute the slop while making the match as short as possible by advancing
            all subSpans except the last one in reverse order.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqExclScorer" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Construct a <code>ReqExclScorer</code>.</summary>
            <param name="reqScorer">The scorer that must match, except where
            </param>
            <param name="exclScorer">indicates exclusion.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.ToNonExcluded" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
            <returns> The score of the required scorer.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.SkipTo(System.Int32)" -->
        <member name="T:Lucene.Net.Search.Hit">
            <summary> Wrapper used by {@link HitIterator} to provide a lazily loaded hit
            from {@link Hits}.
            
            </summary>
            <author>  Jeremy Rayner
            </author>
        </member>
        <member name="M:Lucene.Net.Search.Hit.#ctor(Lucene.Net.Search.Hits,System.Int32)">
            <summary> Constructed from {@link HitIterator}</summary>
            <param name="hits">Hits returned from a search
            </param>
            <param name="hitNumber">Hit index in Hits
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetDocument">
            <summary> Returns document for this hit.
            
            </summary>
            <seealso cref="M:Lucene.Net.Search.Hits.Doc(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetScore">
            <summary> Returns score for this hit.
            
            </summary>
            <seealso cref="M:Lucene.Net.Search.Hits.Score(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetId">
            <summary> Returns id for this hit.
            
            </summary>
            <seealso cref="!:Hits#Id(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetBoost">
            <summary> Returns the boost factor for this hit on any field of the underlying document.
            
            </summary>
            <seealso cref="M:Lucene.Net.Documents.Document.GetBoost">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Hit.Get(System.String)">
            <summary> Returns the string value of the field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns null.
            
            </summary>
            <seealso cref="M:Lucene.Net.Documents.Document.Get(System.String)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Hit.ToString">
            <summary> Prints the parameters to be used to discover the promised result.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ShortFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.ShortFieldSource.#ctor(System.String)">
            <summary> Create a cached short field source with default string-to-short parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ShortFieldSource.#ctor(System.String,Lucene.Net.Search.ShortParser)">
            <summary> Create a cached short field source with a specific string-to-short parser. </summary>
        </member>
        <member name="T:Lucene.Net.Search.DefaultSimilarity">
            <summary>Expert: Default scoring implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.LengthNorm(System.String,System.Int32)">
            <summary>Implemented as <code>1/sqrt(numTerms)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Tf(System.Single)">
            <summary>Implemented as <code>sqrt(freq)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Idf(System.Int32,System.Int32)">
            <summary>Implemented as <code>log(numDocs/(docFreq+1)) + 1</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>Implemented as <code>overlap / maxOverlap</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.QueryParser" -->
        <member name="F:Lucene.Net.QueryParsers.QueryParser.AND_OPERATOR">
            <summary>Alternative form of QueryParser.Operator.AND </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.OR_OPERATOR">
            <summary>Alternative form of QueryParser.Operator.OR </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.operator_Renamed">
            <summary>The actual operator that parser uses to combine query terms </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Constructs a query parser.</summary>
            <param name="f"> the default field for query terms.
            </param>
            <param name="a">  used to find terms in the query text.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Parse(System.String)">
            <summary>Parses a query string, returning a {@link Lucene.Net.Search.Query}.</summary>
            <param name="query"> the query string to be parsed.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetAnalyzer">
            <returns> Returns the analyzer.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetField">
            <returns> Returns the field.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyMinSim">
            <summary> Get the minimal similarity for fuzzy queries.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyMinSim(System.Single)">
            <summary> Set the minimum similarity for fuzzy queries.
            Default is 0.5f.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyPrefixLength">
            <summary> Get the prefix length for fuzzy queries. </summary>
            <returns> Returns the fuzzyPrefixLength.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyPrefixLength(System.Int32)">
            <summary> Set the prefix length for fuzzy queries. Default is 0.</summary>
            <param name="fuzzyPrefixLength">The fuzzyPrefixLength to set.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetPhraseSlop(System.Int32)">
            <summary> Sets the default slop for phrases.  If zero, then exact phrase matches
            are required.  Default value is zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetPhraseSlop">
            <summary> Gets the default slop for phrases.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.SetAllowLeadingWildcard(System.Boolean)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetAllowLeadingWildcard">
            <seealso cref="!:SetAllowLeadingWildcard(boolean)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.SetEnablePositionIncrements(System.Boolean)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetEnablePositionIncrements">
            <seealso cref="!:SetEnablePositionIncrements(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDefaultOperator(Lucene.Net.QueryParsers.QueryParser.Operator)">
            <summary> Sets the boolean operator of the QueryParser.
            In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
            are considered optional: for example <code>capital of Hungary</code> is equal to
            <code>capital OR of OR Hungary</code>.<br/>
            In <code>AND_OPERATOR</code> mode terms are considered to be in conjuction: the
            above mentioned query is parsed as <code>capital AND of AND Hungary</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetDefaultOperator">
            <summary> Gets implicit operator setting, which will be either AND_OPERATOR
            or OR_OPERATOR.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLowercaseExpandedTerms(System.Boolean)">
            <summary> Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
            lower-cased or not.  Default is <code>true</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLowercaseExpandedTerms">
            <seealso cref="!:#SetLowercaseExpandedTerms(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetUseOldRangeQuery(System.Boolean)">
            <summary> By default QueryParser uses new ConstantScoreRangeQuery in preference to RangeQuery
            for range queries. This implementation is generally preferable because it 
            a) Runs faster b) Does not have the scarcity of range terms unduly influence score 
            c) avoids any "TooManyBooleanClauses" exception.
            However, if your application really needs to use the old-fashioned RangeQuery and the above
            points are not required then set this option to <code>true</code>
            Default is <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetUseOldRangeQuery">
            <seealso cref="!:SetUseOldRangeQuery(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLocale(System.Globalization.CultureInfo)">
            <summary> Set locale used by date range parsing.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLocale">
            <summary> Returns current locale, allowing access by subclasses.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDateResolution(Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Sets the default date resolution used by RangeQueries for fields for which no
            specific date resolutions has been set. Field specific resolutions can be set
            with {@link #SetDateResolution(String, DateTools.Resolution)}.
            
            </summary>
            <param name="dateResolution">the default date resolution to set
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDateResolution(System.String,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Sets the date resolution used by RangeQueries for a specific field.
            
            </summary>
            <param name="fieldName">field for which the date resolution is to be set 
            </param>
            <param name="dateResolution">date resolution to set
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetDateResolution(System.String)">
            <summary> Returns the date resolution that is used by RangeQueries for the given field. 
            Returns null, if no default or field specific date resolution has been set
            for the given field.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String,System.Int32)">
            <summary> Base implementation delegates to {@link #GetFieldQuery(String,String)}.
            This method may be overridden, for example, to return
            a SpanNearQuery instead of a PhraseQuery.
            
            </summary>
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeQuery(System.String,System.String,System.String,System.Boolean)">
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList,System.Boolean)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            </param>
            <param name="disableCoord">true if coord scoring should be disabled.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetWildcardQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetPrefixQuery(System.String,System.String)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyQuery(System.String,System.String,System.Single)">
            <summary> Factory method for generating a query (similar to
            {@link #getWildcardQuery}). Called when parser parses
            an input term token that has the fuzzy suffix (~) appended.
            
            </summary>
            <param name="field">Name of the field query will use.
            </param>
            <param name="termStr">Term token to use for building term for the query
            
            </param>
            <returns> Resulting {@link Query} built for the term
            </returns>
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.DiscardEscapeChar(System.String)">
            <summary> Returns a String where the escape char has been
            removed, or kept only once if there was a double escape.
            
            Supports escaped unicode characters, e. g. translates
            <code>A</code> to <code>A</code>.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.HexToInt(System.Char)">
            <summary>Returns the numeric value of the hexadecimal character </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Escape(System.String)">
            <summary> Returns a String where those characters that QueryParser
            expects to be escaped are escaped by a preceding <code>\</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.Main(System.String[])" -->
        <member name="T:Lucene.Net.QueryParsers.QueryParser.Operator">
            <summary>The default operator for parsing queries. 
            Use {@link QueryParser#setDefaultOperator} to change it.
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.MultiFieldQueryParser">
            <summary> A QueryParser which constructs queries to search multiple fields.
            
            
            </summary>
            <version>  $Revision: 564236 $
            </version>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(System.String[],Lucene.Net.Analysis.Analyzer,System.Collections.IDictionary)">
            <summary> Creates a MultiFieldQueryParser. 
            Allows passing of a map with term to Boost, and the boost to apply to each term.
            
            <p>It will, when parse(String query)
            is called, construct a query like this (assuming the query consists of
            two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
            
            <code>
            (title:term1 body:term1) (title:term2 body:term2)
            </code>
            
            <p>When setDefaultOperator(AND_OPERATOR) is set, the result will be:</p>
            
            <code>
            +(title:term1 body:term1) +(title:term2 body:term2)
            </code>
            
            <p>When you pass a boost (title=>5 body=>10) you can get </p>
            
            <code>
            +(title:term1^5.0 body:term1^10.0) +(title:term2^5.0 body:term2^10.0)
            </code>
            
            <p>In other words, all the query's terms must appear, but it doesn't matter in
            what fields they appear.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(System.String[],Lucene.Net.Analysis.Analyzer)">
            <summary> Creates a MultiFieldQueryParser.
            
            <p>It will, when parse(String query)
            is called, construct a query like this (assuming the query consists of
            two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
            
            <code>
            (title:term1 body:term1) (title:term2 body:term2)
            </code>
            
            <p>When setDefaultOperator(AND_OPERATOR) is set, the result will be:</p>
            
            <code>
            +(title:term1 body:term1) +(title:term2 body:term2)
            </code>
            
            <p>In other words, all the query's terms must appear, but it doesn't matter in
            what fields they appear.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String[],System.String[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String,System.String[],Lucene.Net.Search.BooleanClause.Occur[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String[],System.String[],Lucene.Net.Search.BooleanClause.Occur[],Lucene.Net.Analysis.Analyzer)" -->
        <member name="T:Lucene.Net.Index.MultiReader">
            <summary>An IndexReader which reads multiple indexes, appending their content.
            
            </summary>
            <version>  $Id: MultiReader.java 596004 2007-11-17 21:34:23Z buschmi $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])">
            <summary> <p>Construct a MultiReader aggregating the named set of (sub)readers.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the subreaders. </p>
            <p>Note that all subreaders are closed if this Multireader is closed.</p>
            </summary>
            <param name="subReaders">set of (sub)readers
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[],System.Boolean)">
            <summary> <p>Construct a MultiReader aggregating the named set of (sub)readers.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the subreaders. </p>
            </summary>
            <param name="closeSubReaders">indicates whether the subreaders should be closed
            when this MultiReader is closed
            </param>
            <param name="subReaders">set of (sub)readers
            </param>
            <throws>  IOException </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiReader.Reopen" -->
        <member name="M:Lucene.Net.Index.MultiReader.IsCurrent">
            <summary> Checks recursively if all subreaders are up to date. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetVersion">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy">
            <summary> This {@link IndexDeletionPolicy} implementation that
            keeps only the most recent commit and immediately removes
            all prior commits after a new commit is done.  This is
            the default deletion policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnInit(System.Collections.IList)">
            <summary> Deletes all commits except the most recent one.</summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnCommit(System.Collections.IList)">
            <summary> Deletes all commits except the most recent one.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.VERBOSE_REF_COUNTS">
            <summary>Change to true to see details of reference counts when
            infoStream != null 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.SegmentInfos,System.IO.TextWriter,Lucene.Net.Index.DocumentsWriter)">
            <summary> Initialize the deleter: find all previous commits in
            the Directory, incref the files they reference, call
            the policy to let it delete commits.  The incoming
            segmentInfos must have been loaded from a commit point
            and not yet modified.  This will remove any files not
            referenced by any of the commits.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteCommits">
            <summary> Remove the CommitPoints in the commitsToDelete List by
            DecRef'ing all files from each SegmentInfos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)">
            <summary> Writer calls this when it has hit an error and had to
            roll back, to tell us that there may now be
            unreferenced files in the filesystem.  So we re-list
            the filesystem and delete such files.  If segmentName
            is non-null, we will only delete files corresponding to
            that segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Checkpoint(Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary> For definition of "check point" see IndexWriter comments:
            "Clarification: Check Points (and commits)".
            
            Writer calls this when it has made a "consistent
            change" to the index, meaning new files are written to
            the index and the in-memory SegmentInfos have been
            modified to point to those files.
            
            This may or may not be a commit (segments_N may or may
            not have been written).
            
            We simply incref the files referenced by the new
            SegmentInfos and decref the files we had previously
            seen (if any).
            
            If this is a commit, we also call the policy to give it
            a chance to remove other commits.  If any commits are
            removed, we decref their files as well.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.IList)">
            <summary>Delets the specified files, but only if they are new
            (have not yet been incref'd). 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.RefCount">
            <summary> Tracks the reference count for a single index file:</summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.CommitPoint">
            <summary> Holds details for each commit point.  This class is
            also passed to the deletion policy.  Note: this class
            has a natural ordering that is inconsistent with
            equals.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.CommitPoint.GetSegmentsFileName">
            <summary> Get the segments_N file for this commit point.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.CommitPoint.Delete">
            <summary> Called only be the deletion policy, to remove this
            commit point from the index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DocumentsWriter" -->
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetInfoStream(System.IO.TextWriter)">
            <summary>If non-null, various details of indexing are printed
            here. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetRAMBufferSizeMB(System.Double)">
            <summary>Set how much RAM we can use before flushing. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetMaxBufferedDocs(System.Int32)">
            <summary>Set max buffered docs, which means we will flush by
            doc count instead of by RAM usage. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetSegment">
            <summary>Get current segment name we are writing. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetNumDocsInRAM">
            <summary>Returns how many docs are currently buffered in RAM. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetDocStoreSegment">
            <summary>Returns the current doc store segment we are writing
            to.  This will be the same as segment when autoCommit
            * is true. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetDocStoreOffset">
            <summary>Returns the doc offset into the shared doc store for
            the current buffered docs. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.CloseDocStore">
            <summary>Closes the current open doc stores an returns the doc
            store segment name.  This returns null if there are *
            no buffered documents. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Abort(Lucene.Net.Index.AbortException)">
            <summary>Called if we hit an exception when adding docs,
            flushing, etc.  This resets our state, discarding any
            docs added since last flush.  If ae is non-null, it
            contains the root cause exception (which we re-throw
            after we are done aborting). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ResetPostingsData">
            <summary>Reset after a flush </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Flush(System.Boolean)">
            <summary>Flush all pending docs to a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.CreateCompoundFile(System.String)">
            <summary>Build compound file for the segment we just flushed </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetFlushPending">
            <summary>Set flushPending if it is not already set and returns
            whether it was set. This is used by IndexWriter to *
            trigger a single flush even when multiple threads are
            * trying to do so. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.WriteNorms(System.String,System.Int32)">
            <summary>Write norms in the "true" segment format.  This is
            called only during commit, to create the .nrm file. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocumentsWriter.WriteSegment" -->
        <member name="M:Lucene.Net.Index.DocumentsWriter.SegmentFileName(System.String)">
            <summary>Returns the name of the file with this extension, on
            the current segment we are working on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetThreadState(Lucene.Net.Documents.Document,Lucene.Net.Index.Term)">
            <summary>Returns a free (idle) ThreadState that may be used for
            indexing this one document.  This call also pauses if a
            flush is pending.  If delTerm is non-null then we
            buffer this deleted term after the thread state has
            been acquired. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary>Returns true if the caller (IndexWriter) should now
            flush. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.FinishDocument(Lucene.Net.Index.DocumentsWriter.ThreadState)">
            <summary>Does the synchronized work to finish/flush the
            inverted document. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.CopyBytes(Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>Copy numBytes from srcIn to destIn </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetCharsFromString(System.String,System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            Copies an array of chars obtained from a String into a specified array of chars
            </summary>
            <param name="sourceString">The String to get the chars from</param>
            <param name="sourceStart">Position of the String to start getting the chars</param>
            <param name="sourceEnd">Position of the String to end getting the chars</param>
            <param name="destinationArray">Array to return the chars</param>
            <param name="destinationStart">Position of the destination array of chars to start storing the chars</param>
            <returns>An array of chars</returns>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter.ThreadState">
            <summary>Per-thread state.  We keep a separate Posting hash and
            other state for each thread and then merge postings *
            hashes from all threads when writing the segment. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.ResetPostings">
            <summary>Clear the postings hash and return objects back to
            shared pool 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WriteDocument">
            <summary>Move all per-document state that was accumulated in
            the ThreadState into the "real" stores. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.Init(Lucene.Net.Documents.Document,System.Int32)">
            <summary>Initializes shared state for this new document </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.DoPostingSort(Lucene.Net.Index.DocumentsWriter.Posting[],System.Int32)">
            <summary>Do in-place sort of Posting array </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.DoVectorSort(Lucene.Net.Index.DocumentsWriter.PostingVector[],System.Int32)">
            <summary>Do in-place sort of PostingVector array </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.TrimFields">
            <summary>If there are fields we've seen but did not see again
            in the last run, then free them up.  Also reduce
            postings hash size. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.ProcessDocument(Lucene.Net.Analysis.Analyzer)">
            <summary>Tokenizes the fields of a document into Postings </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.PostingEquals(System.Char[],System.Int32)">
            <summary>Test whether the text for current Posting p equals
            current tokenText. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocumentsWriter.ThreadState.ComparePostings(Lucene.Net.Index.DocumentsWriter.Posting,Lucene.Net.Index.DocumentsWriter.Posting)" -->
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WriteFreqVInt(System.Int32)">
            <summary>Write vInt into freq stream of current Posting </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WriteProxVInt(System.Int32)">
            <summary>Write vInt into prox stream of current Posting </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriter.ThreadState.freq">
            <summary>Write byte into freq stream of current Posting </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriter.ThreadState.prox">
            <summary>Write byte into prox stream of current Posting </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WriteProxBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Currently only used to copy a payload into the prox
            stream. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WriteOffsetVInt(System.Int32)">
            <summary>Write vInt into offsets stream of current
            PostingVector 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WriteOffsetByte(System.Byte)">
            <summary>Write byte into offsets stream of current
            PostingVector 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WritePosVInt(System.Int32)">
            <summary>Write vInt into pos stream of current
            PostingVector 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.WritePosByte(System.Byte)">
            <summary>Write byte into pos stream of current
            PostingVector 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData">
            <summary>Holds data associated with a single field, including
            the Postings hash.  A document may have many *
            occurrences for a given field name; we gather all *
            such occurrences here (in docFields) so that we can
            * process the entire field at once. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.CompareTo(System.Object)">
            <summary>So Arrays.sort can sort us. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.SortPostings" -->
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.ProcessField(Lucene.Net.Analysis.Analyzer)">
            <summary>Process all occurrences of one field in the document. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.AddNewVector">
            <summary>Only called when term vectors are enabled.  This
            is called the first time we see a given term for
            each * document, to allocate a PostingVector
            instance that * is used to record data needed to
            write the posting * vectors. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.AddPosition(Lucene.Net.Analysis.Token)">
            <summary>This is the hotspot of indexing: it's called once
            for every term of every document.  Its job is to *
            update the postings byte stream (Postings hash) *
            based on the occurence of a single term. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.RehashPostings(System.Int32)" -->
        <member name="M:Lucene.Net.Index.DocumentsWriter.ThreadState.FieldData.WriteVectors(Lucene.Net.Index.FieldInfo)">
            <summary>Called once per field per document if term vectors
            are enabled, to write the vectors to *
            RAMOutputStream, which is then quickly flushed to
            * the real term vectors files in the Directory. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter.FieldMergeState">
            <summary>Used to merge the postings from multiple ThreadStates
            when creating a segment 
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.WordlistLoader">
            <summary> Loader for text files that represent a list of stopwords.
            
            
            </summary>
            <version>  $Id: WordlistLoader.java 564236 2007-08-09 15:21:19Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Analysis.WordlistLoader.GetWordSet(System.IO.FileInfo)">
            <summary> Loads a text file and adds every line as an entry to a HashSet (omitting
            leading and trailing whitespace). Every line of the file should contain only
            one word. The words need to be in lowercase if you make use of an
            Analyzer which uses LowerCaseFilter (like StandardAnalyzer).
            
            </summary>
            <param name="wordfile">File containing the wordlist
            </param>
            <returns> A HashSet with the file's words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.WordlistLoader.GetWordSet(System.IO.TextReader)">
            <summary> Reads lines from a Reader and adds every line as an entry to a HashSet (omitting
            leading and trailing whitespace). Every line of the Reader should contain only
            one word. The words need to be in lowercase if you make use of an
            Analyzer which uses LowerCaseFilter (like StandardAnalyzer).
            
            </summary>
            <param name="reader">Reader containing the wordlist
            </param>
            <returns> A HashSet with the reader's words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.WordlistLoader.GetStemDict(System.IO.FileInfo)">
            <summary> Reads a stem dictionary. Each line contains:
            <pre>word<b>\t</b>stem</pre>
            (i.e. two tab seperated words)
            
            </summary>
            <returns> stem dictionary that overrules the stemming algorithm
            </returns>
            <throws>  IOException  </throws>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceAnalyzer">
            <summary>An Analyzer that uses WhitespaceTokenizer. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopAnalyzer">
            <summary>Filters LetterTokenizer with LowerCaseFilter and StopFilter. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.StopAnalyzer.ENGLISH_STOP_WORDS">
            <summary>An array containing some common English words that are not usually useful
            for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor">
            <summary>Builds an analyzer which removes words in ENGLISH_STOP_WORDS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.Collections.Hashtable)">
            <summary>Builds an analyzer with the stop words from the given set.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer which removes words in the provided array. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.IO.FileInfo)">
            <summary>Builds an analyzer with the stop words from the given file.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(File)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.IO.TextReader)">
            <summary>Builds an analyzer with the stop words from the given reader.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(Reader)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Filters LowerCaseTokenizer with StopFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopAnalyzer.SavedStreams">
            <summary>Filters LowerCaseTokenizer with StopFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SmallFloat">
            <summary>Floating point numbers smaller than 32 bits.
            
            </summary>
            <author>  yonik
            </author>
            <version>  $Id$
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte(System.Single,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.ByteToFloat(System.Byte,System.Int32,System.Int32)">
            <summary>Converts an 8 bit float to a 32 bit float. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte315(System.Single)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.Byte315ToFloat(System.Byte)">
            <summary>byteToFloat(b, mantissaBits=3, zeroExponent=15) </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte52(System.Single)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.Byte52ToFloat(System.Byte)">
            <summary>byteToFloat(b, mantissaBits=5, zeroExponent=2) </summary>
        </member>
        <member name="T:Lucene.Net.Store.NoLockFactory">
            <summary> Use this {@link LockFactory} to disable locking entirely.
            This LockFactory is used when you call {@link FSDirectory#setDisableLocks}.
            Only one instance of this lock is created.  You should call {@link
            #GetNoLockFactory()} to get the instance.
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Store.LockVerifyServer">
            <summary> Simple standalone server that must be running when you
            use {@link VerifyingLockFactory}.  This server simply
            verifies at most one process holds the lock at a time.
            Run without any args to see usage.
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.LockStressTest">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.WildcardTermEnum" -->
        <member name="F:Lucene.Net.Search.WildcardTermEnum.WILDCARD_STRING">
            <summary>*****************************************
            String equality with support for wildcards
            ******************************************
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.WildcardTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Search.WildcardTermEnum.WildcardEquals(System.String,System.Int32,System.String,System.Int32)">
            <summary> Determines if a word matches a wildcard pattern.
            <small>Work released by Granta Design Ltd after originally being done on
            company time.</small>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.QueryWrapperFilter" -->
        <member name="M:Lucene.Net.Search.QueryWrapperFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyTermEnum" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single,System.Int32)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary> The termCompare method in FuzzyTermEnum uses Levenshtein distance to 
            calculate the distance between the given term and the comparing term. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.min(System.Int32,System.Int32,System.Int32)">
            <summary> Finds and returns the smallest of three integers </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.Similarity(System.String)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.GrowDistanceArray(System.Int32)">
            <summary> Grow the second dimension of the array, so that we can calculate the
            Levenshtein difference.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.GetMaxDistance(System.Int32)">
            <summary> The max Distance is the maximum Levenshtein distance for the text
            compared to some other value that results in score that is
            better than the minimum similarity.
            </summary>
            <param name="m">the length of the "other value"
            </param>
            <returns> the maximum levenshtein distance that we care about
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDocSortedHitQueue" -->
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.#ctor(Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="fields">Fieldable names, in priority order (highest priority first).
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.SetFields(Lucene.Net.Search.SortField[])">
            <summary> Allows redefinition of sort fields if they are <code>null</code>.
            This is to handle the case using ParallelMultiSearcher where the
            original list contains AUTO and we don't know the actual sort
            type until the values come back.  The fields can only be set once.
            This method is thread safe.
            </summary>
            <param name="">fields
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.GetFields">
            <summary>Returns the fields being used to sort. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.HasCollators(Lucene.Net.Search.SortField[])">
            <summary>Returns an array of collators, possibly <code>null</code>.  The collators
            correspond to any SortFields which were given a specific locale.
            </summary>
            <param name="fields">Array of sort fields.
            </param>
            <returns> Array, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ParallelReader" -->
        <member name="M:Lucene.Net.Index.ParallelReader.#ctor">
            <summary>Construct a ParallelReader. 
            <p>Note that all subreaders are closed if this ParallelReader is closed.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.#ctor(System.Boolean)">
            <summary>Construct a ParallelReader. </summary>
            <param name="closeSubReaders">indicates whether the subreaders should be closed
            when this ParallelReader is closed
            </param>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.Add(Lucene.Net.Index.IndexReader)">
            <summary>Add an IndexReader. </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.Add(Lucene.Net.Index.IndexReader,System.Boolean)">
            <summary>Add an IndexReader whose stored fields will not be returned.  This can
            accellerate search when stored fields are only needed from a subset of
            the IndexReaders.
            
            </summary>
            <throws>  IllegalArgumentException if not all indexes contain the same number </throws>
            <summary>     of documents
            </summary>
            <throws>  IllegalArgumentException if not all indexes have the same value </throws>
            <summary>     of {@link IndexReader#MaxDoc()}
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.ParallelReader.Reopen" -->
        <member name="M:Lucene.Net.Index.ParallelReader.IsCurrent">
            <summary> Checks recursively if all subreaders are up to date. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.IsOptimized">
            <summary> Checks recursively if all subindexes are optimized </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.GetVersion">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex">
            <summary> Basic tool to check the health of an index and write a
            new segments file that removes reference to problematic
            segments.  There are many more checks that this tool
            could do but does not yet, eg: reconstructing a segments
            file by looking for all loadable segments (if no segments
            file is found), removing specifically specified segments,
            listing files that exist but are not referenced, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.Check(Lucene.Net.Store.Directory,System.Boolean)">
            <summary>Returns true if index is clean, else false.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateTools" -->
        <member name="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Converts a Date to a string suitable for indexing.
            
            </summary>
            <param name="date">the date to be converted
            </param>
            <param name="resolution">the desired resolution, see
            {@link #Round(Date, DateTools.Resolution)}
            </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
            depeding on <code>resolution</code>; using UTC as timezone 
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Converts a millisecond time to a string suitable for indexing.
            
            </summary>
            <param name="time">the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT
            </param>
            <param name="resolution">the desired resolution, see
            {@link #Round(long, DateTools.Resolution)}
            </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
            depeding on <code>resolution</code>; using UTC as timezone
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToTime(System.String)">
            <summary> Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as the
            number of milliseconds since January 1, 1970, 00:00:00 GMT.
            
            </summary>
            <param name="dateString">the date string to be converted
            </param>
            <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT
            </returns>
            <throws>  ParseException if <code>dateString</code> is not in the  </throws>
            <summary>  expected format 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToDate(System.String)">
            <summary> Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as a
            Date object.
            
            </summary>
            <param name="dateString">the date string to be converted
            </param>
            <returns> the parsed time as a Date object 
            </returns>
            <throws>  ParseException if <code>dateString</code> is not in the  </throws>
            <summary>  expected format 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Limit a date's resolution. For example, the date <code>2004-09-21 13:50:11</code>
            will be changed to <code>2004-09-01 00:00:00</code> when using
            <code>Resolution.MONTH</code>. 
            
            </summary>
            <param name="resolution">The desired resolution of the date to be returned
            </param>
            <returns> the date with all values more precise than <code>resolution</code>
            set to 0 or 1
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Limit a date's resolution. For example, the date <code>1095767411000</code>
            (which represents 2004-09-21 13:50:11) will be changed to 
            <code>1093989600000</code> (2004-09-01 00:00:00) when using
            <code>Resolution.MONTH</code>.
            
            </summary>
            <param name="resolution">The desired resolution of the date to be returned
            </param>
            <returns> the date with all values more precise than <code>resolution</code>
            set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT
            </returns>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools.Resolution">
            <summary>Specifies the time granularity. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)">
            <summary> Expert: allocate a new buffer. 
            Subclasses can allocate differently. 
            </summary>
            <param name="size">size of allocated buffer.
            </param>
            <returns> allocated buffer.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>A Query that matches documents containing a term.
            This may be combined with other terms with a {@link BooleanQuery}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for the term <code>t</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetTerm">
            <summary>Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.PhraseFreq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.InitPhrasePositions" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.IntFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.IntFieldSource.#ctor(System.String)">
            <summary> Create a cached int field source with default string-to-int parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.IntFieldSource.#ctor(System.String,Lucene.Net.Search.IntParser)">
            <summary> Create a cached int field source with a specific string-to-int parser. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredQuery" -->
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary> Constructs a new query which applies a filter to the results of the original query.
            Filter.bits() will be called every time this query is used in a search.
            </summary>
            <param name="query"> Query to be filtered, cannot be <code>null</code>.
            </param>
            <param name="filter">Filter to apply to query results, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.Searcher)">
            <summary> Returns a Weight that applies the filter to the enclosed query's Weight.
            This is accomplished by overriding the Scorer returned by the Weight.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Rewrites the wrapped query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermInfo">
            <summary>A TermInfo is the record of information stored for a term.</summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfo.docFreq">
            <summary>The number of documents which contain the term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositionVector.GetOffsets(System.Int32)">
            <summary> Returns an array of TermVectorOffsetInfo in which the term is found.
            
            </summary>
            <param name="index">The position in the array to get the offsets from
            </param>
            <returns> An array of TermVectorOffsetInfo objects or the empty list
            </returns>
            <seealso cref="T:Lucene.Net.Analysis.Token">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositionVector.GetTermPositions(System.Int32)">
            <summary> Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term String array obtained from the <code>indexOf</code> method.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.MapFieldSelector">
            <summary> A FieldSelector based on a Map of field names to FieldSelectorResults
            
            </summary>
            <author>  Chuck Williams
            </author>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.#ctor(System.Collections.IDictionary)">
            <summary>Create a a MapFieldSelector</summary>
            <param name="fieldSelections">maps from field names (String) to FieldSelectorResults
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.#ctor(System.Collections.IList)">
            <summary>Create a a MapFieldSelector</summary>
            <param name="fields">fields to LOAD.  List of Strings.  All other fields are NO_LOAD.
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.#ctor(System.String[])">
            <summary>Create a a MapFieldSelector</summary>
            <param name="fields">fields to LOAD.  All other fields are NO_LOAD.
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.Accept(System.String)">
            <summary>Load field according to its associated value in fieldSelections</summary>
            <param name="field">a field name
            </param>
            <returns> the fieldSelections value that field maps to or NO_LOAD if none.
            </returns>
        </member>
    </members>
</doc>
